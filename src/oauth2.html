
<script type='text/javascript'>
  "use strict"
  {
    
    const sir_render = function (node, options) {
      try {
        if (typeof node !== 'object') {
          return
        }
        let minWidth = '400px'
        if (options) {
          if (options.minWidth) minWidth = options.minWidth
        }
        if (!node.__clone) {
          node.__clone = window.$.extend(true, {}, node)
        }
        new Oauth2({
          target: document.getElementById('oauth2-svelte-container'),
          props: { node: node.__clone }
        })
        document.getElementById('oauth2-svelte-container').style.width = minWidth
        const nodeIsSidebarTab = !!node.onchange
        if (!nodeIsSidebarTab) {
          const orgResize = node._def.oneditresize
          node._def.oneditresize = function (size) {
            document.getElementById('oauth2-svelte-container').style.width = 'auto'
            if (orgResize) orgResize(size)
            node._def.oneditresize = orgResize
          }
        }
      } catch (e) {
          console.log(e)
      }
    }
    const sir_update = function (node) {
      if (node.__clone) {
        const clone = node.__clone
        delete node.__clone
        clone._version = "6.0.0"
        const defaultKeys = Object.keys(node._def.defaults)
        for (const key of Object.keys(clone)) {
          if (defaultKeys.indexOf(key) === -1) {
            delete clone[key]
          }
        }
        // update config node sidebar
        let updateConfigSidebar = false
        for (const key of defaultKeys) {
          if (node._def.defaults[key].type && node[key] !== clone[key]) {
            updateConfigSidebar = true
            // config has changed, add to or remove from config node and refresh sidebar
            // The official RED.nodes.updateConfigNodeUsers(configNode) seems to have no effect.
            const oldConfig = RED.nodes.node(node[key])
            const newConfig = RED.nodes.node(clone[key])
            // Remove from old config node
            if (oldConfig) {
              oldConfig.users = oldConfig.users.filter(userNode => userNode.id !== node.id)
            }
            // add to new config node
            if (newConfig && !newConfig.users?.find(userNode => userNode.id === node.id)) {
              newConfig.users.push(RED.nodes.node(node.id))
            }
          }
        }
        if (updateConfigSidebar) {
          RED.sidebar.config.refresh()
        }

        Object.assign(node, clone)
      }
    }
    const sir_revert = function (node) {
      delete node.__clone
    }
    const sir_addCurrentNodeVersion = function (node) {
      node._version = '6.0.0'
    }
    function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
            dirty[i] = -1;
        }
        return dirty;
    }
    return -1;
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props)
        if (!keys.has(k) && k[0] !== '$')
            rest[k] = props[k];
    return rest;
}
function compute_slots(slots) {
    const result = {};
    for (const key in slots) {
        result[key] = true;
    }
    return result;
}
function null_to_empty(value) {
    return value == null ? '' : value;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}
function append(target, node) {
    target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
    const append_styles_to = get_root_for_style(target);
    if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element('style');
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet(append_styles_to, style);
    }
}
function get_root_for_style(node) {
    if (!node)
        return document;
    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    if (root && root.host) {
        return root;
    }
    return node.ownerDocument;
}
function append_empty_stylesheet(node) {
    const style_element = element('style');
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element.sheet;
}
function append_stylesheet(node, style) {
    append(node.head || node, style);
    return style.sheet;
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function stop_propagation(fn) {
    return function (event) {
        event.stopPropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
        attr(node, key, attributes[key]);
    }
}
function to_number(value) {
    return value === '' ? null : +value;
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.data === data)
        return;
    text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_style(node, key, value, important) {
    if (value == null) {
        node.style.removeProperty(key);
    }
    else {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
}
function select_option(select, value, mounting) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
    if (!mounting || value !== undefined) {
        select.selectedIndex = -1; // no option should be selected
    }
}
function select_value(select) {
    const selected_option = select.querySelector(':checked');
    return selected_option && selected_option.__value;
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, cancelable, detail);
    return e;
}
class HtmlTag {
    constructor(is_svg = false) {
        this.is_svg = false;
        this.is_svg = is_svg;
        this.e = this.n = null;
    }
    c(html) {
        this.h(html);
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            if (this.is_svg)
                this.e = svg_element(target.nodeName);
            /** #7364  target for <template> may be provided as #document-fragment(11) */
            else
                this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));
            this.t = target.tagName !== 'TEMPLATE' ? target : target.content;
            this.c(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}

// we need to store the information for multiple documents because a Svelte application could also contain iframes
// https://github.com/sveltejs/svelte/issues/3624
const managed_styles = new Map();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_style_information(doc, node) {
    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
    managed_styles.set(doc, info);
    return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = get_root_for_style(node);
    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
    if (!rules[name]) {
        rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        managed_styles.forEach(info => {
            const { ownerNode } = info.stylesheet;
            // there is no ownerNode if it runs on jsdom.
            if (ownerNode)
                detach(ownerNode);
        });
        managed_styles.clear();
    });
}

function create_animation(node, from, fn, params) {
    if (!from)
        return noop;
    const to = node.getBoundingClientRect();
    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop;
    const { delay = 0, duration = 300, easing = identity, 
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay, 
    // @ts-ignore todo:
    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
    let running = true;
    let started = false;
    let name;
    function start() {
        if (css) {
            name = create_rule(node, 0, 1, duration, delay, easing, css);
        }
        if (!delay) {
            started = true;
        }
    }
    function stop() {
        if (css)
            delete_rule(node, name);
        running = false;
    }
    loop(now => {
        if (!started && now >= start_time) {
            started = true;
        }
        if (started && now >= end) {
            tick(1, 0);
            stop();
        }
        if (!running) {
            return false;
        }
        if (started) {
            const p = now - start_time;
            const t = 0 + 1 * easing(p / duration);
            tick(t, 1 - t);
        }
        return true;
    });
    start();
    tick(0, 1);
    return stop;
}
function fix_position(node) {
    const style = getComputedStyle(node);
    if (style.position !== 'absolute' && style.position !== 'fixed') {
        const { width, height } = style;
        const a = node.getBoundingClientRect();
        node.style.position = 'absolute';
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
    }
}
function add_transform(node, a) {
    const b = node.getBoundingClientRect();
    if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
    }
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
/**
 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
 * it can be called from an external module).
 *
 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
 *
 * https://svelte.dev/docs#run-time-svelte-onmount
 */
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
/**
 * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
 *
 * Component events created with `createEventDispatcher` create a
 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
 * property and can contain any type of data.
 *
 * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
 */
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail, { cancelable = false } = {}) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail, { cancelable });
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
            return !event.defaultPrevented;
        }
        return true;
    };
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function tick() {
    schedule_update();
    return resolved_promise;
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
const seen_callbacks = new Set();
let flushidx = 0; // Do *not* move this inside the flush() function
function flush() {
    // Do not reenter flush while dirty components are updated, as this can
    // result in an infinite loop. Instead, let the inner flush handle it.
    // Reentrancy is ok afterwards for bindings etc.
    if (flushidx !== 0) {
        return;
    }
    const saved_component = current_component;
    do {
        // first, call beforeUpdate functions
        // and update components
        try {
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update$1(component.$$);
            }
        }
        catch (e) {
            // reset dirty state to not end up in a deadlocked state and then rethrow
            dirty_components.length = 0;
            flushidx = 0;
            throw e;
        }
        set_current_component(null);
        dirty_components.length = 0;
        flushidx = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
}
function update$1($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}
/**
 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
 */
function flush_render_callbacks(fns) {
    const filtered = [];
    const targets = [];
    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
    targets.forEach((c) => c());
    render_callbacks = filtered;
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
    else if (callback) {
        callback();
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    const options = { direction: 'in' };
    let config = fn(node, params, options);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            started = true;
            delete_rule(node);
            if (is_function(config)) {
                config = config(options);
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}
function create_out_transition(node, fn, params) {
    const options = { direction: 'out' };
    let config = fn(node, params, options);
    let running = true;
    let animation_name;
    const group = outros;
    group.r += 1;
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, 'start'));
        loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(0, 1);
                    dispatch(node, false, 'end');
                    if (!--group.r) {
                        // this will result in `end()` being called,
                        // so we don't need to clean up here
                        run_all(group.c);
                    }
                    return false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(1 - t, t);
                }
            }
            return running;
        });
    }
    if (is_function(config)) {
        wait().then(() => {
            // @ts-ignore
            config = config(options);
            go();
        });
    }
    else {
        go();
    }
    return {
        end(reset) {
            if (reset && config.tick) {
                config.tick(1, 0);
            }
            if (running) {
                if (animation_name)
                    delete_rule(node, animation_name);
                running = false;
            }
        }
    };
}

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function fix_and_outro_and_destroy_block(block, lookup) {
    block.f();
    outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    const updates = [];
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            // defer updates until all the DOM shuffling is done
            updates.push(() => block.p(child_ctx, dirty));
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    run_all(updates);
    return new_blocks;
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
            // if the component was destroyed immediately
            // it will update the `$$.on_destroy` reference to `null`.
            // the destructured on_destroy may still reference to the old array
            if (component.$$.on_destroy) {
                component.$$.on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        flush_render_callbacks($$.after_update);
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: [],
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        if (!is_function(callback)) {
            return noop;
        }
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

/* global RED */

const getBooleanFrom = (property) => {
  return typeof property === 'boolean' ? property : property.toString().toLowerCase() === 'true'
};

const getId = (prop = null) => {
  let id = prop;
  if (!id) {
    id = Date.now() + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
  }
  return id
};

const getFadeDuration = (fading) => {
  let fadeDuration = 800;
  // do not use isNaN with boolean!
  if (typeof fading === 'number' || (typeof fading === 'string' && fading !== 'true' && fading !== 'false')) {
    fadeDuration = Number(fading);
  } else {
    fading = getBooleanFrom(fading);
    if (!fading) fadeDuration = 0;
  }
  return fadeDuration
};

const setInternalValue = (internal, nodeProp, value) => {
  // value must not be undefined, as that can result in strange behaviour but can have other falsy value types (checkbox = false, number = 0)
  if (internal.updateNode && typeof nodeProp !== 'undefined') {
    return nodeProp
  } else if (typeof value !== 'undefined') {
    return value
  } else {
    return ''
  }
};

const initInternal = (nodeProp, value) => {
  const internal = {
    init: true,
    isError: false,
    updateNode: typeof nodeProp !== 'undefined',
    valueHasChanged: false
  };
  // on init set the nodeProp.value else we have the whole node property (with label etc.)
  internal.value = setInternalValue(internal, nodeProp?.value, value);
  internal.oldValue = internal.value;
  return internal
};

const getNewInternal = (nodeProp, value, internal, validateFunction, error, node) => {
  internal.valueHasChanged = internal.updateNode ? nodeProp !== internal.value : internal.value !== value;
  if (internal.valueHasChanged) {
    if (internal.value === internal.oldValue) {
      internal.value = setInternalValue(internal, nodeProp, value);
    }
    internal.oldValue = internal.value;
  }
  if (validateFunction) {
    // add node to validate function to have access to node properties while validating when input field changes
    internal.isError = !validateFunction(internal.value, node);
  } else {
    internal.isError = error;
  }
  return internal
};

// escape "unallowed" jQuery chars
const idSanitizer = (id) => id.replace(/(:|\.|\[|\]|,|=|@)/g, '\\$1');

const setTooltip = (tooltip, tooltipExists, target) => {
  target = idSanitizer(target);

  // delete via popover.tooltip as RED.popover Object has no delete function and removing content will show empty tooltip
  RED.popover.tooltip(window.$(target)).delete();
  tooltipExists = false;
  if (tooltip) {
    // Use RED.popover.create to set the tooltip instead of RED.popover.tooltip as a tooltip can't be interactive (closes on mouseover)
    // don't use a dynamic tooltip via content: () => {tooltip} as this won't work so well on some elements (e.g. label) and Node-RED won't
    // use the string rendered as html but as plain string.
    RED.popover.create({
      tooltip: true,
      target: window.$(target),
      trigger: 'hover',
      size: 'small',
      direction: 'bottom',
      content: RED.utils.renderMarkdown(RED.utils.sanitize(tooltip)),
      delay: { show: 750, hide: 100 },
      interactive: true,
      class: 'sir-NR-popover'
    });
    tooltipExists = true;
  }
  return tooltipExists
};

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}

/* node_modules/svelte-integration-red/components/Row.svelte generated by Svelte v3.58.0 */

function add_css$h(target) {
	append_styles(target, "svelte-njf2hk", ".sir-Row.svelte-njf2hk{clear:both;margin-bottom:12px;display:flex;align-items:center;justify-content:flex-start}.sir-Row > *:not(:last-child){margin-right:7px}.sir-Row.inline button:not(:last-child){margin-right:3px}.sir-Row label{display:inline-block;min-width:105px;width:105px;margin-right:7px;align-items:center;margin-bottom:0px;overflow-wrap:break-word}i, .sir-Row, .sir-Row label{user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}");
}

// (53:0) {:else}
function create_else_block$4(ctx) {
	let div;
	let t;
	let div_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block = /*indented*/ ctx[2] && create_if_block_2$8(ctx);
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			attr(div, "id", /*id*/ ctx[0]);
			attr(div, "class", div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-njf2hk"));
			attr(div, "style", /*style*/ ctx[4]);
			toggle_class(div, "sir-Row", !/*inline*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "click", /*click_handler_1*/ ctx[16]),
					listen(div, "keypress", /*keypress_handler_1*/ ctx[17]),
					listen(div, "keydown", /*keydown_handler_1*/ ctx[18]),
					listen(div, "dblclick", /*dblclick_handler_1*/ ctx[19]),
					listen(div, "mouseenter", /*mouseenter_handler_1*/ ctx[20]),
					listen(div, "mouseleave", /*mouseleave_handler_1*/ ctx[21])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*indented*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$8(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr(div, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*clazz*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-njf2hk"))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 16) {
				attr(div, "style", /*style*/ ctx[4]);
			}

			if (!current || dirty & /*clazz, inline*/ 10) {
				toggle_class(div, "sir-Row", !/*inline*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (46:0) {#if fadeDuration}
function create_if_block$h(ctx) {
	let div;
	let t;
	let div_class_value;
	let div_intro;
	let current;
	let mounted;
	let dispose;
	let if_block = /*indented*/ ctx[2] && create_if_block_1$b(ctx);
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			attr(div, "id", /*id*/ ctx[0]);
			attr(div, "class", div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-njf2hk"));
			attr(div, "style", /*style*/ ctx[4]);
			toggle_class(div, "sir-Row", !/*inline*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "click", /*click_handler*/ ctx[10]),
					listen(div, "keypress", /*keypress_handler*/ ctx[11]),
					listen(div, "keydown", /*keydown_handler*/ ctx[12]),
					listen(div, "dblclick", /*dblclick_handler*/ ctx[13]),
					listen(div, "mouseenter", /*mouseenter_handler*/ ctx[14]),
					listen(div, "mouseleave", /*mouseleave_handler*/ ctx[15])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*indented*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$b(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr(div, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*clazz*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-njf2hk"))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 16) {
				attr(div, "style", /*style*/ ctx[4]);
			}

			if (!current || dirty & /*clazz, inline*/ 10) {
				toggle_class(div, "sir-Row", !/*inline*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);

			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fade, { duration: /*fadeDuration*/ ctx[5] });
					div_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (55:4) {#if indented}
function create_if_block_2$8(ctx) {
	let label;

	return {
		c() {
			label = element("label");
			attr(label, "for", /*id*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, label, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*id*/ 1) {
				attr(label, "for", /*id*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(label);
		}
	};
}

// (48:4) {#if indented}
function create_if_block_1$b(ctx) {
	let label;

	return {
		c() {
			label = element("label");
			attr(label, "for", /*id*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, label, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*id*/ 1) {
				attr(label, "for", /*id*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(label);
		}
	};
}

function create_fragment$l(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$h, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*fadeDuration*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$l($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { id, clazz = '', style = "", inline = false, maximize = false, indented = false, fading = true } = $$props;
	id = id || getId();
	if (!id.toString().startsWith("sir-")) id = "sir-Row-" + id;
	inline = getBooleanFrom(inline);
	maximize = getBooleanFrom(maximize);
	indented = getBooleanFrom(indented);
	const fadeDuration = getFadeDuration(fading);

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dblclick_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function dblclick_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('clazz' in $$props) $$invalidate(3, clazz = $$props.clazz);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('inline' in $$props) $$invalidate(1, inline = $$props.inline);
		if ('maximize' in $$props) $$invalidate(6, maximize = $$props.maximize);
		if ('indented' in $$props) $$invalidate(2, indented = $$props.indented);
		if ('fading' in $$props) $$invalidate(7, fading = $$props.fading);
		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	return [
		id,
		inline,
		indented,
		clazz,
		style,
		fadeDuration,
		maximize,
		fading,
		$$scope,
		slots,
		click_handler,
		keypress_handler,
		keydown_handler,
		dblclick_handler,
		mouseenter_handler,
		mouseleave_handler,
		click_handler_1,
		keypress_handler_1,
		keydown_handler_1,
		dblclick_handler_1,
		mouseenter_handler_1,
		mouseleave_handler_1
	];
}

class Row extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$l,
			create_fragment$l,
			safe_not_equal,
			{
				id: 0,
				clazz: 3,
				style: 4,
				inline: 1,
				maximize: 6,
				indented: 2,
				fading: 7
			},
			add_css$h
		);
	}
}

/* global localStorage, */

// Translation:
// current way with Node-RED tools:
// - an i18nOptions object for the node where we can set a prefix if the Node-Red node is not in the main folder.
// - to translate in a SIR component object just set the node property and set the path within the json file, e.g.: label:{ label.name }.
// - instead of giving the node property you can set an i18n property with the path to the local folder, e.g.: 'test-node/second-node:' or if in the main folder: 'second-node:'
//
// a different approach to the code below is to use the offical way like:
// - direct i18n in html <span data-i18n="test-node/second-node:second-node.label.name"></span>
// - setting to placeholder prop <input type="text" data-i18n="[placeholder]myNode.placeholder.foo">
//
// Sidenote: This translation is only working for custom nodes. Translations for the sir components are within their files.
// This must be done that way, as we must ensure translation, whether SIR is installed or not. Also it seems that Node-Red only initialize translation files
// for nodes registered in the package.json.
// Addition: Since Node-Red 2.0.3 we can't import i18next as this will break all other translations.

localStorage.getItem('editor-language') || navigator.language || 'en-US';

const i18nTranslate = (RED, node = {}, i18nDOM = true, translateThis) => {
  let result = translateThis;
  // i18n can be a string for the local folder path (which we can't have without node) or boolean false if we don't want to translate this one
  if (i18nDOM === false || i18nDOM.toString().trim() === 'false') {
    return result
  }

  let path = '';
  if (typeof i18nDOM === 'string') {
    path = i18nDOM;
  } else if (node) {
    path = node.type;
    let folder = node?._def?.i18nOptions?.folder;
    if (folder) {
      if (!folder.endsWith('/')) {
        folder += '/';
      }
      path = folder + path;
    }
  }
  if (path) {
    if (!path.endsWith(':')) path += ':';
    result = RED._(path + translateThis);
    // RED._() will replace colon with dot, so we have to check if result is like that pattern
    const translateColonReplacedWithDot = translateThis.replaceAll(':', '.');
    if (result === path + translateThis || result === path + translateColonReplacedWithDot || result === translateColonReplacedWithDot) {
      // couldn't find translation
      result = translateThis;
    }
  }
  return result
};

/* node_modules/svelte-integration-red/components/Button.svelte generated by Svelte v3.58.0 */

function add_css$g(target) {
	append_styles(target, "svelte-1ly0frp", ".sir-Button.svelte-1ly0frp{width:fit-content}.minWidth.svelte-1ly0frp{min-width:33px}.red-ui-button-small.svelte-1ly0frp{min-width:21px}button.red-ui-button.sir-Button:not(.primary):not(.disabled):not(:disabled):hover{background:var(--red-ui-secondary-background-hover)}.maximize.svelte-1ly0frp{width:100%}");
}

// (54:2) {#if indented}
function create_if_block_1$a(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (60:4) {#if icon}
function create_if_block$g(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[9] + " svelte-1ly0frp");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 512 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[9] + " svelte-1ly0frp")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (53:0) <Row id="sir-Button-Container-{id}" clazz="{clazz} sir-Button-Container" {inline} {fading}>
function create_default_slot$d(ctx) {
	let t0;
	let button;
	let t1;
	let t2_value = (/*label*/ ctx[1] || '') + "";
	let t2;
	let mounted;
	let dispose;
	let if_block0 = /*indented*/ ctx[3] && create_if_block_1$a();
	let if_block1 = /*icon*/ ctx[9] && create_if_block$g(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			button = element("button");
			if (if_block1) if_block1.c();
			t1 = space();
			t2 = text(t2_value);
			attr(button, "id", /*id*/ ctx[0]);
			attr(button, "style", /*style*/ ctx[12]);
			button.disabled = /*disabled*/ ctx[2];
			attr(button, "type", "button");
			attr(button, "class", "red-ui-button sir-Button svelte-1ly0frp");
			toggle_class(button, "maximize", /*maximize*/ ctx[5]);
			toggle_class(button, "selected", /*selected*/ ctx[11]);
			toggle_class(button, "red-ui-button-small", /*small*/ ctx[6]);
			toggle_class(button, "primary", /*primary*/ ctx[10] && !/*disabled*/ ctx[2]);
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, button, anchor);
			if (if_block1) if_block1.m(button, null);
			append(button, t1);
			append(button, t2);

			if (!mounted) {
				dispose = [
					listen(button, "click", stop_propagation(/*clickHandler*/ ctx[13])),
					listen(button, "mousedown", stop_propagation(/*mousedown_handler*/ ctx[19])),
					listen(button, "mouseup", stop_propagation(/*mouseup_handler*/ ctx[20])),
					listen(button, "mouseenter", stop_propagation(/*mouseenter_handler*/ ctx[21])),
					listen(button, "mouseleave", stop_propagation(/*mouseleave_handler*/ ctx[22]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*indented*/ ctx[3]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_1$a();
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*icon*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$g(ctx);
					if_block1.c();
					if_block1.m(button, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*label*/ 2 && t2_value !== (t2_value = (/*label*/ ctx[1] || '') + "")) set_data(t2, t2_value);

			if (dirty & /*id*/ 1) {
				attr(button, "id", /*id*/ ctx[0]);
			}

			if (dirty & /*style*/ 4096) {
				attr(button, "style", /*style*/ ctx[12]);
			}

			if (dirty & /*disabled*/ 4) {
				button.disabled = /*disabled*/ ctx[2];
			}

			if (dirty & /*maximize*/ 32) {
				toggle_class(button, "maximize", /*maximize*/ ctx[5]);
			}

			if (dirty & /*selected*/ 2048) {
				toggle_class(button, "selected", /*selected*/ ctx[11]);
			}

			if (dirty & /*small*/ 64) {
				toggle_class(button, "red-ui-button-small", /*small*/ ctx[6]);
			}

			if (dirty & /*primary, disabled*/ 1028) {
				toggle_class(button, "primary", /*primary*/ ctx[10] && !/*disabled*/ ctx[2]);
			}
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(button);
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$k(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Button-Container-" + /*id*/ ctx[0],
				clazz: "" + (/*clazz*/ ctx[7] + " sir-Button-Container"),
				inline: /*inline*/ ctx[4],
				fading: /*fading*/ ctx[8],
				$$slots: { default: [create_default_slot$d] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*id*/ 1) row_changes.id = "sir-Button-Container-" + /*id*/ ctx[0];
			if (dirty & /*clazz*/ 128) row_changes.clazz = "" + (/*clazz*/ ctx[7] + " sir-Button-Container");
			if (dirty & /*inline*/ 16) row_changes.inline = /*inline*/ ctx[4];
			if (dirty & /*fading*/ 256) row_changes.fading = /*fading*/ ctx[8];

			if (dirty & /*$$scope, id, style, disabled, maximize, selected, small, primary, label, icon, indented*/ 16785007) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$k($$self, $$props, $$invalidate) {
	let { clazz = '', disabled = false, fading = true, i18n, icon, id, indented = false, inline = false, label, maximize = false, node, primary = false, selected = false, small = false, style = '', tooltip = '' } = $$props;
	small = getBooleanFrom(small);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	inline = getBooleanFrom(inline);
	indented = getBooleanFrom(indented);
	id = id || getId();
	if (label) label = i18nTranslate(RED, node, i18n, label);
	const dispatch = createEventDispatcher();

	function clickHandler(event) {
		dispatch('click', event.details, { cancelable: true });
	}

	// delay creation of tooltips as this needs jQuery and can be called often
	let init = true;

	let tooltipExists = false;

	onMount(() => {
		setTimeout(() => $$invalidate(17, init = false), 1000);
	});

	function mousedown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseup_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(7, clazz = $$props.clazz);
		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ('fading' in $$props) $$invalidate(8, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(14, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(9, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('indented' in $$props) $$invalidate(3, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(4, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(5, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(15, node = $$props.node);
		if ('primary' in $$props) $$invalidate(10, primary = $$props.primary);
		if ('selected' in $$props) $$invalidate(11, selected = $$props.selected);
		if ('small' in $$props) $$invalidate(6, small = $$props.small);
		if ('style' in $$props) $$invalidate(12, style = $$props.style);
		if ('tooltip' in $$props) $$invalidate(16, tooltip = $$props.tooltip);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*init, tooltip, tooltipExists, id*/ 458753) {
			{
				if (!init && (tooltip || tooltipExists)) $$invalidate(18, tooltipExists = setTooltip(tooltip, tooltipExists, '#' + id));
			}
		}

		if ($$self.$$.dirty & /*label, node, i18n*/ 49154) {
			{
				if (label) $$invalidate(1, label = i18nTranslate(RED, node, i18n, label));
			}
		}
	};

	return [
		id,
		label,
		disabled,
		indented,
		inline,
		maximize,
		small,
		clazz,
		fading,
		icon,
		primary,
		selected,
		style,
		clickHandler,
		i18n,
		node,
		tooltip,
		init,
		tooltipExists,
		mousedown_handler,
		mouseup_handler,
		mouseenter_handler,
		mouseleave_handler
	];
}

class Button extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$k,
			create_fragment$k,
			safe_not_equal,
			{
				clazz: 7,
				disabled: 2,
				fading: 8,
				i18n: 14,
				icon: 9,
				id: 0,
				indented: 3,
				inline: 4,
				label: 1,
				maximize: 5,
				node: 15,
				primary: 10,
				selected: 11,
				small: 6,
				style: 12,
				tooltip: 16
			},
			add_css$g
		);
	}
}

/* node_modules/svelte-integration-red/components/Callout.svelte generated by Svelte v3.58.0 */

function add_css$f(target) {
	append_styles(target, "svelte-13nhx2a", ".sir-Row.sir-Callout{display:flex;align-items:center;margin-bottom:12px;border-left-width:5px;border-left-style:solid;border-left-color:#7e7e7e;background-color:#e4e4e4;color:#202020}.sir-Row.sir-Callout.indented{margin-left:112px}.sir-Callout-icon.svelte-13nhx2a.svelte-13nhx2a{padding-left:30px;margin-right:0px}.sir-Callout-icon.svelte-13nhx2a i.svelte-13nhx2a{font-size:3em;min-width:50px}.sir-Callout-icon-small.svelte-13nhx2a.svelte-13nhx2a{padding-left:10px;margin-right:7px}.sir-Callout-icon-small.svelte-13nhx2a i.svelte-13nhx2a{font-size:1.5em;min-width:25px}.sir-Callout-content.svelte-13nhx2a.svelte-13nhx2a{padding:15px 7px}.sir-Callout-content-small.svelte-13nhx2a.svelte-13nhx2a{padding:3px}.sir-Callout-content :is(p, div, span):last-child{padding-bottom:0px;margin-bottom:0px}.hasButton.svelte-13nhx2a.svelte-13nhx2a{padding-right:5px}.close-button.svelte-13nhx2a.svelte-13nhx2a{margin-bottom:auto;margin-left:auto;margin-top:6px;margin-right:6px}.close-button-small.svelte-13nhx2a.svelte-13nhx2a{margin-left:auto;margin-right:6px}.close-button-small.svelte-13nhx2a .sir-Button-Container.svelte-13nhx2a{margin-bottom:0px}.sir-Row.sir-Callout.info{border-left-color:#325c80;background-color:#def0ff;color:#325c80}.sir-Row.sir-Callout.warning{border-left-color:var(--red-ui-border-color-warning);color:var(--red-ui-text-color-warning)}.sir-Row.sir-Callout.error{border-left-color:var(--red-ui-border-color-error);color:var(--red-ui-text-color-error)}.sir-Row.sir-Callout.success{border-left-color:var(--red-ui-border-color-success);color:var(--red-ui-text-color-success)}.sir-Callout :is(h1, h2, h3, h4, h5, h6){margin-top:0px;margin-bottom:10px\n  }.sir-Callout.sir-Row{user-select:text;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text}");
}

const get_header_slot_changes$3 = dirty => ({});
const get_header_slot_context$3 = ctx => ({});

// (145:0) {#if show}
function create_if_block$f(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Callout-" + /*id*/ ctx[3],
				clazz: /*clazz*/ ctx[8] + " sir-Callout " + /*type*/ ctx[0] + (/*indented*/ ctx[4] ? ' indented' : ''),
				style: /*style*/ ctx[6],
				fading: /*fading*/ ctx[9],
				$$slots: { default: [create_default_slot$c] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty & /*id*/ 8) row_changes.id = "sir-Callout-" + /*id*/ ctx[3];
			if (dirty & /*clazz, type, indented*/ 273) row_changes.clazz = /*clazz*/ ctx[8] + " sir-Callout " + /*type*/ ctx[0] + (/*indented*/ ctx[4] ? ' indented' : '');
			if (dirty & /*style*/ 64) row_changes.style = /*style*/ ctx[6];
			if (dirty & /*fading*/ 512) row_changes.fading = /*fading*/ ctx[9];

			if (dirty & /*$$scope, small, show, closeable, $$slots, icon*/ 34982) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

// (149:6) {#if $$slots.header}
function create_if_block_2$7(ctx) {
	let h2;
	let current;
	const header_slot_template = /*#slots*/ ctx[13].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[15], get_header_slot_context$3);

	return {
		c() {
			h2 = element("h2");
			if (header_slot) header_slot.c();
		},
		m(target, anchor) {
			insert(target, h2, anchor);

			if (header_slot) {
				header_slot.m(h2, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[15],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[15], dirty, get_header_slot_changes$3),
						get_header_slot_context$3
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h2);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (154:4) {#if closeable}
function create_if_block_1$9(ctx) {
	let div;
	let button;
	let current;

	button = new Button({
			props: { icon: "close", small: /*small*/ ctx[7] }
		});

	button.$on("click", /*click_handler*/ ctx[14]);

	return {
		c() {
			div = element("div");
			create_component(button.$$.fragment);
			attr(div, "class", "" + (null_to_empty(/*sizeClasses*/ ctx[10].close) + " svelte-13nhx2a"));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*small*/ 128) button_changes.small = /*small*/ ctx[7];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(button);
		}
	};
}

// (146:2) <Row id="sir-Callout-{id}" clazz={clazz + " sir-Callout " + type + (indented ? ' indented' : '')} {style} {fading}>
function create_default_slot$c(ctx) {
	let div0;
	let i;
	let i_class_value;
	let t0;
	let div1;
	let t1;
	let t2;
	let if_block1_anchor;
	let current;
	let if_block0 = /*$$slots*/ ctx[11].header && create_if_block_2$7(ctx);
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
	let if_block1 = /*closeable*/ ctx[1] && create_if_block_1$9(ctx);

	return {
		c() {
			div0 = element("div");
			i = element("i");
			t0 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(i, "class", i_class_value = "" + (null_to_empty(/*icon*/ ctx[2]) + " svelte-13nhx2a"));
			attr(div0, "class", "" + (null_to_empty(/*sizeClasses*/ ctx[10].icon) + " svelte-13nhx2a"));
			attr(div1, "class", "" + (null_to_empty(/*sizeClasses*/ ctx[10].content) + " svelte-13nhx2a"));
			toggle_class(div1, "hasButton", /*closeable*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, i);
			insert(target, t0, anchor);
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			insert(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*icon*/ 4 && i_class_value !== (i_class_value = "" + (null_to_empty(/*icon*/ ctx[2]) + " svelte-13nhx2a"))) {
				attr(i, "class", i_class_value);
			}

			if (/*$$slots*/ ctx[11].header) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$$slots*/ 2048) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$7(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[15],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*closeable*/ 2) {
				toggle_class(div1, "hasButton", /*closeable*/ ctx[1]);
			}

			if (/*closeable*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*closeable*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$9(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t0);
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

function create_fragment$j(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*show*/ ctx[5] && create_if_block$f(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*show*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*show*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$f(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$j($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { clazz = "", closeable = false, fading = true, icon, id, indented = false, show = true, type = 'info', style = "", small = false } = $$props;
	id = id || getId();
	indented = getBooleanFrom(indented);
	closeable = getBooleanFrom(closeable);
	show = getBooleanFrom(show);
	small = getBooleanFrom(small);
	if (type === 'danger') type = 'error';
	let customIcon = false;

	if (icon) {
		customIcon = true;
		icon = icon.trim();

		if (!icon.startsWith('fa fa-')) {
			if (icon.startsWith('fa-')) icon = 'fa ' + icon; else icon = 'fa fa-' + icon;
		}
	}

	let sizeClasses = {
		"icon": small ? "sir-Callout-icon-small" : "sir-Callout-icon",
		"content": small
		? "sir-Callout-content-small"
		: "sir-Callout-content",
		"close": small ? "close-button-small" : "close-button"
	};

	// get the background color by root variable and reduce opacity
	// if background root variable is one day not hex anymore, use rgba(var(--red-ui-border-color-warning), 0.2) in css directly
	if (type === 'warning' || type === 'success' || type === 'error') {
		const r = document.querySelector(':root');
		let backgroundColor = getComputedStyle(r).getPropertyValue('--red-ui-text-color-' + type).trim();

		if (backgroundColor.startsWith('#')) {
			if (backgroundColor.length === 4) {
				// double all digits except the '#'
				backgroundColor = backgroundColor.split('').map(hex => hex + hex).join('').substring(1);
			}

			style = 'background-color: ' + backgroundColor + 20 + '; ' + style;
		}
	}

	const click_handler = () => $$invalidate(5, show = false);

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(8, clazz = $$props.clazz);
		if ('closeable' in $$props) $$invalidate(1, closeable = $$props.closeable);
		if ('fading' in $$props) $$invalidate(9, fading = $$props.fading);
		if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('indented' in $$props) $$invalidate(4, indented = $$props.indented);
		if ('show' in $$props) $$invalidate(5, show = $$props.show);
		if ('type' in $$props) $$invalidate(0, type = $$props.type);
		if ('style' in $$props) $$invalidate(6, style = $$props.style);
		if ('small' in $$props) $$invalidate(7, small = $$props.small);
		if ('$$scope' in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*customIcon, type*/ 4097) {
			{
				if (!customIcon) {
					switch (type) {
						case 'info':
							$$invalidate(2, icon = 'fa fa-info-circle');
							break;
						case 'warning':
							$$invalidate(2, icon = 'fa fa-exclamation-triangle');
							break;
						case 'error':
							$$invalidate(2, icon = 'fa fa-window-close');
							break;
						case 'success':
							$$invalidate(2, icon = 'fa fa-check-circle');
							break;
						default:
							$$invalidate(2, icon = 'fa fa-info-circle');
					}
				}
			}
		}
	};

	return [
		type,
		closeable,
		icon,
		id,
		indented,
		show,
		style,
		small,
		clazz,
		fading,
		sizeClasses,
		$$slots,
		customIcon,
		slots,
		click_handler,
		$$scope
	];
}

class Callout extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$j,
			create_fragment$j,
			safe_not_equal,
			{
				clazz: 8,
				closeable: 1,
				fading: 9,
				icon: 2,
				id: 3,
				indented: 4,
				show: 5,
				type: 0,
				style: 6,
				small: 7
			},
			add_css$f
		);
	}
}

/* node_modules/svelte-integration-red/components/ComponentHeader.svelte generated by Svelte v3.58.0 */

function add_css$e(target) {
	append_styles(target, "svelte-1mxd4a1", ".header.svelte-1mxd4a1.svelte-1mxd4a1{display:inline-flex;align-items:center;width:100%;margin-bottom:6px}.header.svelte-1mxd4a1>.icon.svelte-1mxd4a1{margin-right:3px}.header.svelte-1mxd4a1 .headerContent.svelte-1mxd4a1{display:inline-flex;align-items:center;justify-content:space-between;width:100%}.header.svelte-1mxd4a1 label.svelte-1mxd4a1{width:auto;cursor:initial;min-width:105px;margin-bottom:0px;padding-left:5px}.mousePointer.svelte-1mxd4a1.svelte-1mxd4a1,.mousePointer.svelte-1mxd4a1 label.svelte-1mxd4a1{cursor:pointer}label.svelte-1mxd4a1 i.svelte-1mxd4a1{padding-right:5px}.header.svelte-1mxd4a1 label.svelte-1mxd4a1{width:inherit;display:flex;align-items:center}.labelContainer.svelte-1mxd4a1.svelte-1mxd4a1,.content.svelte-1mxd4a1.svelte-1mxd4a1{user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}");
}

const get_headerExtension_slot_changes = dirty => ({});
const get_headerExtension_slot_context = ctx => ({});

// (67:2) {#if isCollapsible}
function create_if_block_2$6(ctx) {
	let i;

	return {
		c() {
			i = element("i");
			attr(i, "class", "fa fa-angle-right mousePointer icon svelte-1mxd4a1");
			attr(i, "style", /*iconStyle*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*iconStyle*/ 16) {
				attr(i, "style", /*iconStyle*/ ctx[4]);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (71:4) {#if label}
function create_if_block$e(ctx) {
	let label_1;
	let t;
	let if_block = /*icon*/ ctx[3] && create_if_block_1$8(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t = text(/*label*/ ctx[5]);
			attr(label_1, "id", /*id*/ ctx[0]);
			attr(label_1, "for", /*labelFor*/ ctx[6]);
			attr(label_1, "class", "svelte-1mxd4a1");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$8(ctx);
					if_block.c();
					if_block.m(label_1, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*label*/ 32) set_data(t, /*label*/ ctx[5]);

			if (dirty & /*id*/ 1) {
				attr(label_1, "id", /*id*/ ctx[0]);
			}

			if (dirty & /*labelFor*/ 64) {
				attr(label_1, "for", /*labelFor*/ ctx[6]);
			}
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
		}
	};
}

// (73:8) {#if icon}
function create_if_block_1$8(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[3] + " svelte-1mxd4a1");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[3] + " svelte-1mxd4a1")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

function create_fragment$i(ctx) {
	let div1;
	let t0;
	let div0;
	let t1;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*isCollapsible*/ ctx[7] && create_if_block_2$6(ctx);
	let if_block1 = /*label*/ ctx[5] && create_if_block$e(ctx);
	const headerExtension_slot_template = /*#slots*/ ctx[13].headerExtension;
	const headerExtension_slot = create_slot(headerExtension_slot_template, ctx, /*$$scope*/ ctx[12], get_headerExtension_slot_context);

	return {
		c() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div0 = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			if (headerExtension_slot) headerExtension_slot.c();
			attr(div0, "class", "headerContent svelte-1mxd4a1");
			attr(div1, "class", div1_class_value = "header " + /*clazz*/ ctx[2] + " svelte-1mxd4a1");
			attr(div1, "style", /*style*/ ctx[1]);
			toggle_class(div1, "mousePointer", /*isCollapsible*/ ctx[7] && !/*openOnlyOnIcon*/ ctx[8]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t0);
			append(div1, div0);
			if (if_block1) if_block1.m(div0, null);
			append(div0, t1);

			if (headerExtension_slot) {
				headerExtension_slot.m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div1, "mouseenter", /*mouseenter_handler*/ ctx[14]),
					listen(div1, "mouseleave", /*mouseleave_handler*/ ctx[15]),
					listen(div1, "click", /*click_handler*/ ctx[16]),
					listen(div1, "keypress", /*keypress_handler*/ ctx[17]),
					listen(div1, "keydown", /*keydown_handler*/ ctx[18])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*isCollapsible*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$6(ctx);
					if_block0.c();
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*label*/ ctx[5]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$e(ctx);
					if_block1.c();
					if_block1.m(div0, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (headerExtension_slot) {
				if (headerExtension_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						headerExtension_slot,
						headerExtension_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(headerExtension_slot_template, /*$$scope*/ ctx[12], dirty, get_headerExtension_slot_changes),
						get_headerExtension_slot_context
					);
				}
			}

			if (!current || dirty & /*clazz*/ 4 && div1_class_value !== (div1_class_value = "header " + /*clazz*/ ctx[2] + " svelte-1mxd4a1")) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*style*/ 2) {
				attr(div1, "style", /*style*/ ctx[1]);
			}

			if (!current || dirty & /*clazz, isCollapsible, openOnlyOnIcon*/ 388) {
				toggle_class(div1, "mousePointer", /*isCollapsible*/ ctx[7] && !/*openOnlyOnIcon*/ ctx[8]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(headerExtension_slot, local);
			current = true;
		},
		o(local) {
			transition_out(headerExtension_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (headerExtension_slot) headerExtension_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { clazz = "", icon = "", iconStyle = "", id, label = "", labelFor = "", style = "", isCollapsible = false, openOnlyOnIcon = false, tooltip } = $$props;
	if (isCollapsible) style += " margin-bottom: 0px;";
	if (id && !id.endsWith('-Label')) id += '-Label';

	// delay creation of tooltips as this needs jQuery and can be called often
	let init = true;

	let tooltipExists = false;

	onMount(() => {
		setTimeout(() => $$invalidate(10, init = false), 1000);
	});

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(2, clazz = $$props.clazz);
		if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
		if ('iconStyle' in $$props) $$invalidate(4, iconStyle = $$props.iconStyle);
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('label' in $$props) $$invalidate(5, label = $$props.label);
		if ('labelFor' in $$props) $$invalidate(6, labelFor = $$props.labelFor);
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
		if ('isCollapsible' in $$props) $$invalidate(7, isCollapsible = $$props.isCollapsible);
		if ('openOnlyOnIcon' in $$props) $$invalidate(8, openOnlyOnIcon = $$props.openOnlyOnIcon);
		if ('tooltip' in $$props) $$invalidate(9, tooltip = $$props.tooltip);
		if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*init, tooltip, tooltipExists, id*/ 3585) {
			{
				if (!init && (tooltip || tooltipExists)) $$invalidate(11, tooltipExists = setTooltip(tooltip, tooltipExists, '#' + id));
			}
		}
	};

	return [
		id,
		style,
		clazz,
		icon,
		iconStyle,
		label,
		labelFor,
		isCollapsible,
		openOnlyOnIcon,
		tooltip,
		init,
		tooltipExists,
		$$scope,
		slots,
		mouseenter_handler,
		mouseleave_handler,
		click_handler,
		keypress_handler,
		keydown_handler
	];
}

class ComponentHeader extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$i,
			create_fragment$i,
			safe_not_equal,
			{
				clazz: 2,
				icon: 3,
				iconStyle: 4,
				id: 0,
				label: 5,
				labelFor: 6,
				style: 1,
				isCollapsible: 7,
				openOnlyOnIcon: 8,
				tooltip: 9
			},
			add_css$e
		);
	}
}

const subscriber_queue = [];
/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier} [start]
 */
function readable(value, start) {
    return {
        subscribe: writable(value, start).subscribe
    };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=} start
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (const subscriber of subscribers) {
                    subscriber[1]();
                    subscriber_queue.push(subscriber, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            subscribers.delete(subscriber);
            if (subscribers.size === 0 && stop) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}
function derived(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single
        ? [stores]
        : stores;
    const auto = fn.length < 2;
    return readable(initial_value, (set) => {
        let started = false;
        const values = [];
        let pending = 0;
        let cleanup = noop;
        const sync = () => {
            if (pending) {
                return;
            }
            cleanup();
            const result = fn(single ? values[0] : values, set);
            if (auto) {
                set(result);
            }
            else {
                cleanup = is_function(result) ? result : noop;
            }
        };
        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
            values[i] = value;
            pending &= ~(1 << i);
            if (started) {
                sync();
            }
        }, () => {
            pending |= (1 << i);
        }));
        started = true;
        sync();
        return function stop() {
            run_all(unsubscribers);
            cleanup();
            // We need to set this to false because callbacks can still happen despite having unsubscribed:
            // Callbacks might already be placed in the queue which doesn't know it should no longer
            // invoke this derived store.
            started = false;
        };
    });
}

function is_date(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
}

function get_interpolator(a, b) {
    if (a === b || a !== a)
        return () => a;
    const type = typeof a;
    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
        throw new Error('Cannot interpolate values of different type');
    }
    if (Array.isArray(a)) {
        const arr = b.map((bi, i) => {
            return get_interpolator(a[i], bi);
        });
        return t => arr.map(fn => fn(t));
    }
    if (type === 'object') {
        if (!a || !b)
            throw new Error('Object cannot be null');
        if (is_date(a) && is_date(b)) {
            a = a.getTime();
            b = b.getTime();
            const delta = b - a;
            return t => new Date(a + t * delta);
        }
        const keys = Object.keys(b);
        const interpolators = {};
        keys.forEach(key => {
            interpolators[key] = get_interpolator(a[key], b[key]);
        });
        return t => {
            const result = {};
            keys.forEach(key => {
                result[key] = interpolators[key](t);
            });
            return result;
        };
    }
    if (type === 'number') {
        const delta = b - a;
        return t => a + t * delta;
    }
    throw new Error(`Cannot interpolate ${type} values`);
}
function tweened(value, defaults = {}) {
    const store = writable(value);
    let task;
    let target_value = value;
    function set(new_value, opts) {
        if (value == null) {
            store.set(value = new_value);
            return Promise.resolve();
        }
        target_value = new_value;
        let previous_task = task;
        let started = false;
        let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
        if (duration === 0) {
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            store.set(value = target_value);
            return Promise.resolve();
        }
        const start = now() + delay;
        let fn;
        task = loop(now => {
            if (now < start)
                return true;
            if (!started) {
                fn = interpolate(value, new_value);
                if (typeof duration === 'function')
                    duration = duration(value, new_value);
                started = true;
            }
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            const elapsed = now - start;
            if (elapsed > duration) {
                store.set(value = new_value);
                return false;
            }
            // @ts-ignore
            store.set(value = fn(easing(elapsed / duration)));
            return true;
        });
        return task.promise;
    }
    return {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe
    };
}

/* node_modules/svelte-integration-red/components/Collapsible.svelte generated by Svelte v3.58.0 */

function add_css$d(target) {
	append_styles(target, "svelte-1pd8dbj", ".border.svelte-1pd8dbj{padding:12px}.content.svelte-1pd8dbj{width:100%;overflow:hidden}[id^='sir-Collapsible-'].sir-Row.sir-Collapsible, [id^='sir-Collapsible-'].sir-Collapsible{display:inline-flex;flex-direction:column;align-items:flex-start;width:100%}.sir-Collapsible .content .slotDiv .sir-Row:last-child{margin-bottom:0px}[id^='sir-Collapsible-'].sir-Collapsible .slotDiv{display:inline-flex;flex-direction:column;width:100%;padding-top:6px}[id^='sir-Collapsible-'].sir-Collapsible .slotDiv.indented{padding-left:12px;width:calc(100% - 12px)\n  }");
}

const get_default_slot_changes$1 = dirty => ({
	_collapsed: dirty[0] & /*_collapsed*/ 1024
});

const get_default_slot_context$1 = ctx => ({ _collapsed: /*_collapsed*/ ctx[10] });

const get_header_slot_changes$2 = dirty => ({
	_collapsed: dirty[0] & /*_collapsed*/ 1024
});

const get_header_slot_context$2 = ctx => ({
	slot: "headerExtension",
	_collapsed: /*_collapsed*/ ctx[10]
});

// (108:2) {#if label || $$slots.header}
function create_if_block$d(ctx) {
	let componentheader;
	let updating_iconStyle;
	let current;

	function componentheader_iconStyle_binding(value) {
		/*componentheader_iconStyle_binding*/ ctx[27](value);
	}

	let componentheader_props = {
		label: /*label*/ ctx[4],
		labelFor: "sir-Collapsible-" + /*id*/ ctx[1] + "-content",
		id: "sir-Collapsible-" + /*id*/ ctx[1],
		icon: /*icon*/ ctx[6],
		isCollapsible: true,
		openOnlyOnIcon: /*openOnlyOnIcon*/ ctx[7],
		tooltip: /*tooltip*/ ctx[9],
		$$slots: {
			headerExtension: [create_headerExtension_slot$2]
		},
		$$scope: { ctx }
	};

	if (/*iconStyle*/ ctx[14] !== void 0) {
		componentheader_props.iconStyle = /*iconStyle*/ ctx[14];
	}

	componentheader = new ComponentHeader({ props: componentheader_props });
	binding_callbacks.push(() => bind(componentheader, 'iconStyle', componentheader_iconStyle_binding));
	componentheader.$on("click", /*click_handler_1*/ ctx[28]);
	componentheader.$on("mouseenter", /*mouseenter_handler*/ ctx[29]);
	componentheader.$on("mouseleave", /*mouseleave_handler*/ ctx[30]);
	componentheader.$on("click", /*click_handler*/ ctx[31]);

	return {
		c() {
			create_component(componentheader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(componentheader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const componentheader_changes = {};
			if (dirty[0] & /*label*/ 16) componentheader_changes.label = /*label*/ ctx[4];
			if (dirty[0] & /*id*/ 2) componentheader_changes.labelFor = "sir-Collapsible-" + /*id*/ ctx[1] + "-content";
			if (dirty[0] & /*id*/ 2) componentheader_changes.id = "sir-Collapsible-" + /*id*/ ctx[1];
			if (dirty[0] & /*icon*/ 64) componentheader_changes.icon = /*icon*/ ctx[6];
			if (dirty[0] & /*openOnlyOnIcon*/ 128) componentheader_changes.openOnlyOnIcon = /*openOnlyOnIcon*/ ctx[7];
			if (dirty[0] & /*tooltip*/ 512) componentheader_changes.tooltip = /*tooltip*/ ctx[9];

			if (dirty[0] & /*_collapsed*/ 1024 | dirty[1] & /*$$scope*/ 8) {
				componentheader_changes.$$scope = { dirty, ctx };
			}

			if (!updating_iconStyle && dirty[0] & /*iconStyle*/ 16384) {
				updating_iconStyle = true;
				componentheader_changes.iconStyle = /*iconStyle*/ ctx[14];
				add_flush_callback(() => updating_iconStyle = false);
			}

			componentheader.$set(componentheader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(componentheader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(componentheader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(componentheader, detaching);
		}
	};
}

// (111:6) 
function create_headerExtension_slot$2(ctx) {
	let current;
	const header_slot_template = /*#slots*/ ctx[26].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[34], get_header_slot_context$2);

	return {
		c() {
			if (header_slot) header_slot.c();
		},
		m(target, anchor) {
			if (header_slot) {
				header_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty[0] & /*_collapsed*/ 1024 | dirty[1] & /*$$scope*/ 8)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[34],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[34])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[34], dirty, get_header_slot_changes$2),
						get_header_slot_context$2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (107:0) <Row id="sir-Collapsible-{id}" bind:clazz={classes} {inline} {fading} {style} >
function create_default_slot$b(ctx) {
	let t;
	let div1;
	let div0;
	let div1_id_value;
	let current;
	let if_block = (/*label*/ ctx[4] || /*$$slots*/ ctx[18].header) && create_if_block$d(ctx);
	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[34], get_default_slot_context$1);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", "slotDiv");
			toggle_class(div0, "indented", /*indented*/ ctx[2]);
			toggle_class(div0, "_collapsed", /*_collapsed*/ ctx[10]);
			attr(div1, "id", div1_id_value = "sir-Collapsible-" + /*id*/ ctx[1] + "-content");
			attr(div1, "class", "content svelte-1pd8dbj");
			attr(div1, "style", /*slotHeightStyle*/ ctx[12]);
			toggle_class(div1, "red-ui-editableList-border", /*border*/ ctx[0]);
			toggle_class(div1, "border", /*border*/ ctx[0]);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, div1, anchor);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div0_binding*/ ctx[32](div0);
			current = true;
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[4] || /*$$slots*/ ctx[18].header) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*label, $$slots*/ 262160) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$d(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*_collapsed*/ 1024 | dirty[1] & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[34],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[34])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[34], dirty, get_default_slot_changes$1),
						get_default_slot_context$1
					);
				}
			}

			if (!current || dirty[0] & /*indented*/ 4) {
				toggle_class(div0, "indented", /*indented*/ ctx[2]);
			}

			if (!current || dirty[0] & /*_collapsed*/ 1024) {
				toggle_class(div0, "_collapsed", /*_collapsed*/ ctx[10]);
			}

			if (!current || dirty[0] & /*id*/ 2 && div1_id_value !== (div1_id_value = "sir-Collapsible-" + /*id*/ ctx[1] + "-content")) {
				attr(div1, "id", div1_id_value);
			}

			if (!current || dirty[0] & /*slotHeightStyle*/ 4096) {
				attr(div1, "style", /*slotHeightStyle*/ ctx[12]);
			}

			if (!current || dirty[0] & /*border*/ 1) {
				toggle_class(div1, "red-ui-editableList-border", /*border*/ ctx[0]);
			}

			if (!current || dirty[0] & /*border*/ 1) {
				toggle_class(div1, "border", /*border*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			/*div0_binding*/ ctx[32](null);
		}
	};
}

function create_fragment$h(ctx) {
	let row;
	let updating_clazz;
	let current;

	function row_clazz_binding(value) {
		/*row_clazz_binding*/ ctx[33](value);
	}

	let row_props = {
		id: "sir-Collapsible-" + /*id*/ ctx[1],
		inline: /*inline*/ ctx[3],
		fading: /*fading*/ ctx[5],
		style: /*style*/ ctx[8],
		$$slots: { default: [create_default_slot$b] },
		$$scope: { ctx }
	};

	if (/*classes*/ ctx[13] !== void 0) {
		row_props.clazz = /*classes*/ ctx[13];
	}

	row = new Row({ props: row_props });
	binding_callbacks.push(() => bind(row, 'clazz', row_clazz_binding));

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty[0] & /*id*/ 2) row_changes.id = "sir-Collapsible-" + /*id*/ ctx[1];
			if (dirty[0] & /*inline*/ 8) row_changes.inline = /*inline*/ ctx[3];
			if (dirty[0] & /*fading*/ 32) row_changes.fading = /*fading*/ ctx[5];
			if (dirty[0] & /*style*/ 256) row_changes.style = /*style*/ ctx[8];

			if (dirty[0] & /*id, slotHeightStyle, border, slotDiv, indented, _collapsed, label, icon, openOnlyOnIcon, tooltip, iconStyle, $$slots*/ 286423 | dirty[1] & /*$$scope*/ 8) {
				row_changes.$$scope = { dirty, ctx };
			}

			if (!updating_clazz && dirty[0] & /*classes*/ 8192) {
				updating_clazz = true;
				row_changes.clazz = /*classes*/ ctx[13];
				add_flush_callback(() => updating_clazz = false);
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	let iconStyle;
	let classes;
	let slotHeightStyle;
	let $slotHeight;
	let $rotation;
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { border = false, clazz = '', collapsed = false, fading = true, i18n, icon, id, indented = true, inline = false, label, node, openOnlyOnIcon = false, style = "", tooltip } = $$props;
	id = id || getId();
	indented = getBooleanFrom(indented);
	border = getBooleanFrom(border);
	inline = getBooleanFrom(inline);
	collapsed = getBooleanFrom(collapsed);

	// intern variable if used without bind
	let _collapsed = collapsed;

	if (label) {
		label = i18nTranslate(RED, node, i18n, label);
	}

	// collapsible icon styling
	const rotation = tweened(_collapsed ? 0 : 90, { duration: 400, easing: cubicOut });

	component_subscribe($$self, rotation, value => $$invalidate(25, $rotation = value));
	let slotDiv;
	let maxSlotHeight = 0;
	const slotHeight = tweened(0, { duration: 400, easing: cubicOut });
	component_subscribe($$self, slotHeight, value => $$invalidate(24, $slotHeight = value));

	function handleResize(initial = false) {
		let computedSlotHeight = slotDiv.offsetHeight;

		if (_collapsed && maxSlotHeight !== computedSlotHeight) {
			// Prevent flickering when the content was changed after DOM created
			slotHeight.set(computedSlotHeight, { duration: 0 });
		}

		if (computedSlotHeight && computedSlotHeight !== 'auto') {
			$$invalidate(23, maxSlotHeight = computedSlotHeight);
		}

		if (initial) {
			// We do not want animation on first render
			slotHeight.set(_collapsed ? 0 : maxSlotHeight, { duration: 0 });
		} else {
			slotHeight.set(_collapsed ? 0 : maxSlotHeight);
		}
	}

	function openSlot(path) {
		// openOnlyOnIcon is a very special case for tree nodes where we only want to open it with the '>' icon
		// as the click event self is still needed for marking on select and e.g. pekfinger show description, we can't deactivate it completly.
		// this is bit dirty, but to change it on componentHeader will bloat the code for a perhabs single use case. Therefore this won't be shown in the Readme.
		if (openOnlyOnIcon && !path[0].classList.contains('fa-angle-right')) {
			return;
		}

		if (_collapsed) {
			rotation.set(90);
		} else {
			rotation.set(0);
		}

		$$invalidate(19, collapsed = !collapsed);
		$$invalidate(10, _collapsed = !_collapsed);
		handleResize();
	}

	onMount(() => {
		handleResize(true);
	});

	function componentheader_iconStyle_binding(value) {
		iconStyle = value;
		($$invalidate(14, iconStyle), $$invalidate(25, $rotation));
	}

	const click_handler_1 = event => openSlot(event.composedPath());

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			slotDiv = $$value;
			$$invalidate(11, slotDiv);
		});
	}

	function row_clazz_binding(value) {
		classes = value;
		(($$invalidate(13, classes), $$invalidate(20, clazz)), $$invalidate(10, _collapsed));
	}

	$$self.$$set = $$props => {
		if ('border' in $$props) $$invalidate(0, border = $$props.border);
		if ('clazz' in $$props) $$invalidate(20, clazz = $$props.clazz);
		if ('collapsed' in $$props) $$invalidate(19, collapsed = $$props.collapsed);
		if ('fading' in $$props) $$invalidate(5, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(21, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(6, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('indented' in $$props) $$invalidate(2, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(3, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('node' in $$props) $$invalidate(22, node = $$props.node);
		if ('openOnlyOnIcon' in $$props) $$invalidate(7, openOnlyOnIcon = $$props.openOnlyOnIcon);
		if ('style' in $$props) $$invalidate(8, style = $$props.style);
		if ('tooltip' in $$props) $$invalidate(9, tooltip = $$props.tooltip);
		if ('$$scope' in $$props) $$invalidate(34, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*$rotation*/ 33554432) {
			$$invalidate(14, iconStyle = 'transform:rotate(' + $rotation + 'deg);');
		}

		if ($$self.$$.dirty[0] & /*clazz, _collapsed*/ 1049600) {
			$$invalidate(13, classes = clazz + " sir-Collapsible" + (_collapsed ? "" : " open"));
		}

		if ($$self.$$.dirty[0] & /*_collapsed, $slotHeight, maxSlotHeight*/ 25166848) {
			$$invalidate(12, slotHeightStyle = 'height: ' + (!_collapsed && $slotHeight === maxSlotHeight
			? '100%;'
			: $slotHeight + 'px;'));
		}
	};

	return [
		border,
		id,
		indented,
		inline,
		label,
		fading,
		icon,
		openOnlyOnIcon,
		style,
		tooltip,
		_collapsed,
		slotDiv,
		slotHeightStyle,
		classes,
		iconStyle,
		rotation,
		slotHeight,
		openSlot,
		$$slots,
		collapsed,
		clazz,
		i18n,
		node,
		maxSlotHeight,
		$slotHeight,
		$rotation,
		slots,
		componentheader_iconStyle_binding,
		click_handler_1,
		mouseenter_handler,
		mouseleave_handler,
		click_handler,
		div0_binding,
		row_clazz_binding,
		$$scope
	];
}

class Collapsible extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$h,
			create_fragment$h,
			safe_not_equal,
			{
				border: 0,
				clazz: 20,
				collapsed: 19,
				fading: 5,
				i18n: 21,
				icon: 6,
				id: 1,
				indented: 2,
				inline: 3,
				label: 4,
				node: 22,
				openOnlyOnIcon: 7,
				style: 8,
				tooltip: 9
			},
			add_css$d,
			[-1, -1]
		);
	}
}

function flip(node, { from, to }, params = {}) {
    const style = getComputedStyle(node);
    const transform = style.transform === 'none' ? '' : style.transform;
    const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
    const dx = (from.left + from.width * ox / to.width) - (to.left + ox);
    const dy = (from.top + from.height * oy / to.height) - (to.top + oy);
    const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
    return {
        delay,
        duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
        easing,
        css: (t, u) => {
            const x = u * dx;
            const y = u * dy;
            const sx = t + u * from.width / to.width;
            const sy = t + u * from.height / to.height;
            return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
        }
    };
}

/* node_modules/svelte-integration-red/components/EditableList.svelte generated by Svelte v3.58.0 */

function add_css$c(target) {
	append_styles(target, "svelte-1jkq0hc", "li.svelte-1jkq0hc.svelte-1jkq0hc{display:inline-flex;width:100%;align-items:center}li.svelte-1jkq0hc .red-ui-editableList-item-content.svelte-1jkq0hc{width:100%;margin:0px 8px}li.svelte-1jkq0hc .red-ui-editableList-item-remove.svelte-1jkq0hc{position:initial;margin:0px 3px 0px 0px}li.svelte-1jkq0hc .red-ui-editableList-item-handle.svelte-1jkq0hc{position:initial;margin:0px 0px 0px 3px}.disabled.svelte-1jkq0hc.svelte-1jkq0hc{pointer-events:none}[id^='sir-EditableList-'].sir-Row.sir-EditableList{align-items:flex-start;flex-direction:column}.indented.svelte-1jkq0hc.svelte-1jkq0hc{padding-left:12px}[id^='sir-EditableList-'].sir-Row.sir-EditableList div:last-child{margin-bottom:0px}.sir-EditableList .red-ui-editableList-item-remove .sir-Row, .sir-EditableList .header .sir-Row{margin-bottom:0px}[id^='sir-EditableList-'].sir-Row.sir-EditableList .red-ui-editableList-container{min-height:100px;overflow-y:auto !important;overflow-x:hidden;padding-top:0px}[id^='sir-EditableList-'].sir-Row.sir-EditableList .red-ui-editableList{width:100%}[id^='sir-EditableList-'].sir-Row.sir-EditableList .red-ui-editableList-item-remove button{min-width:auto}.halfTransparent.svelte-1jkq0hc.svelte-1jkq0hc{opacity:.5}.dropzoneCurrent.svelte-1jkq0hc.svelte-1jkq0hc{border-top:2px solid #ccc;border-bottom:3px solid #ccc}.dropzoneUnder.svelte-1jkq0hc.svelte-1jkq0hc{border-top:3px solid #ccc}.dropzoneAbove.svelte-1jkq0hc.svelte-1jkq0hc{border-bottom:3px solid #ccc}.sir-EditableListHeader.editableListRemoveable .sir-Row{position:relative;width:calc(100% - 35px)}.sir-EditableListHeader.editableListSortable .sir-Row{position:relative;left:20px}");
}

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[57] = list[i];
	child_ctx[59] = i;
	return child_ctx;
}

const get_default_slot_changes = dirty => ({
	element: dirty[0] & /*elements*/ 2,
	index: dirty[0] & /*elements*/ 2
});

const get_default_slot_context = ctx => ({
	element: /*element*/ ctx[57],
	index: /*index*/ ctx[59]
});

const get_tableHeader_slot_changes = dirty => ({
	element: dirty[0] & /*elements*/ 2,
	index: dirty[0] & /*elements*/ 2
});

const get_tableHeader_slot_context = ctx => ({
	element: /*element*/ ctx[57],
	index: /*index*/ ctx[59]
});

const get_header_slot_changes$1 = dirty => ({
	element: dirty[0] & /*elements*/ 2,
	index: dirty[0] & /*elements*/ 2
});

const get_header_slot_context$1 = ctx => ({
	slot: "headerExtension",
	element: /*element*/ ctx[57],
	index: /*index*/ ctx[59]
});

// (143:2) {#if label || $$slots.header}
function create_if_block_4$3(ctx) {
	let componentheader;
	let current;

	componentheader = new ComponentHeader({
			props: {
				label: /*label*/ ctx[6],
				id: "sir-EditableList-" + /*id*/ ctx[3],
				labelFor: "sir-EditableList-" + /*id*/ ctx[3] + "-content",
				icon: /*icon*/ ctx[14],
				tooltip: /*tooltip*/ ctx[15],
				$$slots: {
					headerExtension: [create_headerExtension_slot$1]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(componentheader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(componentheader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const componentheader_changes = {};
			if (dirty[0] & /*label*/ 64) componentheader_changes.label = /*label*/ ctx[6];
			if (dirty[0] & /*id*/ 8) componentheader_changes.id = "sir-EditableList-" + /*id*/ ctx[3];
			if (dirty[0] & /*id*/ 8) componentheader_changes.labelFor = "sir-EditableList-" + /*id*/ ctx[3] + "-content";
			if (dirty[0] & /*icon*/ 16384) componentheader_changes.icon = /*icon*/ ctx[14];
			if (dirty[0] & /*tooltip*/ 32768) componentheader_changes.tooltip = /*tooltip*/ ctx[15];

			if (dirty[0] & /*elements*/ 2 | dirty[1] & /*$$scope*/ 8388608) {
				componentheader_changes.$$scope = { dirty, ctx };
			}

			componentheader.$set(componentheader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(componentheader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(componentheader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(componentheader, detaching);
		}
	};
}

// (145:6) 
function create_headerExtension_slot$1(ctx) {
	let current;
	const header_slot_template = /*#slots*/ ctx[34].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[54], get_header_slot_context$1);

	return {
		c() {
			if (header_slot) header_slot.c();
		},
		m(target, anchor) {
			if (header_slot) {
				header_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty[0] & /*elements*/ 2 | dirty[1] & /*$$scope*/ 8388608)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[54],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[54])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[54], dirty, get_header_slot_changes$1),
						get_header_slot_context$1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (158:6) {#if $$slots.tableHeader}
function create_if_block_3$3(ctx) {
	let div;
	let current;
	const tableHeader_slot_template = /*#slots*/ ctx[34].tableHeader;
	const tableHeader_slot = create_slot(tableHeader_slot_template, ctx, /*$$scope*/ ctx[54], get_tableHeader_slot_context);

	return {
		c() {
			div = element("div");
			if (tableHeader_slot) tableHeader_slot.c();
			attr(div, "class", "red-ui-editableList-header sir-EditableListHeader");
			toggle_class(div, "editableListRemoveable", /*removable*/ ctx[10]);
			toggle_class(div, "editableListSortable", /*sortable*/ ctx[11]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (tableHeader_slot) {
				tableHeader_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (tableHeader_slot) {
				if (tableHeader_slot.p && (!current || dirty[0] & /*elements*/ 2 | dirty[1] & /*$$scope*/ 8388608)) {
					update_slot_base(
						tableHeader_slot,
						tableHeader_slot_template,
						ctx,
						/*$$scope*/ ctx[54],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[54])
						: get_slot_changes(tableHeader_slot_template, /*$$scope*/ ctx[54], dirty, get_tableHeader_slot_changes),
						get_tableHeader_slot_context
					);
				}
			}

			if (!current || dirty[0] & /*removable*/ 1024) {
				toggle_class(div, "editableListRemoveable", /*removable*/ ctx[10]);
			}

			if (!current || dirty[0] & /*sortable*/ 2048) {
				toggle_class(div, "editableListSortable", /*sortable*/ ctx[11]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(tableHeader_slot, local);
			current = true;
		},
		o(local) {
			transition_out(tableHeader_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (tableHeader_slot) tableHeader_slot.d(detaching);
		}
	};
}

// (180:12) {#if sortable}
function create_if_block_2$5(ctx) {
	let i;
	let mounted;
	let dispose;

	return {
		c() {
			i = element("i");
			attr(i, "class", "red-ui-editableList-item-handle fa fa-bars svelte-1jkq0hc");
			toggle_class(i, "disabled", /*disabled*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, i, anchor);

			if (!mounted) {
				dispose = [
					listen(i, "mouseover", /*mouseover_handler*/ ctx[46]),
					listen(i, "focus", /*focus_handler*/ ctx[47]),
					listen(i, "mouseout", /*mouseout_handler*/ ctx[48]),
					listen(i, "blur", /*blur_handler*/ ctx[49])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 1) {
				toggle_class(i, "disabled", /*disabled*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (189:12) {#if removable}
function create_if_block_1$7(ctx) {
	let div;
	let button;
	let current;

	function click_handler() {
		return /*click_handler*/ ctx[50](/*index*/ ctx[59]);
	}

	button = new Button({
			props: {
				small: true,
				icon: "remove",
				disabled: /*disabled*/ ctx[0]
			}
		});

	button.$on("click", click_handler);

	return {
		c() {
			div = element("div");
			create_component(button.$$.fragment);
			attr(div, "class", "red-ui-editableList-item-remove svelte-1jkq0hc");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty[0] & /*disabled*/ 1) button_changes.disabled = /*disabled*/ ctx[0];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(button);
		}
	};
}

// (164:8) {#each elements as element, index (typeof element === 'object' ? element.id || element : index)}
function create_each_block$6(key_1, ctx) {
	let li;
	let t0;
	let div;
	let t1;
	let t2;
	let li_id_value;
	let rect;
	let stop_animation = noop;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*sortable*/ ctx[11] && create_if_block_2$5(ctx);
	const default_slot_template = /*#slots*/ ctx[34].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[54], get_default_slot_context);
	let if_block1 = /*removable*/ ctx[10] && create_if_block_1$7(ctx);

	function dragstart_handler(...args) {
		return /*dragstart_handler*/ ctx[51](/*index*/ ctx[59], ...args);
	}

	function drop_handler_2(...args) {
		return /*drop_handler_2*/ ctx[52](/*index*/ ctx[59], ...args);
	}

	function dragenter_handler_2(...args) {
		return /*dragenter_handler_2*/ ctx[53](/*index*/ ctx[59], ...args);
	}

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			attr(div, "class", "red-ui-editableList-item-content svelte-1jkq0hc");
			attr(li, "id", li_id_value = /*index*/ ctx[59]);
			attr(li, "draggable", /*isDraggable*/ ctx[18]);
			attr(li, "class", "svelte-1jkq0hc");
			toggle_class(li, "red-ui-editableList-item-sortable", /*sortable*/ ctx[11]);
			toggle_class(li, "red-ui-editableList-item-removable", /*removable*/ ctx[10]);
			toggle_class(li, "dropzoneUnder", /*hovering*/ ctx[16] === /*index*/ ctx[59] && /*hovering*/ ctx[16] < /*draggingIndex*/ ctx[17]);
			toggle_class(li, "dropzoneAbove", /*hovering*/ ctx[16] === /*index*/ ctx[59] && /*hovering*/ ctx[16] > /*draggingIndex*/ ctx[17]);
			toggle_class(li, "dropzoneCurrent", /*hovering*/ ctx[16] === /*index*/ ctx[59] && /*index*/ ctx[59] === /*draggingIndex*/ ctx[17]);
			toggle_class(li, "halfTransparent", /*hovering*/ ctx[16] !== /*index*/ ctx[59] && /*index*/ ctx[59] === /*draggingIndex*/ ctx[17]);
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			if (if_block0) if_block0.m(li, null);
			append(li, t0);
			append(li, div);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append(li, t1);
			if (if_block1) if_block1.m(li, null);
			append(li, t2);
			current = true;

			if (!mounted) {
				dispose = [
					listen(li, "dragstart", stop_propagation(dragstart_handler)),
					listen(li, "drag", stop_propagation(/*drag_handler_1*/ ctx[41])),
					listen(li, "drop", stop_propagation(prevent_default(drop_handler_2))),
					listen(li, "drop", /*drop_handler_1*/ ctx[42]),
					listen(li, "dragover", stop_propagation(prevent_default(/*dragover_handler_1*/ ctx[43]))),
					listen(li, "dragenter", stop_propagation(prevent_default(dragenter_handler_2))),
					listen(li, "dragenter", stop_propagation(prevent_default(/*dragenter_handler_1*/ ctx[44]))),
					listen(li, "dragleave", stop_propagation(/*dragleave_handler_1*/ ctx[45])),
					listen(li, "dragend", stop_propagation(/*dragend*/ ctx[26]))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*sortable*/ ctx[11]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$5(ctx);
					if_block0.c();
					if_block0.m(li, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*elements*/ 2 | dirty[1] & /*$$scope*/ 8388608)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[54],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[54])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[54], dirty, get_default_slot_changes),
						get_default_slot_context
					);
				}
			}

			if (/*removable*/ ctx[10]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*removable*/ 1024) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$7(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(li, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*elements*/ 2 && li_id_value !== (li_id_value = /*index*/ ctx[59])) {
				attr(li, "id", li_id_value);
			}

			if (!current || dirty[0] & /*isDraggable*/ 262144) {
				attr(li, "draggable", /*isDraggable*/ ctx[18]);
			}

			if (!current || dirty[0] & /*sortable*/ 2048) {
				toggle_class(li, "red-ui-editableList-item-sortable", /*sortable*/ ctx[11]);
			}

			if (!current || dirty[0] & /*removable*/ 1024) {
				toggle_class(li, "red-ui-editableList-item-removable", /*removable*/ ctx[10]);
			}

			if (!current || dirty[0] & /*hovering, elements, draggingIndex*/ 196610) {
				toggle_class(li, "dropzoneUnder", /*hovering*/ ctx[16] === /*index*/ ctx[59] && /*hovering*/ ctx[16] < /*draggingIndex*/ ctx[17]);
			}

			if (!current || dirty[0] & /*hovering, elements, draggingIndex*/ 196610) {
				toggle_class(li, "dropzoneAbove", /*hovering*/ ctx[16] === /*index*/ ctx[59] && /*hovering*/ ctx[16] > /*draggingIndex*/ ctx[17]);
			}

			if (!current || dirty[0] & /*hovering, elements, draggingIndex*/ 196610) {
				toggle_class(li, "dropzoneCurrent", /*hovering*/ ctx[16] === /*index*/ ctx[59] && /*index*/ ctx[59] === /*draggingIndex*/ ctx[17]);
			}

			if (!current || dirty[0] & /*hovering, elements, draggingIndex*/ 196610) {
				toggle_class(li, "halfTransparent", /*hovering*/ ctx[16] !== /*index*/ ctx[59] && /*index*/ ctx[59] === /*draggingIndex*/ ctx[17]);
			}
		},
		r() {
			rect = li.getBoundingClientRect();
		},
		f() {
			fix_position(li);
			stop_animation();
		},
		a() {
			stop_animation();
			stop_animation = create_animation(li, rect, flip, { duration: 200 });
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (198:4) {#if _addButton}
function create_if_block$c(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				style: "margin-top: 6px;",
				icon: "plus",
				disabled: /*disabled*/ ctx[0],
				label: /*addButtonLabel*/ ctx[20],
				small: true
			}
		});

	button.$on("click", /*addHandler*/ ctx[27]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty[0] & /*disabled*/ 1) button_changes.disabled = /*disabled*/ ctx[0];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (142:0) <Row id="sir-EditableList-{id}" clazz="{clazz} sir-EditableList" {inline} {maximize} fading={fadeDuration} {style}>
function create_default_slot$a(ctx) {
	let t0;
	let div1;
	let div0;
	let t1;
	let ol;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let div0_id_value;
	let div0_style_value;
	let t2;
	let current;
	let mounted;
	let dispose;
	let if_block0 = (/*label*/ ctx[6] || /*$$slots*/ ctx[29].header) && create_if_block_4$3(ctx);
	let if_block1 = /*$$slots*/ ctx[29].tableHeader && create_if_block_3$3(ctx);
	let each_value = /*elements*/ ctx[1];

	const get_key = ctx => typeof /*element*/ ctx[57] === 'object'
	? /*element*/ ctx[57].id || /*element*/ ctx[57]
	: /*index*/ ctx[59];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$6(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$6(key, child_ctx));
	}

	let if_block2 = /*_addButton*/ ctx[19] && create_if_block$c(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			ol = element("ol");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (if_block2) if_block2.c();
			attr(ol, "id", /*nodeInputId*/ ctx[21]);
			attr(ol, "class", "red-ui-editableList-list sir-EditableList-list");
			attr(ol, "style", /*style*/ ctx[12]);
			toggle_class(ol, "ui-sortable", /*sortable*/ ctx[11]);
			attr(div0, "id", div0_id_value = "sir-EditableList-" + /*id*/ ctx[3] + "-content");
			attr(div0, "class", "red-ui-editableList-border red-ui-editableList-container svelte-1jkq0hc");
			attr(div0, "style", div0_style_value = `${/*style*/ ctx[12]} min-height: ${/*minHeight*/ ctx[9]}; height: ${/*height*/ ctx[2]}; max-height: ${/*maxHeight*/ ctx[7]}`);
			toggle_class(div0, "indented", /*indented*/ ctx[4]);
			attr(div1, "class", "red-ui-editableList");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, div1, anchor);
			append(div1, div0);
			if (if_block1) if_block1.m(div0, null);
			append(div0, t1);
			append(div0, ol);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ol, null);
				}
			}

			append(div1, t2);
			if (if_block2) if_block2.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "drag", stop_propagation(/*drag_handler*/ ctx[35])),
					listen(div0, "drop", stop_propagation(prevent_default(/*drop_handler*/ ctx[36]))),
					listen(div0, "dragover", stop_propagation(prevent_default(/*dragover_handler*/ ctx[37]))),
					listen(div0, "dragenter", stop_propagation(prevent_default(/*dragenter_handler*/ ctx[38]))),
					listen(div0, "dragleave", stop_propagation(/*dragleave_handler*/ ctx[39])),
					listen(div0, "dragend", stop_propagation(/*dragend_handler*/ ctx[40]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[6] || /*$$slots*/ ctx[29].header) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*label, $$slots*/ 536870976) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4$3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*$$slots*/ ctx[29].tableHeader) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*$$slots*/ 536870912) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div0, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*elements, isDraggable, sortable, removable, hovering, draggingIndex, dragstart, drop, dragenter, dragend, disabled, removeHandler*/ 394726403 | dirty[1] & /*$$scope*/ 8388608) {
				each_value = /*elements*/ ctx[1];
				group_outros();
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ol, fix_and_outro_and_destroy_block, create_each_block$6, null, get_each_context$6);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
				check_outros();
			}

			if (!current || dirty[0] & /*style*/ 4096) {
				attr(ol, "style", /*style*/ ctx[12]);
			}

			if (!current || dirty[0] & /*sortable*/ 2048) {
				toggle_class(ol, "ui-sortable", /*sortable*/ ctx[11]);
			}

			if (!current || dirty[0] & /*id*/ 8 && div0_id_value !== (div0_id_value = "sir-EditableList-" + /*id*/ ctx[3] + "-content")) {
				attr(div0, "id", div0_id_value);
			}

			if (!current || dirty[0] & /*style, minHeight, height, maxHeight*/ 4740 && div0_style_value !== (div0_style_value = `${/*style*/ ctx[12]} min-height: ${/*minHeight*/ ctx[9]}; height: ${/*height*/ ctx[2]}; max-height: ${/*maxHeight*/ ctx[7]}`)) {
				attr(div0, "style", div0_style_value);
			}

			if (!current || dirty[0] & /*indented*/ 16) {
				toggle_class(div0, "indented", /*indented*/ ctx[4]);
			}

			if (/*_addButton*/ ctx[19]) if_block2.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div1);
			if (if_block1) if_block1.d();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$g(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-EditableList-" + /*id*/ ctx[3],
				clazz: "" + (/*clazz*/ ctx[13] + " sir-EditableList"),
				inline: /*inline*/ ctx[5],
				maximize: /*maximize*/ ctx[8],
				fading: /*fadeDuration*/ ctx[22],
				style: /*style*/ ctx[12],
				$$slots: { default: [create_default_slot$a] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty[0] & /*id*/ 8) row_changes.id = "sir-EditableList-" + /*id*/ ctx[3];
			if (dirty[0] & /*clazz*/ 8192) row_changes.clazz = "" + (/*clazz*/ ctx[13] + " sir-EditableList");
			if (dirty[0] & /*inline*/ 32) row_changes.inline = /*inline*/ ctx[5];
			if (dirty[0] & /*maximize*/ 256) row_changes.maximize = /*maximize*/ ctx[8];
			if (dirty[0] & /*style*/ 4096) row_changes.style = /*style*/ ctx[12];

			if (dirty[0] & /*disabled, id, style, minHeight, height, maxHeight, indented, sortable, elements, isDraggable, removable, hovering, draggingIndex, $$slots, label, icon, tooltip*/ 537386719 | dirty[1] & /*$$scope*/ 8388608) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$g($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { addButton = false, clazz = "", disabled = false, elements, fading = true, height = 'auto', i18n, icon, id, indented = false, inline = false, label = '', maxHeight = 300, maximize = false, minHeight = 100, node, removable = false, sortable = false, style = '', tooltip } = $$props;
	id = id || getId();
	const _addButton = getBooleanFrom(!!addButton);
	sortable = getBooleanFrom(sortable);
	removable = getBooleanFrom(removable);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	inline = getBooleanFrom(inline);
	indented = getBooleanFrom(indented);

	const addButtonLabel = typeof addButton === 'string'
	? addButton
	: RED._("editableList.add");

	if (style && !style.endsWith(";")) {
		style = style + ";";
	}

	if (label) {
		label = i18nTranslate(RED, node, i18n, label);
	}

	const nodeInputId = "node-input-" + id + "-container";
	const fadeDuration = getFadeDuration(fading);

	// note: if height is set, min and max height have no effect
	if (!isNaN(height)) height += "px";

	if (!isNaN(minHeight)) minHeight += "px";
	if (!isNaN(maxHeight)) maxHeight += "px";
	const dispatch = createEventDispatcher();

	// sorting mechanism
	let hovering = false;

	let draggingIndex = null;
	let isDraggable = false;
	let dropzone;

	const drop = (e, target) => {
		if (dropzone) {
			e.dataTransfer.dropEffect = 'move';
			const start = parseInt(e.dataTransfer.getData("text/plain"));
			const newTracklist = [...elements];

			if (start < target) {
				newTracklist.splice(target + 1, 0, newTracklist[start]);
				newTracklist.splice(start, 1);
			} else {
				newTracklist.splice(target, 0, newTracklist[start]);
				newTracklist.splice(start + 1, 1);
			}

			$$invalidate(1, elements = newTracklist);
			$$invalidate(16, hovering = null);
			$$invalidate(17, draggingIndex = null);
			dispatch('sort', { value: elements }, { cancelable: false });
		}
	};

	const dragstart = (e, i) => {
		dropzone = e.target.closest('ol').id;
		$$invalidate(17, draggingIndex = i);
		e.dataTransfer.effectAllowed = 'move';
		e.dataTransfer.dropEffect = 'move';
		const start = i;
		e.dataTransfer.setData('text/plain', start);
	};

	const dragenter = (e, i) => {
		if (dropzone) {
			$$invalidate(16, hovering = i);
		}
	};

	const dragend = () => {
		dropzone = false;
		$$invalidate(16, hovering = null);
		$$invalidate(17, draggingIndex = null);
	};

	// add / remove content
	const addHandler = () => dispatch('add', { index: elements.length });

	const removeHandler = index => {
		const removed = elements[index];
		$$invalidate(1, elements = [...elements.slice(0, index), ...elements.slice(index + 1)]);
		dispatch('remove', { value: removed, index }, { cancelable: false });
	};

	function drag_handler(event) {
		bubble.call(this, $$self, event);
	}

	function drop_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragover_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragend_handler(event) {
		bubble.call(this, $$self, event);
	}

	function drag_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function drop_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function dragover_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function dragenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function dragleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	const mouseover_handler = () => $$invalidate(18, isDraggable = true);
	const focus_handler = () => $$invalidate(18, isDraggable = true);
	const mouseout_handler = () => $$invalidate(18, isDraggable = false);
	const blur_handler = () => $$invalidate(18, isDraggable = false);
	const click_handler = index => removeHandler(index);
	const dragstart_handler = (index, e) => dragstart(e, index);
	const drop_handler_2 = (index, e) => drop(e, index);

	const dragenter_handler_2 = (index, e) => {
		dragenter(e, index);
	};

	$$self.$$set = $$props => {
		if ('addButton' in $$props) $$invalidate(30, addButton = $$props.addButton);
		if ('clazz' in $$props) $$invalidate(13, clazz = $$props.clazz);
		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
		if ('elements' in $$props) $$invalidate(1, elements = $$props.elements);
		if ('fading' in $$props) $$invalidate(31, fading = $$props.fading);
		if ('height' in $$props) $$invalidate(2, height = $$props.height);
		if ('i18n' in $$props) $$invalidate(32, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(14, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('indented' in $$props) $$invalidate(4, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(5, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(6, label = $$props.label);
		if ('maxHeight' in $$props) $$invalidate(7, maxHeight = $$props.maxHeight);
		if ('maximize' in $$props) $$invalidate(8, maximize = $$props.maximize);
		if ('minHeight' in $$props) $$invalidate(9, minHeight = $$props.minHeight);
		if ('node' in $$props) $$invalidate(33, node = $$props.node);
		if ('removable' in $$props) $$invalidate(10, removable = $$props.removable);
		if ('sortable' in $$props) $$invalidate(11, sortable = $$props.sortable);
		if ('style' in $$props) $$invalidate(12, style = $$props.style);
		if ('tooltip' in $$props) $$invalidate(15, tooltip = $$props.tooltip);
		if ('$$scope' in $$props) $$invalidate(54, $$scope = $$props.$$scope);
	};

	return [
		disabled,
		elements,
		height,
		id,
		indented,
		inline,
		label,
		maxHeight,
		maximize,
		minHeight,
		removable,
		sortable,
		style,
		clazz,
		icon,
		tooltip,
		hovering,
		draggingIndex,
		isDraggable,
		_addButton,
		addButtonLabel,
		nodeInputId,
		fadeDuration,
		drop,
		dragstart,
		dragenter,
		dragend,
		addHandler,
		removeHandler,
		$$slots,
		addButton,
		fading,
		i18n,
		node,
		slots,
		drag_handler,
		drop_handler,
		dragover_handler,
		dragenter_handler,
		dragleave_handler,
		dragend_handler,
		drag_handler_1,
		drop_handler_1,
		dragover_handler_1,
		dragenter_handler_1,
		dragleave_handler_1,
		mouseover_handler,
		focus_handler,
		mouseout_handler,
		blur_handler,
		click_handler,
		dragstart_handler,
		drop_handler_2,
		dragenter_handler_2,
		$$scope
	];
}

class EditableList extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$g,
			create_fragment$g,
			safe_not_equal,
			{
				addButton: 30,
				clazz: 13,
				disabled: 0,
				elements: 1,
				fading: 31,
				height: 2,
				i18n: 32,
				icon: 14,
				id: 3,
				indented: 4,
				inline: 5,
				label: 6,
				maxHeight: 7,
				maximize: 8,
				minHeight: 9,
				node: 33,
				removable: 10,
				sortable: 11,
				style: 12,
				tooltip: 15
			},
			add_css$c,
			[-1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/Group.svelte generated by Svelte v3.58.0 */

function add_css$b(target) {
	append_styles(target, "svelte-6f435u", ".sir-Group-container.svelte-6f435u{padding:12px 12px 0px 12px}[id^='sir-Group-'].sir-Row.sir-Group, [id^='sir-Group-'].sir-Group{flex-direction:column;align-items:stretch}.maximize.svelte-6f435u{width:100%}");
}

const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({ slot: "headerExtension" });

// (29:2) {#if label || $$slots.header}
function create_if_block$b(ctx) {
	let componentheader;
	let current;

	componentheader = new ComponentHeader({
			props: {
				id: "sir-Group-" + /*id*/ ctx[8],
				label: /*label*/ ctx[1],
				labelFor: "sir-EditableList-" + /*id*/ ctx[8] + "-content",
				icon: /*icon*/ ctx[5],
				tooltip: /*tooltip*/ ctx[7],
				$$slots: {
					headerExtension: [create_headerExtension_slot]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(componentheader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(componentheader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const componentheader_changes = {};
			if (dirty & /*id*/ 256) componentheader_changes.id = "sir-Group-" + /*id*/ ctx[8];
			if (dirty & /*label*/ 2) componentheader_changes.label = /*label*/ ctx[1];
			if (dirty & /*id*/ 256) componentheader_changes.labelFor = "sir-EditableList-" + /*id*/ ctx[8] + "-content";
			if (dirty & /*icon*/ 32) componentheader_changes.icon = /*icon*/ ctx[5];
			if (dirty & /*tooltip*/ 128) componentheader_changes.tooltip = /*tooltip*/ ctx[7];

			if (dirty & /*$$scope*/ 8192) {
				componentheader_changes.$$scope = { dirty, ctx };
			}

			componentheader.$set(componentheader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(componentheader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(componentheader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(componentheader, detaching);
		}
	};
}

// (31:6) 
function create_headerExtension_slot(ctx) {
	let current;
	const header_slot_template = /*#slots*/ ctx[12].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[13], get_header_slot_context);

	return {
		c() {
			if (header_slot) header_slot.c();
		},
		m(target, anchor) {
			if (header_slot) {
				header_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[13], dirty, get_header_slot_changes),
						get_header_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (28:0) <Row id="sir-Group-{id}" clazz="{clazz} sir-Group" {inline} {fading}>
function create_default_slot$9(ctx) {
	let t;
	let div;
	let div_id_value;
	let current;
	let if_block = (/*label*/ ctx[1] || /*$$slots*/ ctx[9].header) && create_if_block$b(ctx);
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "id", div_id_value = "sir-Group-" + /*id*/ ctx[8] + "-container");
			attr(div, "class", "red-ui-editableList-border sir-Group-container svelte-6f435u");
			attr(div, "style", /*style*/ ctx[6]);
			toggle_class(div, "maximize", /*maximize*/ ctx[2]);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[1] || /*$$slots*/ ctx[9].header) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label, $$slots*/ 514) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$b(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 256 && div_id_value !== (div_id_value = "sir-Group-" + /*id*/ ctx[8] + "-container")) {
				attr(div, "id", div_id_value);
			}

			if (!current || dirty & /*style*/ 64) {
				attr(div, "style", /*style*/ ctx[6]);
			}

			if (!current || dirty & /*maximize*/ 4) {
				toggle_class(div, "maximize", /*maximize*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$f(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Group-" + /*id*/ ctx[8],
				clazz: "" + (/*clazz*/ ctx[3] + " sir-Group"),
				inline: /*inline*/ ctx[0],
				fading: /*fading*/ ctx[4],
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*id*/ 256) row_changes.id = "sir-Group-" + /*id*/ ctx[8];
			if (dirty & /*clazz*/ 8) row_changes.clazz = "" + (/*clazz*/ ctx[3] + " sir-Group");
			if (dirty & /*inline*/ 1) row_changes.inline = /*inline*/ ctx[0];
			if (dirty & /*fading*/ 16) row_changes.fading = /*fading*/ ctx[4];

			if (dirty & /*$$scope, id, style, maximize, label, icon, tooltip, $$slots*/ 9190) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { clazz = '', fading = true, i18n, icon, inline = false, label, maximize = false, node, style = '', tooltip } = $$props;
	let { id = getId() } = $$props;
	maximize = getBooleanFrom(maximize);
	inline = getBooleanFrom(inline);

	if (label) {
		label = i18nTranslate(RED, node, i18n, label);
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(3, clazz = $$props.clazz);
		if ('fading' in $$props) $$invalidate(4, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(10, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(5, icon = $$props.icon);
		if ('inline' in $$props) $$invalidate(0, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(2, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(11, node = $$props.node);
		if ('style' in $$props) $$invalidate(6, style = $$props.style);
		if ('tooltip' in $$props) $$invalidate(7, tooltip = $$props.tooltip);
		if ('id' in $$props) $$invalidate(8, id = $$props.id);
		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	return [
		inline,
		label,
		maximize,
		clazz,
		fading,
		icon,
		style,
		tooltip,
		id,
		$$slots,
		i18n,
		node,
		slots,
		$$scope
	];
}

class Group extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$f,
			create_fragment$f,
			safe_not_equal,
			{
				clazz: 3,
				fading: 4,
				i18n: 10,
				icon: 5,
				inline: 0,
				label: 1,
				maximize: 2,
				node: 11,
				style: 6,
				tooltip: 7,
				id: 8
			},
			add_css$b
		);
	}
}

/* node_modules/svelte-integration-red/components/PlainInput.svelte generated by Svelte v3.58.0 */

function add_css$a(target) {
	append_styles(target, "svelte-18o1pln", ".maximize.svelte-18o1pln{width:100% !important}.clickable.svelte-18o1pln{cursor:pointer}");
}

// (128:0) {:else}
function create_else_block_1$1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: No property name given.";
			attr(span, "class", "maximize svelte-18o1pln");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (86:0) {#if !internal.updateNode || prop}
function create_if_block$a(ctx) {
	let t;
	let if_block1_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[7] !== 'checkbox' && /*label*/ ctx[1] || /*type*/ ctx[7] === 'checkbox' && /*label*/ ctx[1] && /*labelBeforeCheckbox*/ ctx[6]) return create_if_block_12;
		if (/*indented*/ ctx[5]) return create_if_block_14;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block0 = current_block_type && current_block_type(ctx);

	function select_block_type_2(ctx, dirty) {
		if (/*type*/ ctx[7] === 'text') return create_if_block_1$6;
		if (/*type*/ ctx[7] === 'number') return create_if_block_2$4;
		if (/*type*/ ctx[7] === 'password') return create_if_block_3$2;
		if (/*type*/ ctx[7] === 'email') return create_if_block_4$2;
		if (/*type*/ ctx[7] === 'url') return create_if_block_5$2;
		if (/*type*/ ctx[7] === 'color') return create_if_block_6$1;
		if (/*type*/ ctx[7] === 'checkbox') return create_if_block_7$1;
		if (/*type*/ ctx[7] === 'search') return create_if_block_10;
		return create_else_block$3;
	}

	let current_block_type_1 = select_block_type_2(ctx);
	let if_block1 = current_block_type_1(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			}
		},
		d(detaching) {
			if (if_block0) {
				if_block0.d(detaching);
			}

			if (detaching) detach(t);
			if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (91:21) 
function create_if_block_14(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (87:2) {#if (type !== 'checkbox' && label) || (type === 'checkbox' && label && labelBeforeCheckbox)}
function create_if_block_12(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_id_value;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[4] && create_if_block_13(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[1]);
			attr(label_1, "id", label_1_id_value = "sir-Input-Label-" + /*id*/ ctx[0]);
			attr(label_1, "for", /*inputFieldId*/ ctx[11]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler*/ ctx[88]),
					listen(label_1, "mouseleave", /*mouseleave_handler*/ ctx[89])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_13(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*label*/ 2) set_data(t1, /*label*/ ctx[1]);

			if (dirty[0] & /*id*/ 1 && label_1_id_value !== (label_1_id_value = "sir-Input-Label-" + /*id*/ ctx[0])) {
				attr(label_1, "id", label_1_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (89:6) {#if icon}
function create_if_block_13(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-18o1pln");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 16 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-18o1pln")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (125:2) {:else}
function create_else_block$3(ctx) {
	let span;
	let t0;
	let t1;
	let t2;

	return {
		c() {
			span = element("span");
			t0 = text("Error: Unsupported property type '");
			t1 = text(/*type*/ ctx[7]);
			t2 = text("'.");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			append(span, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*type*/ 128) set_data(t1, /*type*/ ctx[7]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (117:30) 
function create_if_block_10(ctx) {
	let div;
	let i;
	let t0;
	let input;
	let input_placeholder_value;
	let t1;
	let mounted;
	let dispose;
	let if_block = /*internal*/ ctx[10].value && create_if_block_11(ctx);

	return {
		c() {
			div = element("div");
			i = element("i");
			t0 = space();
			input = element("input");
			t1 = space();
			if (if_block) if_block.c();
			attr(i, "class", "fa fa-search");
			attr(input, "id", /*inputFieldId*/ ctx[11]);
			attr(input, "placeholder", input_placeholder_value = /*placeholder*/ ctx[2] || 'search');
			input.disabled = /*disabled*/ ctx[3];
			attr(input, "class", "red-ui-searchBox-input svelte-18o1pln");
			attr(input, "type", "text");
			toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			attr(div, "class", "red-ui-searchBox-container red-ui-searchBox-compact svelte-18o1pln");
			toggle_class(div, "maximize", /*maximize*/ ctx[8]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, i);
			append(div, t0);
			append(div, input);
			set_input_value(input, /*internal*/ ctx[10].value);
			append(div, t1);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler_5*/ ctx[98]),
					listen(input, "mouseenter", /*mouseenter_handler_9*/ ctx[80]),
					listen(input, "mouseleave", /*mouseleave_handler_9*/ ctx[81]),
					listen(input, "keypress", /*keypress_handler_7*/ ctx[82]),
					listen(input, "keydown", /*keydown_handler_7*/ ctx[83]),
					listen(input, "click", stop_propagation(prevent_default(/*click_handler_7*/ ctx[84]))),
					listen(input, "input", /*input_handler_8*/ ctx[85]),
					listen(input, "focus", /*focus_handler_7*/ ctx[86]),
					listen(input, "blur", /*blur_handler_7*/ ctx[87])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4 && input_placeholder_value !== (input_placeholder_value = /*placeholder*/ ctx[2] || 'search')) {
				attr(input, "placeholder", input_placeholder_value);
			}

			if (dirty[0] & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*internal*/ 1024 && input.value !== /*internal*/ ctx[10].value) {
				set_input_value(input, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			}

			if (/*internal*/ ctx[10].value) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_11(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(div, "maximize", /*maximize*/ ctx[8]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (108:32) 
function create_if_block_7$1(ctx) {
	let div;
	let input;
	let t;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[1] && !/*labelBeforeCheckbox*/ ctx[6] && create_if_block_8$1(ctx);

	return {
		c() {
			div = element("div");
			input = element("input");
			t = space();
			if (if_block) if_block.c();
			attr(input, "id", /*inputFieldId*/ ctx[11]);
			input.disabled = /*disabled*/ ctx[3];
			attr(input, "type", "checkbox");
			toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			attr(div, "class", "checkbox");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			input.checked = /*internal*/ ctx[10].value;
			append(div, t);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = [
					listen(input, "change", /*input_change_handler*/ ctx[97]),
					listen(input, "mouseenter", /*mouseenter_handler_7*/ ctx[72]),
					listen(input, "mouseleave", /*mouseleave_handler_7*/ ctx[73]),
					listen(input, "keypress", /*keypress_handler_6*/ ctx[74]),
					listen(input, "keydown", /*keydown_handler_6*/ ctx[75]),
					listen(input, "click", /*click_handler_6*/ ctx[76]),
					listen(input, "input", /*input_handler_7*/ ctx[77]),
					listen(input, "focus", /*focus_handler_6*/ ctx[78]),
					listen(input, "blur", /*blur_handler_6*/ ctx[79])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*internal*/ 1024) {
				input.checked = /*internal*/ ctx[10].value;
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			}

			if (/*label*/ ctx[1] && !/*labelBeforeCheckbox*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_8$1(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (105:29) 
function create_if_block_6$1(ctx) {
	let input0;
	let t;
	let input1;
	let mounted;
	let dispose;

	return {
		c() {
			input0 = element("input");
			t = space();
			input1 = element("input");
			input0.disabled = /*disabled*/ ctx[3];
			set_style(input0, "max-width", "30px");
			set_style(input0, "cursor", "pointer");
			attr(input0, "type", "color");
			toggle_class(input0, "input-error", /*internal*/ ctx[10].isError);
			attr(input1, "id", /*inputFieldId*/ ctx[11]);
			attr(input1, "placeholder", /*placeholder*/ ctx[2]);
			input1.disabled = /*disabled*/ ctx[3];
			attr(input1, "type", "text");
			attr(input1, "class", "svelte-18o1pln");
			toggle_class(input1, "maximize", /*maximize*/ ctx[8]);
			toggle_class(input1, "input-error", /*internal*/ ctx[10].isError);
		},
		m(target, anchor) {
			insert(target, input0, anchor);
			set_input_value(input0, /*internal*/ ctx[10].value);
			insert(target, t, anchor);
			insert(target, input1, anchor);
			set_input_value(input1, /*internal*/ ctx[10].value);

			if (!mounted) {
				dispose = [
					listen(input0, "input", /*input0_input_handler*/ ctx[95]),
					listen(input0, "input", /*input_handler_5*/ ctx[68]),
					listen(input0, "click", /*click_handler_5*/ ctx[69]),
					listen(input1, "input", /*input1_input_handler*/ ctx[96]),
					listen(input1, "mouseenter", /*mouseenter_handler_6*/ ctx[61]),
					listen(input1, "mouseleave", /*mouseleave_handler_6*/ ctx[62]),
					listen(input1, "keypress", /*keypress_handler_5*/ ctx[63]),
					listen(input1, "keydown", /*keydown_handler_5*/ ctx[64]),
					listen(input1, "input", /*input_handler_6*/ ctx[65]),
					listen(input1, "focus", /*focus_handler_5*/ ctx[66]),
					listen(input1, "blur", /*blur_handler_5*/ ctx[67])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 8) {
				input0.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*internal*/ 1024) {
				set_input_value(input0, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input0, "input-error", /*internal*/ ctx[10].isError);
			}

			if (dirty[0] & /*placeholder*/ 4) {
				attr(input1, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 8) {
				input1.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*internal*/ 1024 && input1.value !== /*internal*/ ctx[10].value) {
				set_input_value(input1, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(input1, "maximize", /*maximize*/ ctx[8]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input1, "input-error", /*internal*/ ctx[10].isError);
			}
		},
		d(detaching) {
			if (detaching) detach(input0);
			if (detaching) detach(t);
			if (detaching) detach(input1);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (103:27) 
function create_if_block_5$2(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputFieldId*/ ctx[11]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[3];
			attr(input, "type", "url");
			attr(input, "class", "svelte-18o1pln");
			toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*internal*/ ctx[10].value);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler_4*/ ctx[94]),
					listen(input, "mouseenter", /*mouseenter_handler_5*/ ctx[53]),
					listen(input, "mouseleave", /*mouseleave_handler_5*/ ctx[54]),
					listen(input, "keypress", /*keypress_handler_4*/ ctx[55]),
					listen(input, "keydown", /*keydown_handler_4*/ ctx[56]),
					listen(input, "click", stop_propagation(prevent_default(/*click_handler_4*/ ctx[57]))),
					listen(input, "input", /*input_handler_4*/ ctx[58]),
					listen(input, "focus", /*focus_handler_4*/ ctx[59]),
					listen(input, "blur", /*blur_handler_4*/ ctx[60])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*internal*/ 1024 && input.value !== /*internal*/ ctx[10].value) {
				set_input_value(input, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (101:29) 
function create_if_block_4$2(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputFieldId*/ ctx[11]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[3];
			attr(input, "type", "email");
			attr(input, "class", "svelte-18o1pln");
			toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*internal*/ ctx[10].value);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler_3*/ ctx[93]),
					listen(input, "mouseenter", /*mouseenter_handler_4*/ ctx[45]),
					listen(input, "mouseleave", /*mouseleave_handler_4*/ ctx[46]),
					listen(input, "keypress", /*keypress_handler_3*/ ctx[47]),
					listen(input, "keydown", /*keydown_handler_3*/ ctx[48]),
					listen(input, "click", stop_propagation(prevent_default(/*click_handler_3*/ ctx[49]))),
					listen(input, "input", /*input_handler_3*/ ctx[50]),
					listen(input, "focus", /*focus_handler_3*/ ctx[51]),
					listen(input, "blur", /*blur_handler_3*/ ctx[52])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*internal*/ 1024 && input.value !== /*internal*/ ctx[10].value) {
				set_input_value(input, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (99:32) 
function create_if_block_3$2(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputFieldId*/ ctx[11]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[3];
			attr(input, "type", "password");
			attr(input, "class", "svelte-18o1pln");
			toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*internal*/ ctx[10].value);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler_2*/ ctx[92]),
					listen(input, "mouseenter", /*mouseenter_handler_3*/ ctx[37]),
					listen(input, "mouseleave", /*mouseleave_handler_3*/ ctx[38]),
					listen(input, "keypress", /*keypress_handler_2*/ ctx[39]),
					listen(input, "keydown", /*keydown_handler_2*/ ctx[40]),
					listen(input, "click", stop_propagation(prevent_default(/*click_handler_2*/ ctx[41]))),
					listen(input, "input", /*input_handler_2*/ ctx[42]),
					listen(input, "focus", /*focus_handler_2*/ ctx[43]),
					listen(input, "blur", /*blur_handler_2*/ ctx[44])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*internal*/ 1024 && input.value !== /*internal*/ ctx[10].value) {
				set_input_value(input, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (97:30) 
function create_if_block_2$4(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputFieldId*/ ctx[11]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[3];
			attr(input, "type", "number");
			attr(input, "class", "svelte-18o1pln");
			toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*internal*/ ctx[10].value);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler_1*/ ctx[91]),
					listen(input, "mouseenter", /*mouseenter_handler_2*/ ctx[29]),
					listen(input, "mouseleave", /*mouseleave_handler_2*/ ctx[30]),
					listen(input, "keypress", /*keypress_handler_1*/ ctx[31]),
					listen(input, "keydown", /*keydown_handler_1*/ ctx[32]),
					listen(input, "click", stop_propagation(prevent_default(/*click_handler_1*/ ctx[33]))),
					listen(input, "input", /*input_handler_1*/ ctx[34]),
					listen(input, "focus", /*focus_handler_1*/ ctx[35]),
					listen(input, "blur", /*blur_handler_1*/ ctx[36])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*internal*/ 1024 && to_number(input.value) !== /*internal*/ ctx[10].value) {
				set_input_value(input, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (95:2) {#if type === 'text'}
function create_if_block_1$6(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputFieldId*/ ctx[11]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[3];
			attr(input, "type", "text");
			attr(input, "class", "svelte-18o1pln");
			toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*internal*/ ctx[10].value);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[90]),
					listen(input, "mouseenter", /*mouseenter_handler_1*/ ctx[21]),
					listen(input, "mouseleave", /*mouseleave_handler_1*/ ctx[22]),
					listen(input, "keypress", /*keypress_handler*/ ctx[23]),
					listen(input, "keydown", /*keydown_handler*/ ctx[24]),
					listen(input, "click", stop_propagation(prevent_default(/*click_handler*/ ctx[25]))),
					listen(input, "input", /*input_handler*/ ctx[26]),
					listen(input, "focus", /*focus_handler*/ ctx[27]),
					listen(input, "blur", /*blur_handler*/ ctx[28])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*internal*/ 1024 && input.value !== /*internal*/ ctx[10].value) {
				set_input_value(input, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (121:6) {#if internal.value}
function create_if_block_11(ctx) {
	let i;
	let mounted;
	let dispose;

	return {
		c() {
			i = element("i");
			attr(i, "class", "fa fa-times clickable svelte-18o1pln");
		},
		m(target, anchor) {
			insert(target, i, anchor);

			if (!mounted) {
				dispose = [
					listen(i, "click", stop_propagation(prevent_default(/*click_handler_8*/ ctx[99]))),
					listen(i, "keydown", /*keydown_handler_8*/ ctx[100])
				];

				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(i);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (111:8) {#if label && !labelBeforeCheckbox}
function create_if_block_8$1(ctx) {
	let label_1;
	let t0;
	let t1;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[4] && create_if_block_9(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[1]);
			attr(label_1, "for", /*inputFieldId*/ ctx[11]);
			set_style(label_1, "width", "100%");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler_8*/ ctx[70]),
					listen(label_1, "mouseleave", /*mouseleave_handler_8*/ ctx[71])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_9(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*label*/ 2) set_data(t1, /*label*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (112:84) {#if icon}
function create_if_block_9(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-18o1pln");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 16 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-18o1pln")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

function create_fragment$e(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (!/*internal*/ ctx[10].updateNode || /*prop*/ ctx[9]) return create_if_block$a;
		return create_else_block_1$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	let { credentials = false, disabled = false, error = false, i18n, icon, id, indented = false, label, labelBeforeCheckbox = false, maximize, node, placeholder, prop, tooltip, type, value } = $$props;
	id = id || getId(prop);
	credentials = getBooleanFrom(credentials);
	indented = getBooleanFrom(indented);
	disabled = getBooleanFrom(disabled);
	error = getBooleanFrom(error);
	labelBeforeCheckbox = getBooleanFrom(labelBeforeCheckbox);
	const inputFieldId = 'node-input-' + id;
	let defaults = {};

	if (node) {
		defaults = credentials ? node._def.credentials : node._def.defaults;
	}

	let internal = initInternal(defaults[prop], value);

	// Credentials is a special case, which only occurs in Input field. Therefore we won't put the initialization of them in initInternal.
	if (credentials && node.credentials[prop]) {
		internal.value = node.credentials[prop];
	}

	// If credential is type password and has an old value we won't get that value in the editor.
	// Instead there is a "has_"+prop flag to differentate if the UI should show an empty input field or with an value.
	// If the value is "__PWRD__" the value will not be saved/changed till deploy in node.credentials[prop].
	// https://github.com/node-red/node-red/blob/master/packages/node_modules/%40node-red/editor-client/src/js/ui/editor.js
	if (internal.updateNode && credentials && node.credentials['has_' + prop]) {
		internal.value = "__PWRD__";
	}

	icon = icon || defaults[prop]?.icon || '';

	if (label !== false) {
		label = label || defaults[prop]?.label || prop || '';
	}

	placeholder = placeholder || defaults[prop]?.placeholder || '';

	if (!type) {
		let testValue = typeof defaults[prop] !== 'undefined'
		? defaults[prop].value
		: internal.value;

		if (typeof testValue === 'number') {
			type = 'number';
		} else if (typeof testValue === 'boolean') {
			type = 'checkbox';
		} else {
			type = 'text';
		}
	}

	// delay creation of tooltips as this needs jQuery and can be called often
	let init = true;

	let tooltipExists = false;

	onMount(() => {
		setTimeout(() => $$invalidate(19, init = false), 1000);
	});

	const dispatch = createEventDispatcher();

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_8(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_8(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_9(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_9(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_8(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_input_handler() {
		internal.value = this.value;
		(((((($$invalidate(10, internal), $$invalidate(13, node)), $$invalidate(9, prop)), $$invalidate(14, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(0, id));
	}

	function input_input_handler_1() {
		internal.value = to_number(this.value);
		(((((($$invalidate(10, internal), $$invalidate(13, node)), $$invalidate(9, prop)), $$invalidate(14, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(0, id));
	}

	function input_input_handler_2() {
		internal.value = this.value;
		(((((($$invalidate(10, internal), $$invalidate(13, node)), $$invalidate(9, prop)), $$invalidate(14, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(0, id));
	}

	function input_input_handler_3() {
		internal.value = this.value;
		(((((($$invalidate(10, internal), $$invalidate(13, node)), $$invalidate(9, prop)), $$invalidate(14, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(0, id));
	}

	function input_input_handler_4() {
		internal.value = this.value;
		(((((($$invalidate(10, internal), $$invalidate(13, node)), $$invalidate(9, prop)), $$invalidate(14, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(0, id));
	}

	function input0_input_handler() {
		internal.value = this.value;
		(((((($$invalidate(10, internal), $$invalidate(13, node)), $$invalidate(9, prop)), $$invalidate(14, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(0, id));
	}

	function input1_input_handler() {
		internal.value = this.value;
		(((((($$invalidate(10, internal), $$invalidate(13, node)), $$invalidate(9, prop)), $$invalidate(14, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(0, id));
	}

	function input_change_handler() {
		internal.value = this.checked;
		(((((($$invalidate(10, internal), $$invalidate(13, node)), $$invalidate(9, prop)), $$invalidate(14, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(0, id));
	}

	function input_input_handler_5() {
		internal.value = this.value;
		(((((($$invalidate(10, internal), $$invalidate(13, node)), $$invalidate(9, prop)), $$invalidate(14, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(0, id));
	}

	const click_handler_8 = () => $$invalidate(10, internal.value = '', internal);
	const keydown_handler_8 = () => $$invalidate(10, internal.value = '', internal);

	$$self.$$set = $$props => {
		if ('credentials' in $$props) $$invalidate(15, credentials = $$props.credentials);
		if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ('error' in $$props) $$invalidate(12, error = $$props.error);
		if ('i18n' in $$props) $$invalidate(16, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('indented' in $$props) $$invalidate(5, indented = $$props.indented);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('labelBeforeCheckbox' in $$props) $$invalidate(6, labelBeforeCheckbox = $$props.labelBeforeCheckbox);
		if ('maximize' in $$props) $$invalidate(8, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(13, node = $$props.node);
		if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
		if ('prop' in $$props) $$invalidate(9, prop = $$props.prop);
		if ('tooltip' in $$props) $$invalidate(17, tooltip = $$props.tooltip);
		if ('type' in $$props) $$invalidate(7, type = $$props.type);
		if ('value' in $$props) $$invalidate(14, value = $$props.value);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*node, prop, value, internal, defaults, error, id*/ 292353) {
			{
				$$invalidate(10, internal = getNewInternal(node?.[prop], value, internal, defaults?.[prop]?.validate, error, node));

				if (internal.updateNode) {
					$$invalidate(13, node[prop] = internal.value, node);
				} else {
					$$invalidate(14, value = internal.value);
				}

				if (!internal.init && internal.valueHasChanged) {
					dispatch('change', { id, value: internal.value }, { cancelable: false });
				}

				$$invalidate(10, internal.init = false, internal);
			}
		}

		if ($$self.$$.dirty[0] & /*label, node, i18n*/ 73730) {
			{
				if (label) $$invalidate(1, label = i18nTranslate(RED, node, i18n, label));
			}
		}

		if ($$self.$$.dirty[0] & /*placeholder, node, i18n*/ 73732) {
			{
				if (placeholder) $$invalidate(2, placeholder = i18nTranslate(RED, node, i18n, placeholder));
			}
		}

		if ($$self.$$.dirty[0] & /*init, tooltip, tooltipExists, id*/ 1703937) {
			{
				if (!init && (tooltip || tooltipExists)) $$invalidate(20, tooltipExists = setTooltip(tooltip, tooltipExists, '#sir-Input-Label-' + id));
			}
		}
	};

	return [
		id,
		label,
		placeholder,
		disabled,
		icon,
		indented,
		labelBeforeCheckbox,
		type,
		maximize,
		prop,
		internal,
		inputFieldId,
		error,
		node,
		value,
		credentials,
		i18n,
		tooltip,
		defaults,
		init,
		tooltipExists,
		mouseenter_handler_1,
		mouseleave_handler_1,
		keypress_handler,
		keydown_handler,
		click_handler,
		input_handler,
		focus_handler,
		blur_handler,
		mouseenter_handler_2,
		mouseleave_handler_2,
		keypress_handler_1,
		keydown_handler_1,
		click_handler_1,
		input_handler_1,
		focus_handler_1,
		blur_handler_1,
		mouseenter_handler_3,
		mouseleave_handler_3,
		keypress_handler_2,
		keydown_handler_2,
		click_handler_2,
		input_handler_2,
		focus_handler_2,
		blur_handler_2,
		mouseenter_handler_4,
		mouseleave_handler_4,
		keypress_handler_3,
		keydown_handler_3,
		click_handler_3,
		input_handler_3,
		focus_handler_3,
		blur_handler_3,
		mouseenter_handler_5,
		mouseleave_handler_5,
		keypress_handler_4,
		keydown_handler_4,
		click_handler_4,
		input_handler_4,
		focus_handler_4,
		blur_handler_4,
		mouseenter_handler_6,
		mouseleave_handler_6,
		keypress_handler_5,
		keydown_handler_5,
		input_handler_6,
		focus_handler_5,
		blur_handler_5,
		input_handler_5,
		click_handler_5,
		mouseenter_handler_8,
		mouseleave_handler_8,
		mouseenter_handler_7,
		mouseleave_handler_7,
		keypress_handler_6,
		keydown_handler_6,
		click_handler_6,
		input_handler_7,
		focus_handler_6,
		blur_handler_6,
		mouseenter_handler_9,
		mouseleave_handler_9,
		keypress_handler_7,
		keydown_handler_7,
		click_handler_7,
		input_handler_8,
		focus_handler_7,
		blur_handler_7,
		mouseenter_handler,
		mouseleave_handler,
		input_input_handler,
		input_input_handler_1,
		input_input_handler_2,
		input_input_handler_3,
		input_input_handler_4,
		input0_input_handler,
		input1_input_handler,
		input_change_handler,
		input_input_handler_5,
		click_handler_8,
		keydown_handler_8
	];
}

class PlainInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$e,
			create_fragment$e,
			safe_not_equal,
			{
				credentials: 15,
				disabled: 3,
				error: 12,
				i18n: 16,
				icon: 4,
				id: 0,
				indented: 5,
				label: 1,
				labelBeforeCheckbox: 6,
				maximize: 8,
				node: 13,
				placeholder: 2,
				prop: 9,
				tooltip: 17,
				type: 7,
				value: 14
			},
			add_css$a,
			[-1, -1, -1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/ConfigNodeInput.svelte generated by Svelte v3.58.0 */

function add_css$9(target) {
	append_styles(target, "svelte-1grox8e", ".disabled.svelte-1grox8e{pointer-events:none}.maximize.svelte-1grox8e{width:100%}");
}

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i].id;
	child_ctx[4] = list[i].label;
	return child_ctx;
}

// (107:0) {:else}
function create_else_block$2(ctx) {
	let span;
	let t0;
	let t1;

	return {
		c() {
			span = element("span");
			t0 = text("Error: ");
			t1 = text(/*error*/ ctx[8]);
			attr(span, "class", "maximize svelte-1grox8e");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*error*/ 256) set_data(t1, /*error*/ ctx[8]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (97:0) {#if node && prop}
function create_if_block$9(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let t2;
	let select;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let select_id_value;
	let select_placeholder_value;
	let t3;
	let button;
	let current;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[1] && create_if_block_1$5(ctx);
	let each_value = /*configNodes*/ ctx[9];
	const get_key = ctx => /*id*/ ctx[5];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$5(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
	}

	button = new Button({
			props: {
				id: "node-input-lookup-" + /*prop*/ ctx[6],
				inline: true,
				disabled: /*disabled*/ ctx[2],
				icon: "pencil"
			}
		});

	button.$on("click", /*editConfigNode*/ ctx[11]);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[4]);
			t2 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			create_component(button.$$.fragment);
			attr(label_1, "for", label_1_for_value = "node-input-" + /*prop*/ ctx[6]);
			attr(select, "id", select_id_value = "node-input-" + /*prop*/ ctx[6]);
			attr(select, "placeholder", select_placeholder_value = /*defaults*/ ctx[10][/*prop*/ ctx[6]].label);
			select.disabled = /*disabled*/ ctx[2];
			attr(select, "class", "svelte-1grox8e");
			if (/*selectedNode*/ ctx[7] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[17].call(select));
			toggle_class(select, "input-error", /*selectedNode*/ ctx[7] === '_ADD_');
			toggle_class(select, "maximize", /*maximize*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);
			insert(target, t2, anchor);
			insert(target, select, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(select, null);
				}
			}

			select_option(select, /*selectedNode*/ ctx[7], true);
			insert(target, t3, anchor);
			mount_component(button, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[17]),
					listen(select, "mouseenter", /*mouseenter_handler*/ ctx[14]),
					listen(select, "mouseleave", /*mouseleave_handler*/ ctx[15]),
					listen(select, "click", /*click_handler*/ ctx[16])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$5(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty & /*label*/ 16) set_data(t1, /*label*/ ctx[4]);

			if (!current || dirty & /*prop*/ 64 && label_1_for_value !== (label_1_for_value = "node-input-" + /*prop*/ ctx[6])) {
				attr(label_1, "for", label_1_for_value);
			}

			if (dirty & /*configNodes*/ 512) {
				each_value = /*configNodes*/ ctx[9];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block$5, null, get_each_context$5);
			}

			if (!current || dirty & /*prop*/ 64 && select_id_value !== (select_id_value = "node-input-" + /*prop*/ ctx[6])) {
				attr(select, "id", select_id_value);
			}

			if (!current || dirty & /*prop*/ 64 && select_placeholder_value !== (select_placeholder_value = /*defaults*/ ctx[10][/*prop*/ ctx[6]].label)) {
				attr(select, "placeholder", select_placeholder_value);
			}

			if (!current || dirty & /*disabled*/ 4) {
				select.disabled = /*disabled*/ ctx[2];
			}

			if (dirty & /*selectedNode, configNodes*/ 640) {
				select_option(select, /*selectedNode*/ ctx[7]);
			}

			if (!current || dirty & /*selectedNode*/ 128) {
				toggle_class(select, "input-error", /*selectedNode*/ ctx[7] === '_ADD_');
			}

			if (!current || dirty & /*maximize*/ 8) {
				toggle_class(select, "maximize", /*maximize*/ ctx[3]);
			}

			const button_changes = {};
			if (dirty & /*prop*/ 64) button_changes.id = "node-input-lookup-" + /*prop*/ ctx[6];
			if (dirty & /*disabled*/ 4) button_changes.disabled = /*disabled*/ ctx[2];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			if (detaching) detach(t2);
			if (detaching) detach(select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach(t3);
			destroy_component(button, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (98:33) {#if icon}
function create_if_block_1$5(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[1] + " svelte-1grox8e");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 2 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[1] + " svelte-1grox8e")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (102:6) {#each configNodes as { id, label }
function create_each_block$5(key_1, ctx) {
	let option;
	let t_value = /*label*/ ctx[4] + "";
	let t;
	let option_value_value;

	return {
		key: key_1,
		first: null,
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*id*/ ctx[5];
			option.value = option.__value;
			this.first = option;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*configNodes*/ 512 && t_value !== (t_value = /*label*/ ctx[4] + "")) set_data(t, t_value);

			if (dirty & /*configNodes*/ 512 && option_value_value !== (option_value_value = /*id*/ ctx[5])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

function create_fragment$d(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$9, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*node*/ ctx[0] && /*prop*/ ctx[6]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let { node, prop, icon, label, id, disabled = false, maximize = true, i18n } = $$props;
	id = id || getId(prop);
	let error = '';
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);

	if (!node) {
		node = {};
		error = "No node property given.";
	} else if (!prop) {
		error = "No property name given.";
	}

	const dispatch = createEventDispatcher();
	let defaults = node._def.defaults;
	icon = icon || defaults?.[prop]?.icon || '';
	label = label || defaults[prop] && defaults[prop].label || prop;
	if (label) label = i18nTranslate(RED, node, i18n, label);
	let configNodes = [];
	let previouslySelectedNode = node[prop] || '_ADD_';
	let selectedNode = node[prop] || '_ADD_';

	function updateConfigNodes() {
		$$invalidate(9, configNodes = []);
		const type = defaults[prop].type;
		const node_def = RED.nodes.getType(type);

		RED.nodes.eachConfig(function (config) {
			if (config.type === type) {
				let label = '';

				if (typeof node_def.label === 'function') {
					label = node_def.label.call(config);
				} else {
					label = node_def.label;
				}

				configNodes.push({ id: config.id, label });
			}
		});

		$$invalidate(9, configNodes = [...configNodes, { id: '_ADD_', label: `Add new ${type}...` }]);
	}

	onMount(() => {
		updateConfigNodes();

		RED.events.on('nodes:add', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();
				$$invalidate(7, selectedNode = e.id);
			}
		});

		RED.events.on('nodes:change', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();
			}
		});

		RED.events.on('nodes:remove', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();

				// Always select '_ADD_' after deleting (standard behaviour)
				// otherwise it breaks the node if only one other option was available
				$$invalidate(7, selectedNode = '_ADD_');
			}
		});
	});

	function editConfigNode() {
		// The prefix is omitted so the select gets updated by us and not by Node-RED
		RED.editor.editConfig(prop, defaults[prop].type, selectedNode); /*, 'node-input' */
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function select_change_handler() {
		selectedNode = select_value(this);
		$$invalidate(7, selectedNode);
		$$invalidate(9, configNodes);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
		if ('prop' in $$props) $$invalidate(6, prop = $$props.prop);
		if ('icon' in $$props) $$invalidate(1, icon = $$props.icon);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('id' in $$props) $$invalidate(5, id = $$props.id);
		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ('maximize' in $$props) $$invalidate(3, maximize = $$props.maximize);
		if ('i18n' in $$props) $$invalidate(12, i18n = $$props.i18n);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*selectedNode, previouslySelectedNode, prop*/ 8384) {
			{
				if (selectedNode !== previouslySelectedNode) {
					$$invalidate(0, node[prop] = selectedNode, node);

					dispatch(
						'change',
						{
							before: previouslySelectedNode,
							after: selectedNode
						},
						{ cancelable: false }
					);

					$$invalidate(13, previouslySelectedNode = selectedNode);
				}
			}
		}
	};

	return [
		node,
		icon,
		disabled,
		maximize,
		label,
		id,
		prop,
		selectedNode,
		error,
		configNodes,
		defaults,
		editConfigNode,
		i18n,
		previouslySelectedNode,
		mouseenter_handler,
		mouseleave_handler,
		click_handler,
		select_change_handler
	];
}

class ConfigNodeInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$d,
			create_fragment$d,
			safe_not_equal,
			{
				node: 0,
				prop: 6,
				icon: 1,
				label: 4,
				id: 5,
				disabled: 2,
				maximize: 3,
				i18n: 12
			},
			add_css$9
		);
	}
}

/* node_modules/svelte-integration-red/components/Input.svelte generated by Svelte v3.58.0 */

function add_css$8(target) {
	append_styles(target, "svelte-ym0ye2", ".sir-Input-Container{display:inline-flex;align-items:center;width:100%}.red-ui-popover.sir-NR-popover a{color:var(--red-ui-text-color-link) !important}.red-ui-popover.sir-NR-popover a:hover{color:var(--red-ui-text-color-link) !important;text-decoration:underline}");
}

// (58:2) {:else}
function create_else_block$1(ctx) {
	let plaininput;
	let updating_node;
	let updating_prop;
	let updating_icon;
	let updating_label;
	let updating_disabled;
	let updating_value;
	let updating_type;
	let updating_placeholder;
	let updating_maximize;
	let updating_error;
	let updating_tooltip;
	let current;

	function plaininput_node_binding(value) {
		/*plaininput_node_binding*/ ctx[30](value);
	}

	function plaininput_prop_binding(value) {
		/*plaininput_prop_binding*/ ctx[31](value);
	}

	function plaininput_icon_binding(value) {
		/*plaininput_icon_binding*/ ctx[32](value);
	}

	function plaininput_label_binding(value) {
		/*plaininput_label_binding*/ ctx[33](value);
	}

	function plaininput_disabled_binding(value) {
		/*plaininput_disabled_binding*/ ctx[34](value);
	}

	function plaininput_value_binding(value) {
		/*plaininput_value_binding*/ ctx[35](value);
	}

	function plaininput_type_binding(value) {
		/*plaininput_type_binding*/ ctx[36](value);
	}

	function plaininput_placeholder_binding(value) {
		/*plaininput_placeholder_binding*/ ctx[37](value);
	}

	function plaininput_maximize_binding(value) {
		/*plaininput_maximize_binding*/ ctx[38](value);
	}

	function plaininput_error_binding(value) {
		/*plaininput_error_binding*/ ctx[39](value);
	}

	function plaininput_tooltip_binding(value) {
		/*plaininput_tooltip_binding*/ ctx[40](value);
	}

	let plaininput_props = {
		i18n: /*i18n*/ ctx[18],
		indented: /*indented*/ ctx[6],
		credentials: /*credentials*/ ctx[16],
		labelBeforeCheckbox: /*labelBeforeCheckbox*/ ctx[9],
		id: /*id*/ ctx[5]
	};

	if (/*node*/ ctx[11] !== void 0) {
		plaininput_props.node = /*node*/ ctx[11];
	}

	if (/*prop*/ ctx[13] !== void 0) {
		plaininput_props.prop = /*prop*/ ctx[13];
	}

	if (/*icon*/ ctx[4] !== void 0) {
		plaininput_props.icon = /*icon*/ ctx[4];
	}

	if (/*label*/ ctx[8] !== void 0) {
		plaininput_props.label = /*label*/ ctx[8];
	}

	if (/*disabled*/ ctx[2] !== void 0) {
		plaininput_props.disabled = /*disabled*/ ctx[2];
	}

	if (/*value*/ ctx[1] !== void 0) {
		plaininput_props.value = /*value*/ ctx[1];
	}

	if (/*type*/ ctx[0] !== void 0) {
		plaininput_props.type = /*type*/ ctx[0];
	}

	if (/*placeholder*/ ctx[12] !== void 0) {
		plaininput_props.placeholder = /*placeholder*/ ctx[12];
	}

	if (/*maximize*/ ctx[10] !== void 0) {
		plaininput_props.maximize = /*maximize*/ ctx[10];
	}

	if (/*error*/ ctx[3] !== void 0) {
		plaininput_props.error = /*error*/ ctx[3];
	}

	if (/*tooltip*/ ctx[14] !== void 0) {
		plaininput_props.tooltip = /*tooltip*/ ctx[14];
	}

	plaininput = new PlainInput({ props: plaininput_props });
	binding_callbacks.push(() => bind(plaininput, 'node', plaininput_node_binding));
	binding_callbacks.push(() => bind(plaininput, 'prop', plaininput_prop_binding));
	binding_callbacks.push(() => bind(plaininput, 'icon', plaininput_icon_binding));
	binding_callbacks.push(() => bind(plaininput, 'label', plaininput_label_binding));
	binding_callbacks.push(() => bind(plaininput, 'disabled', plaininput_disabled_binding));
	binding_callbacks.push(() => bind(plaininput, 'value', plaininput_value_binding));
	binding_callbacks.push(() => bind(plaininput, 'type', plaininput_type_binding));
	binding_callbacks.push(() => bind(plaininput, 'placeholder', plaininput_placeholder_binding));
	binding_callbacks.push(() => bind(plaininput, 'maximize', plaininput_maximize_binding));
	binding_callbacks.push(() => bind(plaininput, 'error', plaininput_error_binding));
	binding_callbacks.push(() => bind(plaininput, 'tooltip', plaininput_tooltip_binding));
	plaininput.$on("change", /*change_handler_1*/ ctx[41]);
	plaininput.$on("mouseenter", /*mouseenter_handler_1*/ ctx[42]);
	plaininput.$on("mouseleave", /*mouseleave_handler_1*/ ctx[43]);
	plaininput.$on("click", /*click_handler_1*/ ctx[44]);
	plaininput.$on("keypress", /*keypress_handler*/ ctx[45]);
	plaininput.$on("keydown", /*keydown_handler*/ ctx[46]);
	plaininput.$on("input", /*input_handler*/ ctx[47]);
	plaininput.$on("focus", /*focus_handler*/ ctx[48]);
	plaininput.$on("blur", /*blur_handler*/ ctx[49]);

	return {
		c() {
			create_component(plaininput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(plaininput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const plaininput_changes = {};
			if (dirty[0] & /*i18n*/ 262144) plaininput_changes.i18n = /*i18n*/ ctx[18];
			if (dirty[0] & /*indented*/ 64) plaininput_changes.indented = /*indented*/ ctx[6];
			if (dirty[0] & /*credentials*/ 65536) plaininput_changes.credentials = /*credentials*/ ctx[16];
			if (dirty[0] & /*labelBeforeCheckbox*/ 512) plaininput_changes.labelBeforeCheckbox = /*labelBeforeCheckbox*/ ctx[9];
			if (dirty[0] & /*id*/ 32) plaininput_changes.id = /*id*/ ctx[5];

			if (!updating_node && dirty[0] & /*node*/ 2048) {
				updating_node = true;
				plaininput_changes.node = /*node*/ ctx[11];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty[0] & /*prop*/ 8192) {
				updating_prop = true;
				plaininput_changes.prop = /*prop*/ ctx[13];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_icon && dirty[0] & /*icon*/ 16) {
				updating_icon = true;
				plaininput_changes.icon = /*icon*/ ctx[4];
				add_flush_callback(() => updating_icon = false);
			}

			if (!updating_label && dirty[0] & /*label*/ 256) {
				updating_label = true;
				plaininput_changes.label = /*label*/ ctx[8];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty[0] & /*disabled*/ 4) {
				updating_disabled = true;
				plaininput_changes.disabled = /*disabled*/ ctx[2];
				add_flush_callback(() => updating_disabled = false);
			}

			if (!updating_value && dirty[0] & /*value*/ 2) {
				updating_value = true;
				plaininput_changes.value = /*value*/ ctx[1];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_type && dirty[0] & /*type*/ 1) {
				updating_type = true;
				plaininput_changes.type = /*type*/ ctx[0];
				add_flush_callback(() => updating_type = false);
			}

			if (!updating_placeholder && dirty[0] & /*placeholder*/ 4096) {
				updating_placeholder = true;
				plaininput_changes.placeholder = /*placeholder*/ ctx[12];
				add_flush_callback(() => updating_placeholder = false);
			}

			if (!updating_maximize && dirty[0] & /*maximize*/ 1024) {
				updating_maximize = true;
				plaininput_changes.maximize = /*maximize*/ ctx[10];
				add_flush_callback(() => updating_maximize = false);
			}

			if (!updating_error && dirty[0] & /*error*/ 8) {
				updating_error = true;
				plaininput_changes.error = /*error*/ ctx[3];
				add_flush_callback(() => updating_error = false);
			}

			if (!updating_tooltip && dirty[0] & /*tooltip*/ 16384) {
				updating_tooltip = true;
				plaininput_changes.tooltip = /*tooltip*/ ctx[14];
				add_flush_callback(() => updating_tooltip = false);
			}

			plaininput.$set(plaininput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(plaininput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(plaininput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(plaininput, detaching);
		}
	};
}

// (56:2) {#if type === 'config'}
function create_if_block$8(ctx) {
	let confignodeinput;
	let updating_node;
	let updating_prop;
	let updating_label;
	let updating_disabled;
	let updating_tooltip;
	let current;

	function confignodeinput_node_binding(value) {
		/*confignodeinput_node_binding*/ ctx[21](value);
	}

	function confignodeinput_prop_binding(value) {
		/*confignodeinput_prop_binding*/ ctx[22](value);
	}

	function confignodeinput_label_binding(value) {
		/*confignodeinput_label_binding*/ ctx[23](value);
	}

	function confignodeinput_disabled_binding(value) {
		/*confignodeinput_disabled_binding*/ ctx[24](value);
	}

	function confignodeinput_tooltip_binding(value) {
		/*confignodeinput_tooltip_binding*/ ctx[25](value);
	}

	let confignodeinput_props = {
		icon: /*icon*/ ctx[4],
		i18n: /*i18n*/ ctx[18],
		indented: /*indented*/ ctx[6]
	};

	if (/*node*/ ctx[11] !== void 0) {
		confignodeinput_props.node = /*node*/ ctx[11];
	}

	if (/*prop*/ ctx[13] !== void 0) {
		confignodeinput_props.prop = /*prop*/ ctx[13];
	}

	if (/*label*/ ctx[8] !== void 0) {
		confignodeinput_props.label = /*label*/ ctx[8];
	}

	if (/*disabled*/ ctx[2] !== void 0) {
		confignodeinput_props.disabled = /*disabled*/ ctx[2];
	}

	if (/*tooltip*/ ctx[14] !== void 0) {
		confignodeinput_props.tooltip = /*tooltip*/ ctx[14];
	}

	confignodeinput = new ConfigNodeInput({ props: confignodeinput_props });
	binding_callbacks.push(() => bind(confignodeinput, 'node', confignodeinput_node_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'prop', confignodeinput_prop_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'label', confignodeinput_label_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'disabled', confignodeinput_disabled_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'tooltip', confignodeinput_tooltip_binding));
	confignodeinput.$on("change", /*change_handler*/ ctx[26]);
	confignodeinput.$on("mouseenter", /*mouseenter_handler*/ ctx[27]);
	confignodeinput.$on("mouseleave", /*mouseleave_handler*/ ctx[28]);
	confignodeinput.$on("click", /*click_handler*/ ctx[29]);

	return {
		c() {
			create_component(confignodeinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(confignodeinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const confignodeinput_changes = {};
			if (dirty[0] & /*icon*/ 16) confignodeinput_changes.icon = /*icon*/ ctx[4];
			if (dirty[0] & /*i18n*/ 262144) confignodeinput_changes.i18n = /*i18n*/ ctx[18];
			if (dirty[0] & /*indented*/ 64) confignodeinput_changes.indented = /*indented*/ ctx[6];

			if (!updating_node && dirty[0] & /*node*/ 2048) {
				updating_node = true;
				confignodeinput_changes.node = /*node*/ ctx[11];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty[0] & /*prop*/ 8192) {
				updating_prop = true;
				confignodeinput_changes.prop = /*prop*/ ctx[13];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_label && dirty[0] & /*label*/ 256) {
				updating_label = true;
				confignodeinput_changes.label = /*label*/ ctx[8];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty[0] & /*disabled*/ 4) {
				updating_disabled = true;
				confignodeinput_changes.disabled = /*disabled*/ ctx[2];
				add_flush_callback(() => updating_disabled = false);
			}

			if (!updating_tooltip && dirty[0] & /*tooltip*/ 16384) {
				updating_tooltip = true;
				confignodeinput_changes.tooltip = /*tooltip*/ ctx[14];
				add_flush_callback(() => updating_tooltip = false);
			}

			confignodeinput.$set(confignodeinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(confignodeinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(confignodeinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(confignodeinput, detaching);
		}
	};
}

// (55:0) <Row id="sir-Input-Container-{id}" clazz="{clazz} sir-Input-Container" {inline} {maximize} {fading} {style}>
function create_default_slot$8(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$8, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[0] === 'config') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$c(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Input-Container-" + /*id*/ ctx[5],
				clazz: "" + (/*clazz*/ ctx[15] + " sir-Input-Container"),
				inline: /*inline*/ ctx[7],
				maximize: /*maximize*/ ctx[10],
				fading: /*fading*/ ctx[17],
				style: /*style*/ ctx[19],
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty[0] & /*id*/ 32) row_changes.id = "sir-Input-Container-" + /*id*/ ctx[5];
			if (dirty[0] & /*clazz*/ 32768) row_changes.clazz = "" + (/*clazz*/ ctx[15] + " sir-Input-Container");
			if (dirty[0] & /*inline*/ 128) row_changes.inline = /*inline*/ ctx[7];
			if (dirty[0] & /*maximize*/ 1024) row_changes.maximize = /*maximize*/ ctx[10];
			if (dirty[0] & /*fading*/ 131072) row_changes.fading = /*fading*/ ctx[17];
			if (dirty[0] & /*style*/ 524288) row_changes.style = /*style*/ ctx[19];

			if (dirty[0] & /*icon, i18n, indented, node, prop, label, disabled, tooltip, type, credentials, labelBeforeCheckbox, id, value, placeholder, maximize, error*/ 360319 | dirty[1] & /*$$scope*/ 524288) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	let { checked, clazz = '', credentials, disabled = false, error, fading = true, i18n, icon, id, indented = false, inline = false, label, labelBeforeCheckbox = false, maximize = true, node, placeholder, prop, style = '', tooltip = '', type, value } = $$props;
	id = id || getId(prop);
	inline = getBooleanFrom(inline);
	maximize = getBooleanFrom(maximize);
	disabled = getBooleanFrom(disabled);
	indented = getBooleanFrom(indented);
	labelBeforeCheckbox = getBooleanFrom(labelBeforeCheckbox);

	if (typeof error !== 'undefined') {
		error = getBooleanFrom(error);
	}

	// loading node: if only node is bound for any input field in the svelte code, value would be undefined if the input field is empty or false
	if (type !== 'checkbox' && typeof value === 'undefined' && typeof node?.[prop] !== 'undefined') {
		value = node[prop];
	} else if (type === 'checkbox' && typeof value === 'undefined') {
		// special case for checkbox: bind:checked (offical property) could also be used and has prio before getting it possibly from node[prop]
		if (typeof checked !== 'undefined') {
			value = getBooleanFrom(checked);
		} else if (typeof node?.[prop] !== 'undefined') {
			value = getBooleanFrom(node[prop]);
		}
	}

	function confignodeinput_node_binding(value) {
		node = value;
		$$invalidate(11, node);
	}

	function confignodeinput_prop_binding(value) {
		prop = value;
		$$invalidate(13, prop);
	}

	function confignodeinput_label_binding(value) {
		label = value;
		$$invalidate(8, label);
	}

	function confignodeinput_disabled_binding(value) {
		disabled = value;
		$$invalidate(2, disabled);
	}

	function confignodeinput_tooltip_binding(value) {
		tooltip = value;
		$$invalidate(14, tooltip);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function plaininput_node_binding(value) {
		node = value;
		$$invalidate(11, node);
	}

	function plaininput_prop_binding(value) {
		prop = value;
		$$invalidate(13, prop);
	}

	function plaininput_icon_binding(value) {
		icon = value;
		$$invalidate(4, icon);
	}

	function plaininput_label_binding(value) {
		label = value;
		$$invalidate(8, label);
	}

	function plaininput_disabled_binding(value) {
		disabled = value;
		$$invalidate(2, disabled);
	}

	function plaininput_value_binding(value$1) {
		value = value$1;
		$$invalidate(1, value);
	}

	function plaininput_type_binding(value) {
		type = value;
		$$invalidate(0, type);
	}

	function plaininput_placeholder_binding(value) {
		placeholder = value;
		$$invalidate(12, placeholder);
	}

	function plaininput_maximize_binding(value) {
		maximize = value;
		$$invalidate(10, maximize);
	}

	function plaininput_error_binding(value) {
		error = value;
		$$invalidate(3, error);
	}

	function plaininput_tooltip_binding(value) {
		tooltip = value;
		$$invalidate(14, tooltip);
	}

	function change_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('checked' in $$props) $$invalidate(20, checked = $$props.checked);
		if ('clazz' in $$props) $$invalidate(15, clazz = $$props.clazz);
		if ('credentials' in $$props) $$invalidate(16, credentials = $$props.credentials);
		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ('error' in $$props) $$invalidate(3, error = $$props.error);
		if ('fading' in $$props) $$invalidate(17, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(18, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(5, id = $$props.id);
		if ('indented' in $$props) $$invalidate(6, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(7, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(8, label = $$props.label);
		if ('labelBeforeCheckbox' in $$props) $$invalidate(9, labelBeforeCheckbox = $$props.labelBeforeCheckbox);
		if ('maximize' in $$props) $$invalidate(10, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(11, node = $$props.node);
		if ('placeholder' in $$props) $$invalidate(12, placeholder = $$props.placeholder);
		if ('prop' in $$props) $$invalidate(13, prop = $$props.prop);
		if ('style' in $$props) $$invalidate(19, style = $$props.style);
		if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
		if ('type' in $$props) $$invalidate(0, type = $$props.type);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*type, checked, value*/ 1048579) {
			// if checkbox has checked bound it must be updated with the value property (needed)
			if (type === 'checkbox' && typeof checked !== 'undefined' && typeof value !== 'undefined') {
				$$invalidate(20, checked = getBooleanFrom(value));
			}
		}
	};

	return [
		type,
		value,
		disabled,
		error,
		icon,
		id,
		indented,
		inline,
		label,
		labelBeforeCheckbox,
		maximize,
		node,
		placeholder,
		prop,
		tooltip,
		clazz,
		credentials,
		fading,
		i18n,
		style,
		checked,
		confignodeinput_node_binding,
		confignodeinput_prop_binding,
		confignodeinput_label_binding,
		confignodeinput_disabled_binding,
		confignodeinput_tooltip_binding,
		change_handler,
		mouseenter_handler,
		mouseleave_handler,
		click_handler,
		plaininput_node_binding,
		plaininput_prop_binding,
		plaininput_icon_binding,
		plaininput_label_binding,
		plaininput_disabled_binding,
		plaininput_value_binding,
		plaininput_type_binding,
		plaininput_placeholder_binding,
		plaininput_maximize_binding,
		plaininput_error_binding,
		plaininput_tooltip_binding,
		change_handler_1,
		mouseenter_handler_1,
		mouseleave_handler_1,
		click_handler_1,
		keypress_handler,
		keydown_handler,
		input_handler,
		focus_handler,
		blur_handler
	];
}

class Input extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$c,
			create_fragment$c,
			safe_not_equal,
			{
				checked: 20,
				clazz: 15,
				credentials: 16,
				disabled: 2,
				error: 3,
				fading: 17,
				i18n: 18,
				icon: 4,
				id: 5,
				indented: 6,
				inline: 7,
				label: 8,
				labelBeforeCheckbox: 9,
				maximize: 10,
				node: 11,
				placeholder: 12,
				prop: 13,
				style: 19,
				tooltip: 14,
				type: 0,
				value: 1
			},
			add_css$8,
			[-1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/Select.svelte generated by Svelte v3.58.0 */

function add_css$7(target) {
	append_styles(target, "svelte-1m0uqs8", ".disabled.svelte-1m0uqs8{pointer-events:none}.maximize.svelte-1m0uqs8{width:100%}.sir-Input-Container select, .sir-Select select{padding-left:3px}.sir-Select{display:inline-flex;width:100%;align-items:center}");
}

// (55:2) {#if label}
function create_if_block$7(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let if_block = /*icon*/ ctx[4] && create_if_block_1$4(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[1]);
			attr(label_1, "for", label_1_for_value = "node-input-" + /*id*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$4(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*label*/ 2) set_data(t1, /*label*/ ctx[1]);

			if (dirty & /*id*/ 1 && label_1_for_value !== (label_1_for_value = "node-input-" + /*id*/ ctx[0])) {
				attr(label_1, "for", label_1_for_value);
			}
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
		}
	};
}

// (56:33) {#if icon}
function create_if_block_1$4(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1m0uqs8");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 16 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1m0uqs8")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (54:0) <Row id="sir-Select-{id}-Container" clazz="{clazz} sir-Select" {inline} {style} {fading}>
function create_default_slot$7(ctx) {
	let t;
	let select;
	let select_id_value;
	let select_placeholder_value;
	let current;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[1] && create_if_block$7(ctx);
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			select = element("select");
			if (default_slot) default_slot.c();
			attr(select, "id", select_id_value = "node-input-" + /*id*/ ctx[0]);
			select.disabled = /*disabled*/ ctx[3];
			attr(select, "placeholder", select_placeholder_value = /*node*/ ctx[2] && /*defaults*/ ctx[12][/*prop*/ ctx[9]].label || '');
			attr(select, "class", "svelte-1m0uqs8");
			if (/*internal*/ ctx[11].value === void 0) add_render_callback(() => /*select_change_handler*/ ctx[19].call(select));
			toggle_class(select, "maximize", /*maximize*/ ctx[6]);
			toggle_class(select, "input-error", /*internal*/ ctx[11].isError);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*internal*/ ctx[11].value, true);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[19]),
					listen(select, "mouseenter", /*mouseenter_handler*/ ctx[17]),
					listen(select, "mouseleave", /*mouseleave_handler*/ ctx[18])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 1 && select_id_value !== (select_id_value = "node-input-" + /*id*/ ctx[0])) {
				attr(select, "id", select_id_value);
			}

			if (!current || dirty & /*disabled*/ 8) {
				select.disabled = /*disabled*/ ctx[3];
			}

			if (!current || dirty & /*node, prop*/ 516 && select_placeholder_value !== (select_placeholder_value = /*node*/ ctx[2] && /*defaults*/ ctx[12][/*prop*/ ctx[9]].label || '')) {
				attr(select, "placeholder", select_placeholder_value);
			}

			if (dirty & /*internal*/ 2048) {
				select_option(select, /*internal*/ ctx[11].value);
			}

			if (!current || dirty & /*maximize*/ 64) {
				toggle_class(select, "maximize", /*maximize*/ ctx[6]);
			}

			if (!current || dirty & /*internal*/ 2048) {
				toggle_class(select, "input-error", /*internal*/ ctx[11].isError);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(select);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$b(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Select-" + /*id*/ ctx[0] + "-Container",
				clazz: "" + (/*clazz*/ ctx[7] + " sir-Select"),
				inline: /*inline*/ ctx[5],
				style: /*style*/ ctx[10],
				fading: /*fading*/ ctx[8],
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*id*/ 1) row_changes.id = "sir-Select-" + /*id*/ ctx[0] + "-Container";
			if (dirty & /*clazz*/ 128) row_changes.clazz = "" + (/*clazz*/ ctx[7] + " sir-Select");
			if (dirty & /*inline*/ 32) row_changes.inline = /*inline*/ ctx[5];
			if (dirty & /*style*/ 1024) row_changes.style = /*style*/ ctx[10];
			if (dirty & /*fading*/ 256) row_changes.fading = /*fading*/ ctx[8];

			if (dirty & /*$$scope, id, disabled, node, prop, internal, maximize, label, icon*/ 1051231) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { clazz = '', disabled = false, error = false, fading = true, i18n, icon, id, inline = false, label, maximize = true, node, prop, style = "", value } = $$props;
	id = id || getId(prop);
	inline = getBooleanFrom(inline);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	error = getBooleanFrom(error);
	let defaults = node ? node._def.defaults : {};
	icon = icon || defaults?.[prop]?.icon || '';

	if (label !== false) {
		label = label || node && (defaults[prop] && defaults[prop].label || prop);
	}

	const dispatch = createEventDispatcher();
	let internal = initInternal(defaults[prop], value);

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function select_change_handler() {
		internal.value = select_value(this);
		(((((($$invalidate(11, internal), $$invalidate(2, node)), $$invalidate(9, prop)), $$invalidate(14, value)), $$invalidate(12, defaults)), $$invalidate(13, error)), $$invalidate(0, id));
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(7, clazz = $$props.clazz);
		if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ('error' in $$props) $$invalidate(13, error = $$props.error);
		if ('fading' in $$props) $$invalidate(8, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(15, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('inline' in $$props) $$invalidate(5, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(6, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(2, node = $$props.node);
		if ('prop' in $$props) $$invalidate(9, prop = $$props.prop);
		if ('style' in $$props) $$invalidate(10, style = $$props.style);
		if ('value' in $$props) $$invalidate(14, value = $$props.value);
		if ('$$scope' in $$props) $$invalidate(20, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*node, prop, value, internal, error, id*/ 27141) {
			{
				$$invalidate(11, internal = getNewInternal(node?.[prop], value, internal, defaults?.[prop]?.validate, error, node));

				if (internal.updateNode) {
					$$invalidate(2, node[prop] = internal.value, node);
				} else {
					$$invalidate(14, value = internal.value);
				}

				if (!internal.init && internal.valueHasChanged) {
					dispatch('change', { id, value: internal.value }, { cancelable: false });
				}

				$$invalidate(11, internal.init = false, internal);
			}
		}

		if ($$self.$$.dirty & /*label, node, i18n*/ 32774) {
			{
				if (label) {
					$$invalidate(1, label = i18nTranslate(RED, node, i18n, label));
				}
			}
		}
	};

	return [
		id,
		label,
		node,
		disabled,
		icon,
		inline,
		maximize,
		clazz,
		fading,
		prop,
		style,
		internal,
		defaults,
		error,
		value,
		i18n,
		slots,
		mouseenter_handler,
		mouseleave_handler,
		select_change_handler,
		$$scope
	];
}

class Select extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$b,
			create_fragment$b,
			safe_not_equal,
			{
				clazz: 7,
				disabled: 3,
				error: 13,
				fading: 8,
				i18n: 15,
				icon: 4,
				id: 0,
				inline: 5,
				label: 1,
				maximize: 6,
				node: 2,
				prop: 9,
				style: 10,
				value: 14
			},
			add_css$7
		);
	}
}

/* node_modules/svelte-integration-red/components/TabbedPane.svelte generated by Svelte v3.58.0 */

function add_css$6(target) {
	append_styles(target, "svelte-10kvkej", ".sir-TabedPane.svelte-10kvkej.svelte-10kvkej{margin-bottom:12px;overflow:hidden}.sir-TabedPane.svelte-10kvkej ul.sir-Tablist li.svelte-10kvkej{min-width:80px}.scrollButton.svelte-10kvkej.svelte-10kvkej{width:20px;margin-top:3px;position:absolute;z-index:10;border:1px solid var(--red-ui-primary-border-color);height:30px;cursor:pointer;background:var(--red-ui-primary-background)}.scrollButton.svelte-10kvkej.svelte-10kvkej:hover{background:var(--red-ui-secondary-background-hover)}.scrollButtonLeft.svelte-10kvkej.svelte-10kvkej{left:0px}.scrollButtonRight.svelte-10kvkej.svelte-10kvkej{top:0px;right:0px}.hasScrollButtons.svelte-10kvkej.svelte-10kvkej{margin-left:21px;margin-right:22px}.scrollButton.svelte-10kvkej i.svelte-10kvkej{padding-left:7px;padding-top:8px}.sir-TabedPaneContainer.svelte-10kvkej.svelte-10kvkej{position:relative}");
}

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i].id;
	child_ctx[28] = list[i].name;
	child_ctx[29] = list[i].icon;
	child_ctx[31] = i;
	return child_ctx;
}

// (132:2) {#if showScrollButton}
function create_if_block_2$3(ctx) {
	let div;
	let i;
	let div_id_value;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			i = element("i");
			attr(i, "class", "fa fa-caret-left svelte-10kvkej");
			attr(div, "id", div_id_value = "tabs-" + /*id*/ ctx[1] + "-scrollLeft");
			attr(div, "class", "scrollButton scrollButtonLeft svelte-10kvkej");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, i);

			if (!mounted) {
				dispose = [
					listen(div, "mouseover", /*mouseover_handler*/ ctx[17]),
					listen(div, "focus", /*focus_handler*/ ctx[18]),
					listen(div, "mouseout", /*stopScroll*/ ctx[9]),
					listen(div, "blur", /*stopScroll*/ ctx[9])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*id*/ 2 && div_id_value !== (div_id_value = "tabs-" + /*id*/ ctx[1] + "-scrollLeft")) {
				attr(div, "id", div_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (146:12) {#if icon}
function create_if_block_1$3(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "red-ui-tab-icon fa fa-" + /*icon*/ ctx[29] + " svelte-10kvkej");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*shadowTabs*/ 16 && i_class_value !== (i_class_value = "red-ui-tab-icon fa fa-" + /*icon*/ ctx[29] + " svelte-10kvkej")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (142:6) {#each shadowTabs as {id, name, icon}
function create_each_block$4(key_1, ctx) {
	let li;
	let a;
	let t0;
	let span0;
	let t1_value = /*name*/ ctx[28] + "";
	let t1;
	let t2;
	let span1;
	let t3;
	let span2;
	let a_title_value;
	let t4;
	let li_id_value;
	let li_style_value;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[29] && create_if_block_1$3(ctx);

	function click_handler_1() {
		return /*click_handler_1*/ ctx[19](/*id*/ ctx[1]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			a = element("a");
			if (if_block) if_block.c();
			t0 = space();
			span0 = element("span");
			t1 = text(t1_value);
			t2 = space();
			span1 = element("span");
			t3 = space();
			span2 = element("span");
			t4 = space();
			attr(span0, "class", "red-ui-text-bidi-aware");
			attr(span0, "dir", "");
			attr(span1, "class", "red-ui-tabs-fade");
			attr(span2, "class", "red-ui-tabs-badges");
			attr(a, "href", '#');
			attr(a, "class", "red-ui-tab-label");
			attr(a, "title", a_title_value = /*name*/ ctx[28]);
			attr(a, "draggable", "false");
			attr(li, "id", li_id_value = "sir-Tabselection-" + /*id*/ ctx[1]);
			attr(li, "class", "red-ui-tab svelte-10kvkej");
			attr(li, "style", li_style_value = "width: " + /*tabWidth*/ ctx[5]);
			toggle_class(li, "active", /*active*/ ctx[0] === /*id*/ ctx[1]);
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);
			if (if_block) if_block.m(a, null);
			append(a, t0);
			append(a, span0);
			append(span0, t1);
			append(a, t2);
			append(a, span1);
			append(a, t3);
			append(a, span2);
			append(li, t4);

			if (!mounted) {
				dispose = [
					listen(a, "click", click_handler_1),
					listen(li, "click", /*click_handler*/ ctx[15]),
					listen(li, "keydown", /*keydown_handler*/ ctx[16])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*icon*/ ctx[29]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					if_block.m(a, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*shadowTabs*/ 16 && t1_value !== (t1_value = /*name*/ ctx[28] + "")) set_data(t1, t1_value);

			if (dirty[0] & /*shadowTabs*/ 16 && a_title_value !== (a_title_value = /*name*/ ctx[28])) {
				attr(a, "title", a_title_value);
			}

			if (dirty[0] & /*shadowTabs*/ 16 && li_id_value !== (li_id_value = "sir-Tabselection-" + /*id*/ ctx[1])) {
				attr(li, "id", li_id_value);
			}

			if (dirty[0] & /*tabWidth*/ 32 && li_style_value !== (li_style_value = "width: " + /*tabWidth*/ ctx[5])) {
				attr(li, "style", li_style_value);
			}

			if (dirty[0] & /*active, shadowTabs*/ 17) {
				toggle_class(li, "active", /*active*/ ctx[0] === /*id*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(li);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (157:2) {#if showScrollButton}
function create_if_block$6(ctx) {
	let div;
	let i;
	let div_id_value;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			i = element("i");
			attr(i, "class", "fa fa-caret-right svelte-10kvkej");
			attr(div, "id", div_id_value = "tabs-" + /*id*/ ctx[1] + "-scrollRight");
			attr(div, "class", "scrollButton scrollButtonRight svelte-10kvkej");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, i);

			if (!mounted) {
				dispose = [
					listen(div, "mouseover", /*mouseover_handler_1*/ ctx[20]),
					listen(div, "focus", /*focus_handler_1*/ ctx[21]),
					listen(div, "mouseout", /*stopScroll*/ ctx[9]),
					listen(div, "blur", /*stopScroll*/ ctx[9])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*id*/ 2 && div_id_value !== (div_id_value = "tabs-" + /*id*/ ctx[1] + "-scrollRight")) {
				attr(div, "id", div_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$a(ctx) {
	let div1;
	let t0;
	let div0;
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let ul_id_value;
	let div0_id_value;
	let t1;
	let div1_class_value;
	let t2;
	let div2;
	let div2_id_value;
	let current;
	let if_block0 = /*showScrollButton*/ ctx[6] && create_if_block_2$3(ctx);
	let each_value = /*shadowTabs*/ ctx[4];
	const get_key = ctx => /*i*/ ctx[31];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$4(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$4(key, child_ctx));
	}

	let if_block1 = /*showScrollButton*/ ctx[6] && create_if_block$6(ctx);
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	return {
		c() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div0 = element("div");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div2 = element("div");
			if (default_slot) default_slot.c();
			attr(ul, "id", ul_id_value = "tabs-" + /*id*/ ctx[1]);
			attr(ul, "class", "sir-Tablist");
			attr(div0, "id", div0_id_value = "sir-TabedPane-" + /*id*/ ctx[1]);
			attr(div0, "class", "sir-TabedPane red-ui-tabs svelte-10kvkej");
			toggle_class(div0, "hasScrollButtons", /*showScrollButton*/ ctx[6]);
			attr(div1, "class", div1_class_value = "" + (/*clazz*/ ctx[2] + " sir-TabedPaneContainer" + " svelte-10kvkej"));
			attr(div1, "style", /*style*/ ctx[3]);
			attr(div2, "id", div2_id_value = "tabs-content-" + /*id*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t0);
			append(div1, div0);
			append(div0, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ul, null);
				}
			}

			append(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			insert(target, t2, anchor);
			insert(target, div2, anchor);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*showScrollButton*/ ctx[6]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$3(ctx);
					if_block0.c();
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*shadowTabs, tabWidth, active, showTabContent*/ 177) {
				each_value = /*shadowTabs*/ ctx[4];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, destroy_block, create_each_block$4, null, get_each_context$4);
			}

			if (!current || dirty[0] & /*id*/ 2 && ul_id_value !== (ul_id_value = "tabs-" + /*id*/ ctx[1])) {
				attr(ul, "id", ul_id_value);
			}

			if (!current || dirty[0] & /*id*/ 2 && div0_id_value !== (div0_id_value = "sir-TabedPane-" + /*id*/ ctx[1])) {
				attr(div0, "id", div0_id_value);
			}

			if (!current || dirty[0] & /*showScrollButton*/ 64) {
				toggle_class(div0, "hasScrollButtons", /*showScrollButton*/ ctx[6]);
			}

			if (/*showScrollButton*/ ctx[6]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$6(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty[0] & /*clazz*/ 4 && div1_class_value !== (div1_class_value = "" + (/*clazz*/ ctx[2] + " sir-TabedPaneContainer" + " svelte-10kvkej"))) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty[0] & /*style*/ 8) {
				attr(div1, "style", /*style*/ ctx[3]);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}

			if (!current || dirty[0] & /*id*/ 2 && div2_id_value !== (div2_id_value = "tabs-content-" + /*id*/ ctx[1])) {
				attr(div2, "id", div2_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (if_block1) if_block1.d();
			if (detaching) detach(t2);
			if (detaching) detach(div2);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { active, clazz = '', i18n, id, node, style = '', tabs = {} } = $$props;
	id = id || getId();

	if (Array.isArray(tabs) || typeof tabs !== 'object' || !Object.keys(tabs).length) {
		tabs = { '0': 'No (valid) tabs defined' };
	}

	// lets keep the tabs property as an Object to ensure for the user that each key name only exists one time. Intern we can handle it as an array.
	let shadowTabs = [];

	let tabWidth = 0;

	const updateTabs = () => {
		$$invalidate(4, shadowTabs = []);

		Object.keys(tabs).forEach(tabKey => {
			if (typeof tabs[tabKey] === 'string') {
				// downward compatible
				shadowTabs.push({
					id: tabKey,
					name: i18nTranslate(RED, node, i18n, tabs[tabKey])
				});
			} else {
				const tabClone = Object.assign({}, tabs[tabKey]);
				tabClone.id = tabClone.id || tabKey;
				tabClone.name = i18nTranslate(RED, node, i18n, tabClone.name);
				shadowTabs.push(tabClone);
			}
		});

		// tabWidth = (100 / shadowTabs.length) + '%'
		$$invalidate(5, tabWidth = 'calc(' + 100 / shadowTabs.length + '% - 6px);');
	};

	const showTabContent = tabKey => {
		const tabsContent = document.getElementById('tabs-content-' + id).querySelectorAll('div.sir-Tab');

		tabsContent.forEach(tab => {
			tab.style.display = 'none';
		});

		// class is unique here...
		const content = document.getElementById('tabs-content-' + id).getElementsByClassName('tab-' + tabKey)[0];

		if (content) {
			content.style.display = 'block';
		} else {
			console.log('[sir] No valid content found for tab key ' + tabKey);
		}

		$$invalidate(0, active = tabKey);
	};

	// Button left and right for scrolling!
	let overflowIntervall;

	let showScrollButton = false;

	const checkOverflow = (_e, once = false) => {
		let counter = 0;

		overflowIntervall = setInterval(
			function () {
				counter++;
				const tabsElement = document.getElementById('tabs-' + id);
				if (!tabsElement?.scrollWidth) stopCheckOverflow();

				if (tabsElement.scrollWidth > tabsElement.clientWidth && document.getElementById('tabs-' + id).children[0].clientWidth < 100) {
					$$invalidate(6, showScrollButton = true);
				} else {
					$$invalidate(6, showScrollButton = false);
					document.getElementById('sir-TabedPane-' + id).scrollLeft = 0;
				}

				// just in case...
				if (counter > 2000 || once) stopCheckOverflow();
			},
			100
		);
	};

	const stopCheckOverflow = () => {
		if (overflowIntervall) clearInterval(overflowIntervall);
	};

	const resizeHandle = document.getElementsByClassName('red-ui-tray-resize-handle ui-draggable-handle')[0];
	resizeHandle.addEventListener('mousedown', checkOverflow);
	resizeHandle.addEventListener('mouseup', stopCheckOverflow);
	let scrollIntervall;

	const doScroll = amount => {
		scrollIntervall = setInterval(
			function () {
				document.getElementById('sir-TabedPane-' + id).scrollLeft += amount;
			},
			100
		);
	};

	const stopScroll = () => {
		if (scrollIntervall) clearInterval(scrollIntervall);
	};

	onMount(() => {
		$$invalidate(0, active = active || shadowTabs[0].id);
		showTabContent(active);
		checkOverflow(null, true);
	});

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	const mouseover_handler = () => doScroll(-20);
	const focus_handler = () => doScroll(-20);
	const click_handler_1 = id => showTabContent(id);
	const mouseover_handler_1 = () => doScroll(20);
	const focus_handler_1 = () => doScroll(20);

	$$self.$$set = $$props => {
		if ('active' in $$props) $$invalidate(0, active = $$props.active);
		if ('clazz' in $$props) $$invalidate(2, clazz = $$props.clazz);
		if ('i18n' in $$props) $$invalidate(11, i18n = $$props.i18n);
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('node' in $$props) $$invalidate(12, node = $$props.node);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
		if ('tabs' in $$props) $$invalidate(10, tabs = $$props.tabs);
		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*tabs*/ 1024) {
			updateTabs();
		}
	};

	return [
		active,
		id,
		clazz,
		style,
		shadowTabs,
		tabWidth,
		showScrollButton,
		showTabContent,
		doScroll,
		stopScroll,
		tabs,
		i18n,
		node,
		$$scope,
		slots,
		click_handler,
		keydown_handler,
		mouseover_handler,
		focus_handler,
		click_handler_1,
		mouseover_handler_1,
		focus_handler_1
	];
}

class TabbedPane extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$a,
			create_fragment$a,
			safe_not_equal,
			{
				active: 0,
				clazz: 2,
				i18n: 11,
				id: 1,
				node: 12,
				style: 3,
				tabs: 10
			},
			add_css$6,
			[-1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/TabContent.svelte generated by Svelte v3.58.0 */

function add_css$5(target) {
	append_styles(target, "svelte-12yzo6k", ".sir-Tab.svelte-12yzo6k{display:inline-flex;flex-direction:column;width:100%}");
}

function create_fragment$9(ctx) {
	let div;
	let div_class_value;
	let div_style_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", div_class_value = "" + (/*clazz*/ ctx[0] + " sir-Tab tab-" + /*tab*/ ctx[2] + " svelte-12yzo6k"));
			attr(div, "style", div_style_value = "display:none; " + /*style*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "click", /*click_handler*/ ctx[5]),
					listen(div, "keypress", /*keypress_handler*/ ctx[6]),
					listen(div, "keydown", /*keydown_handler*/ ctx[7])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*clazz, tab*/ 5 && div_class_value !== (div_class_value = "" + (/*clazz*/ ctx[0] + " sir-Tab tab-" + /*tab*/ ctx[2] + " svelte-12yzo6k"))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 2 && div_style_value !== (div_style_value = "display:none; " + /*style*/ ctx[1])) {
				attr(div, "style", div_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { clazz = '', style = '', tab } = $$props;

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(0, clazz = $$props.clazz);
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
		if ('tab' in $$props) $$invalidate(2, tab = $$props.tab);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [
		clazz,
		style,
		tab,
		$$scope,
		slots,
		click_handler,
		keypress_handler,
		keydown_handler
	];
}

class TabContent extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { clazz: 0, style: 1, tab: 2 }, add_css$5);
	}
}

function closeOptions () {
  // other TypedInput-Options could be open therefor using classes instead of variables like class:hide={optionHidden}
  document.querySelectorAll('.sir-typedInput-options').forEach(o => o.classList.add('hide'));
  document.querySelectorAll('.sir-typedInput-valueOptions').forEach(o => o.classList.add('hide'));
  removeEventListeners();
}

function removeEventListeners () {
  document.removeEventListener('click', closeOptions);
  document.removeEventListener('keydown', optionKeys);
}

function optionKeys (e) {
  if (e.code === 'Escape') {
    e.preventDefault();
    closeOptions();
  } else if (e.code === 'ArrowDown') {
    e.preventDefault();
    document.activeElement.nextSibling?.focus();
  } else if (e.code === 'ArrowUp') {
    e.preventDefault();
    document.activeElement.previousSibling?.focus();
  }
}

const getOptionsPosition = (buttonPos, id) => {
  let button, options;
  if (buttonPos === 'left') {
    button = document.getElementById('sir-TypedInput-Options-Button-' + id);
    options = document.getElementById('sir-TypedInput-Options-' + id).getBoundingClientRect();
  } else {
    button = document.getElementById('sir-TypedInput-Value-Options-Button-' + id);
    options = document.getElementById('sir-TypedInput-Value-Options-' + id).getBoundingClientRect();
  }
  const buttonDOMRect = button.getBoundingClientRect();
  let top = buttonDOMRect.bottom;
  if (top + options.height > window.innerHeight) {
    top = buttonDOMRect.top - options.height;
  }
  let left = buttonDOMRect.left;
  if (left + options.width > window.innerWidth) {
    left = left - options.width + buttonDOMRect.width;
  }
  return 'top: ' + top + 'px; left: ' + left + 'px; min-width: ' + buttonDOMRect.width + 'px;'
};

/* node_modules/svelte-integration-red/components/PlainTypedInput.svelte generated by Svelte v3.58.0 */

function add_css$4(target) {
	append_styles(target, "svelte-r4tlf4", ".maximize.svelte-r4tlf4{width:100%}.sir-typedInput-options.svelte-r4tlf4,.sir-typedInput-valueOptions.svelte-r4tlf4{position:fixed}.sir-ui-typedInput-type-label.svelte-r4tlf4{margin-top:1px}.sir-ui-typedInput-svgIcon{margin-right:4px;height:18px;width:13px}.red-ui-typedInput-options.red-ui-editor-dialog.sir-typedInput-options .sir-ui-typedInput-svgIcon{margin-right:8px}.sir-ui-typedInput-faIcon{display:inline-flex;align-content:center;flex-wrap:wrap}.sir-typedInput-valueOptions a.optionEntry i.sir-ui-typedInput-faIcon{margin-right:13px}.red-ui-typedInput-options.sir-typedInput-valueOptions .red-ui-typedInput-icon.sir-ui-typedInput-svgIcon{margin-right:14px}button.svelte-r4tlf4:disabled{pointer-events:none}.optionEntry.svelte-r4tlf4{padding-left:12px}.optionEntryNoIcon.svelte-r4tlf4{padding-left:30px}.valueOptionEntryNoIcon.svelte-r4tlf4{padding-left:40px}.noDropCursor.svelte-r4tlf4{cursor:no-drop !important}.sir-typedInput.svelte-r4tlf4:focus-within{border-color:var(--red-ui-form-input-focus-color) !important}");
}

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[46] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[49] = list[i];
	return child_ctx;
}

// (417:0) {:else}
function create_else_block_1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: Neither property nor type property name given.";
			attr(span, "class", "maximize svelte-r4tlf4");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (415:19) 
function create_if_block_8(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: No property name given.";
			attr(span, "class", "maximize svelte-r4tlf4");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (413:15) 
function create_if_block_7(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: No type property name given.";
			attr(span, "class", "maximize svelte-r4tlf4");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (346:0) {#if !updateNode || (prop && typeProp)}
function create_if_block$5(ctx) {
	let t0;
	let div1;
	let button;
	let i;
	let t1;
	let span;
	let raw_value = /*getLabelAndIcon*/ ctx[17](/*selectedType*/ ctx[10]) + "";
	let button_id_value;
	let t2;
	let div0;
	let div0_id_value;
	let t3;
	let div1_id_value;
	let mounted;
	let dispose;

	function select_block_type_1(ctx, dirty) {
		if (/*label*/ ctx[0]) return create_if_block_4$1;
		if (/*indented*/ ctx[4]) return create_if_block_6;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block0 = current_block_type && current_block_type(ctx);
	let each_value_1 = Object.keys(/*typeSelections*/ ctx[11]);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let if_block1 = /*selectedType*/ ctx[10].hasValue !== false && create_if_block_1$2(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div1 = element("div");
			button = element("button");
			i = element("i");
			t1 = space();
			span = element("span");
			t2 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			if (if_block1) if_block1.c();
			attr(i, "class", "red-ui-typedInput-icon fa fa-caret-down");
			attr(span, "class", "red-ui-typedInput-type-label sir-ui-typedInput-type-label svelte-r4tlf4");
			attr(button, "id", button_id_value = "sir-TypedInput-Options-Button-" + /*id*/ ctx[6]);
			attr(button, "type", "button");
			attr(button, "class", "red-ui-typedInput-type-select svelte-r4tlf4");
			attr(button, "tabindex", "0");
			button.disabled = /*disabled*/ ctx[2];
			toggle_class(button, "maximize", /*selectedType*/ ctx[10].hasValue === false);
			attr(div0, "id", div0_id_value = "sir-TypedInput-Options-" + /*id*/ ctx[6]);
			attr(div0, "class", "red-ui-typedInput-options red-ui-editor-dialog sir-typedInput-options hide svelte-r4tlf4");
			attr(div0, "style", /*optionsStyle*/ ctx[12]);
			attr(div1, "id", div1_id_value = "sir-TypedInput-Container-" + /*id*/ ctx[6]);
			attr(div1, "class", "red-ui-typedInput-container sir-typedInput svelte-r4tlf4");
			toggle_class(div1, "input-error", /*internalValue*/ ctx[9].isError);
			toggle_class(div1, "maximize", /*maximize*/ ctx[5]);
			toggle_class(div1, "noDropCursor", /*disabled*/ ctx[2]);
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, div1, anchor);
			append(div1, button);
			append(button, i);
			append(button, t1);
			append(button, span);
			span.innerHTML = raw_value;
			append(div1, t2);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}

			append(div1, t3);
			if (if_block1) if_block1.m(div1, null);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_1*/ ctx[36]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			}

			if (dirty[0] & /*selectedType*/ 1024 && raw_value !== (raw_value = /*getLabelAndIcon*/ ctx[17](/*selectedType*/ ctx[10]) + "")) span.innerHTML = raw_value;
			if (dirty[0] & /*id*/ 64 && button_id_value !== (button_id_value = "sir-TypedInput-Options-Button-" + /*id*/ ctx[6])) {
				attr(button, "id", button_id_value);
			}

			if (dirty[0] & /*disabled*/ 4) {
				button.disabled = /*disabled*/ ctx[2];
			}

			if (dirty[0] & /*selectedType*/ 1024) {
				toggle_class(button, "maximize", /*selectedType*/ ctx[10].hasValue === false);
			}

			if (dirty[0] & /*typeSelections, handleLeftSideOptionChanged, getLabelAndIcon*/ 395264) {
				each_value_1 = Object.keys(/*typeSelections*/ ctx[11]);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (dirty[0] & /*id*/ 64 && div0_id_value !== (div0_id_value = "sir-TypedInput-Options-" + /*id*/ ctx[6])) {
				attr(div0, "id", div0_id_value);
			}

			if (dirty[0] & /*optionsStyle*/ 4096) {
				attr(div0, "style", /*optionsStyle*/ ctx[12]);
			}

			if (/*selectedType*/ ctx[10].hasValue !== false) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$2(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*id*/ 64 && div1_id_value !== (div1_id_value = "sir-TypedInput-Container-" + /*id*/ ctx[6])) {
				attr(div1, "id", div1_id_value);
			}

			if (dirty[0] & /*internalValue*/ 512) {
				toggle_class(div1, "input-error", /*internalValue*/ ctx[9].isError);
			}

			if (dirty[0] & /*maximize*/ 32) {
				toggle_class(div1, "maximize", /*maximize*/ ctx[5]);
			}

			if (dirty[0] & /*disabled*/ 4) {
				toggle_class(div1, "noDropCursor", /*disabled*/ ctx[2]);
			}
		},
		d(detaching) {
			if (if_block0) {
				if_block0.d(detaching);
			}

			if (detaching) detach(t0);
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

// (351:21) 
function create_if_block_6(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (347:2) {#if label}
function create_if_block_4$1(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_id_value;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[3] && create_if_block_5$1(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[0]);
			attr(label_1, "id", label_1_id_value = "sir-TypedInput-Label-" + /*id*/ ctx[6]);
			attr(label_1, "for", /*typedInputId*/ ctx[15]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler*/ ctx[34]),
					listen(label_1, "mouseleave", /*mouseleave_handler*/ ctx[35])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_5$1(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*label*/ 1) set_data(t1, /*label*/ ctx[0]);

			if (dirty[0] & /*id*/ 64 && label_1_id_value !== (label_1_id_value = "sir-TypedInput-Label-" + /*id*/ ctx[6])) {
				attr(label_1, "id", label_1_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (349:6) {#if icon}
function create_if_block_5$1(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[3] + " svelte-r4tlf4");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 8 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[3] + " svelte-r4tlf4")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (365:8) {#each Object.keys(typeSelections) as selection}
function create_each_block_1(ctx) {
	let a;
	let html_tag;
	let raw_value = /*getLabelAndIcon*/ ctx[17](/*typeSelections*/ ctx[11][/*selection*/ ctx[49]], true) + "";
	let t;
	let a_value_value;
	let mounted;
	let dispose;

	function click_handler_2() {
		return /*click_handler_2*/ ctx[37](/*selection*/ ctx[49]);
	}

	return {
		c() {
			a = element("a");
			html_tag = new HtmlTag(false);
			t = space();
			html_tag.a = t;
			attr(a, "href", "#");
			attr(a, "value", a_value_value = /*typeSelections*/ ctx[11][/*selection*/ ctx[49]].value);
			attr(a, "class", "optionEntry svelte-r4tlf4");
			toggle_class(a, "optionEntryNoIcon", !!Object.values(/*typeSelections*/ ctx[11]).find(func) && !/*typeSelections*/ ctx[11][/*selection*/ ctx[49]].icon);
		},
		m(target, anchor) {
			insert(target, a, anchor);
			html_tag.m(raw_value, a);
			append(a, t);

			if (!mounted) {
				dispose = [
					listen(a, "click", click_handler_2),
					listen(a, "blur", /*blur_handler*/ ctx[33])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*typeSelections*/ 2048 && raw_value !== (raw_value = /*getLabelAndIcon*/ ctx[17](/*typeSelections*/ ctx[11][/*selection*/ ctx[49]], true) + "")) html_tag.p(raw_value);

			if (dirty[0] & /*typeSelections*/ 2048 && a_value_value !== (a_value_value = /*typeSelections*/ ctx[11][/*selection*/ ctx[49]].value)) {
				attr(a, "value", a_value_value);
			}

			if (dirty[0] & /*typeSelections*/ 2048) {
				toggle_class(a, "optionEntryNoIcon", !!Object.values(/*typeSelections*/ ctx[11]).find(func) && !/*typeSelections*/ ctx[11][/*selection*/ ctx[49]].icon);
			}
		},
		d(detaching) {
			if (detaching) detach(a);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (375:4) {#if selectedType.hasValue !== false}
function create_if_block_1$2(ctx) {
	let t;
	let if_block1_anchor;

	function select_block_type_2(ctx, dirty) {
		if (/*selectedType*/ ctx[10].options?.length) return create_if_block_3$1;
		return create_else_block;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*selectedType*/ ctx[10].expand && create_if_block_2$2(ctx);

	return {
		c() {
			if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			}

			if (/*selectedType*/ ctx[10].expand) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$2(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if_block0.d(detaching);
			if (detaching) detach(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (397:6) {:else}
function create_else_block(ctx) {
	let div;
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			input = element("input");
			attr(input, "id", /*typedInputId*/ ctx[15]);
			attr(input, "class", "red-ui-typedInput-input");
			attr(input, "type", "text");
			set_style(input, "margin-right", "0px");
			set_style(input, "margin-left", "0px");
			input.disabled = /*disabled*/ ctx[2];
			attr(input, "placeholder", /*placeholder*/ ctx[1]);
			attr(div, "class", "red-ui-typedInput-input-wrap");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			set_input_value(input, /*internalValue*/ ctx[9].value);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[40]),
					listen(input, "click", /*click_handler*/ ctx[30]),
					listen(input, "focus", stop_propagation(prevent_default(/*focus_handler*/ ctx[31]))),
					listen(input, "blur", /*blur_handler_1*/ ctx[32])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 4) {
				input.disabled = /*disabled*/ ctx[2];
			}

			if (dirty[0] & /*placeholder*/ 2) {
				attr(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty[0] & /*internalValue*/ 512 && input.value !== /*internalValue*/ ctx[9].value) {
				set_input_value(input, /*internalValue*/ ctx[9].value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (377:6) {#if selectedType.options?.length}
function create_if_block_3$1(ctx) {
	let button;
	let span0;
	let t0;
	let span1;
	let button_id_value;
	let t1;
	let div;
	let div_id_value;
	let mounted;
	let dispose;
	let each_value = /*selectedType*/ ctx[10].options;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	return {
		c() {
			button = element("button");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			span1.innerHTML = `<i class="red-ui-typedInput-icon fa fa-caret-down"></i>`;
			t1 = space();
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(span0, "class", "red-ui-typedInput-option-label");
			attr(span1, "class", "red-ui-typedInput-option-caret");
			attr(button, "id", button_id_value = "sir-TypedInput-Value-Options-Button-" + /*id*/ ctx[6]);
			attr(button, "type", "button");
			attr(button, "tabindex", "0");
			attr(button, "class", "red-ui-typedInput-option-trigger svelte-r4tlf4");
			button.disabled = /*disabled*/ ctx[2];
			attr(div, "id", div_id_value = "sir-TypedInput-Value-Options-" + /*id*/ ctx[6]);
			attr(div, "class", "red-ui-typedInput-options red-ui-editor-dialog sir-typedInput-valueOptions hide svelte-r4tlf4");
			attr(div, "style", /*optionsStyle*/ ctx[12]);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, span0);
			span0.innerHTML = /*valueOptionsLabel*/ ctx[13];
			append(button, t0);
			append(button, span1);
			insert(target, t1, anchor);
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_3*/ ctx[38]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*valueOptionsLabel*/ 8192) span0.innerHTML = /*valueOptionsLabel*/ ctx[13];
			if (dirty[0] & /*id*/ 64 && button_id_value !== (button_id_value = "sir-TypedInput-Value-Options-Button-" + /*id*/ ctx[6])) {
				attr(button, "id", button_id_value);
			}

			if (dirty[0] & /*disabled*/ 4) {
				button.disabled = /*disabled*/ ctx[2];
			}

			if (dirty[0] & /*selectedType, internalValue, getLabelAndIcon*/ 132608) {
				each_value = /*selectedType*/ ctx[10].options;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty[0] & /*id*/ 64 && div_id_value !== (div_id_value = "sir-TypedInput-Value-Options-" + /*id*/ ctx[6])) {
				attr(div, "id", div_id_value);
			}

			if (dirty[0] & /*optionsStyle*/ 4096) {
				attr(div, "style", /*optionsStyle*/ ctx[12]);
			}
		},
		d(detaching) {
			if (detaching) detach(button);
			if (detaching) detach(t1);
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};
}

// (386:10) {#each selectedType.options as option}
function create_each_block$3(ctx) {
	let a;
	let html_tag;
	let raw_value = /*getLabelAndIcon*/ ctx[17](/*option*/ ctx[46], true) + "";
	let t;
	let a_value_value;
	let mounted;
	let dispose;

	function click_handler_4() {
		return /*click_handler_4*/ ctx[39](/*option*/ ctx[46]);
	}

	return {
		c() {
			a = element("a");
			html_tag = new HtmlTag(false);
			t = space();
			html_tag.a = t;
			attr(a, "href", "#");
			attr(a, "value", a_value_value = /*option*/ ctx[46].value);
			attr(a, "class", "optionEntry svelte-r4tlf4");
			toggle_class(a, "valueOptionEntryNoIcon", !!Object.values(/*selectedType*/ ctx[10].options).find(func_1) && !/*option*/ ctx[46].icon);
		},
		m(target, anchor) {
			insert(target, a, anchor);
			html_tag.m(raw_value, a);
			append(a, t);

			if (!mounted) {
				dispose = listen(a, "click", click_handler_4);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*selectedType*/ 1024 && raw_value !== (raw_value = /*getLabelAndIcon*/ ctx[17](/*option*/ ctx[46], true) + "")) html_tag.p(raw_value);

			if (dirty[0] & /*selectedType*/ 1024 && a_value_value !== (a_value_value = /*option*/ ctx[46].value)) {
				attr(a, "value", a_value_value);
			}

			if (dirty[0] & /*selectedType*/ 1024) {
				toggle_class(a, "valueOptionEntryNoIcon", !!Object.values(/*selectedType*/ ctx[10].options).find(func_1) && !/*option*/ ctx[46].icon);
			}
		},
		d(detaching) {
			if (detaching) detach(a);
			mounted = false;
			dispose();
		}
	};
}

// (406:6) {#if selectedType.expand}
function create_if_block_2$2(ctx) {
	let button;
	let i;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			i = element("i");
			attr(i, "class", "red-ui-typedInput-icon fa fa-ellipsis-h");
			attr(button, "type", "button");
			attr(button, "tabindex", "0");
			attr(button, "class", "red-ui-typedInput-option-expand svelte-r4tlf4");
			button.disabled = /*disabled*/ ctx[2];
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, i);

			if (!mounted) {
				dispose = listen(button, "click", prevent_default(/*click_handler_5*/ ctx[41]));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 4) {
				button.disabled = /*disabled*/ ctx[2];
			}
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$8(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (!/*updateNode*/ ctx[14] || /*prop*/ ctx[7] && /*typeProp*/ ctx[8]) return create_if_block$5;
		if (/*prop*/ ctx[7]) return create_if_block_7;
		if (/*typeProp*/ ctx[8]) return create_if_block_8;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

const func = s => s.icon;
const func_1 = s => s.icon;

function instance$8($$self, $$props, $$invalidate) {
	let typeSelections;
	let { disabled = false, error, i18n, icon, id, indented = false, label, maximize = true, node, placeholder, prop, tooltip, type, typeProp, types, value } = $$props;
	disabled = getBooleanFrom(disabled);
	indented = getBooleanFrom(indented);
	maximize = getBooleanFrom(maximize);
	let defaults = node?._def?.defaults || {};
	const dispatch = createEventDispatcher();
	const updateNode = typeof node !== 'undefined';
	const typedInputId = 'node-input-' + id;
	let internalValue = initInternal(defaults[prop], value);
	let internalType = initInternal(defaults[typeProp], type);

	if (label !== false) {
		label = label || defaults[prop] && defaults[prop].label || prop;
	}

	if (label) {
		label = i18nTranslate(RED, node, i18n, label);
	}

	types = types || defaults[typeProp]?.types;

	// do not export as we need access to internalValue for expand function 
	const createTypeSelections = types => {
		const selections = {};

		types.forEach(t => {
			switch (t) {
				case 'msg':
					selections[t] = {
						value: 'msg',
						label: 'msg.',
						validate: RED.utils.validatePropertyExpression
					};
					break;
				case 'flow':
					selections[t] = {
						value: 'flow',
						label: 'flow.',
						hasValue: true,
						options: [],
						validate: RED.utils.validatePropertyExpression
					};
					break;
				case 'global':
					selections[t] = {
						value: 'global',
						label: 'global.',
						hasValue: true,
						options: [],
						validate: RED.utils.validatePropertyExpression
					};
					break;
				case 'str':
					selections[t] = {
						value: 'str',
						label: 'string',
						icon: 'red/images/typedInput/az.svg'
					};
					break;
				case 'num':
					selections[t] = {
						value: 'num',
						label: 'number',
						icon: 'red/images/typedInput/09.svg',
						validate() {
							if ((/^[+-]?[0-9]*\.?[0-9]*([eE][-+]?[0-9]+)?$/).test(internalValue.value)) {
								return true;
							}
						}
					};
					break;
				case 'bool':
					selections[t] = {
						value: 'bool',
						label: 'boolean',
						icon: 'red/images/typedInput/bool.svg',
						options: [{ value: 'true', label: 'true' }, { value: 'false', label: 'false' }]
					};
					break;
				case 'json':
					selections[t] = {
						value: 'json',
						label: 'JSON',
						icon: 'red/images/typedInput/json.svg',
						validate(v) {
							try {
								JSON.parse(v);
								return true;
							} catch(e) {
								return false;
							}
						},
						expand() {
							try {
								$$invalidate(9, internalValue.value = JSON.stringify(JSON.parse(internalValue.value), null, 4), internalValue);
							} catch(err) {
								
							}

							RED.editor.editJSON({
								value: internalValue.value,
								stateId: RED.editor.generateViewStateId('typedInput', {}, 'json'),
								focus: true,
								complete(v) {
									let newValue = v;

									try {
										newValue = JSON.stringify(JSON.parse(v));
									} catch(err) {
										
									}

									$$invalidate(9, internalValue.value = newValue, internalValue);
								}
							});
						}
					};
					break;
				case 're':
					selections[t] = {
						value: 're',
						label: 'regular expression',
						icon: 'red/images/typedInput/re.svg'
					};
					break;
				case 'date':
					selections[t] = {
						value: 'date',
						label: 'timestamp',
						icon: 'fa-clock-o',
						hasValue: false
					};
					break;
				case 'jsonata':
					selections[t] = {
						value: 'jsonata',
						label: 'expression',
						icon: 'red/images/typedInput/expr.svg',
						validate(v) {
							try {
								jsonata(v);
								return true;
							} catch(e) {
								return false;
							}
						},
						expand() {
							RED.editor.editExpression({
								value: internalValue.value.replace(/\t/g, "\n"),
								stateId: RED.editor.generateViewStateId("typedInput", {}, "jsonata"),
								focus: true,
								complete(v) {
									$$invalidate(9, internalValue.value = v.replace(/\n/g, "\t"), internalValue);
								}
							});
						}
					};
					break;
				case 'bin':
					selections[t] = {
						value: 'bin',
						label: 'buffer',
						icon: 'red/images/typedInput/bin.svg',
						expand() {
							RED.editor.editBuffer({
								value: internalValue.value,
								stateId: RED.editor.generateViewStateId("typedInput", {}, "bin"),
								focus: true,
								complete(v) {
									$$invalidate(9, internalValue.value = v, internalValue);
								}
							});
						}
					};
					break;
				case 'env':
					selections[t] = {
						value: 'env',
						label: 'env variable',
						icon: 'red/images/typedInput/env.svg'
					};
					break;
				default:
					// Custom left option list
					if (typeof t === 'string') {
						selections[t] = { value: t, label: t };
					} else if (t.value) {
						selections[t.value] = {
							value: t.value,
							label: t.label || t.value || '',
							icon: t.icon || '',
							validate: t.validate || null,
							// options: t.options || null,
							hasValue: t.hasValue !== false
						};

						// Right option list
						if (Array.isArray(t.options)) {
							selections[t.value].options = t.options.map(option => {
								if (typeof option === 'string') {
									return { value: option, label: option };
								} else {
									return {
										value: option.value,
										label: option.label || option.value,
										icon: option.icon || ''
									};
								}
							});
						}
					} else {
						console.error('Invalid TypedInput type found: ' + t);

						RED.notify({
							type: 'error',
							text: 'Invalid TypedInput type found. Check console for more information.'
						});
					}
			}
		});

		return selections;
	};

	const toggleShowOptions = async side => {
		let optionId, optionValue;

		if (side === 'left') {
			optionId = 'sir-TypedInput-Options-' + id;
			optionValue = internalType.value;
		} else {
			optionId = 'sir-TypedInput-Value-Options-' + id;
			optionValue = internalValue.value;
		}

		await tick();

		// if current option menu is hidden, close others and open this one
		if (document.getElementById(optionId).classList.contains('hide')) {
			closeOptions();
			document.getElementById(optionId).classList.remove('hide');
			await tick();
			$$invalidate(12, optionsStyle = getOptionsPosition(side, id));

			// set focus on current selected type
			[...document.getElementById(optionId).children].find(e => e.getAttribute('value') === optionValue)?.focus();

			await addEventListenerCloseOptions();
		} else {
			// hide all menus (including other typedInput menus)
			closeOptions();
		}

		// closing tooltip doesn't work ._. we hide it via css, which will be removed when showing again
		// RED.popover.tooltip(window.$(idSanitizer('#sir-TypedInput-Options-Button-' + id))).close()
		[...document.querySelectorAll('.sir-NR-popover')].forEach(popover => popover.style.visibility = 'hidden');
	};

	const addEventListenerCloseOptions = () => {
		// tick is too short. The event will be triggered directly with toggle show options if there is no timeout
		setTimeout(
			() => {
				document.addEventListener('click', closeOptions);
				document.addEventListener('keydown', optionKeys);
			},
			200
		);
	};

	placeholder = placeholder || defaults[prop]?.placeholder || '';
	icon = icon || defaults?.[prop]?.icon || '';
	let optionsStyle = '';
	let valueOptionsLabel = '';

	// makes the html code more readable and prevents that delayed or missing / deleted types crashes the node
	let selectedType = {};

	// delay creation of tooltips as this needs jQuery and can be called often
	let init = true;

	let labelTooltipExists = false;
	let selectionTooltipExists;

	onMount(() => {
		setTimeout(() => $$invalidate(27, init = false), 1000);
		$$invalidate(9, internalValue = internalValue); // start reactive function to get the label after options are initiated
	});

	const getLabelAndIcon = (option, hasAlwaysLabel = false) => {
		let result = '';

		if (option?.icon) {
			if (option.icon.endsWith(".svg")) {
				result += `<i class="red-ui-typedInput-icon sir-ui-typedInput-svgIcon" style="mask-image: url(${option.icon}); -webkit-mask-image: url(${option.icon});"></i>`;
			} else {
				result += `<i class="red-ui-typedInput-icon sir-ui-typedInput-faIcon fa ${option.icon}"></i>`;
			}
		}

		if (hasAlwaysLabel || option.icon && option.hasValue === false || !option.icon) {
			result += option?.label || "Unknown";
		}

		return result;
	};

	const handleLeftSideOptionChanged = async selection => {
		$$invalidate(26, internalType.value = typeSelections[selection].value, internalType);
		(((((((((((($$invalidate(26, internalType), $$invalidate(19, node)), $$invalidate(7, prop)), $$invalidate(22, value)), $$invalidate(9, internalValue)), $$invalidate(42, defaults)), $$invalidate(23, error)), $$invalidate(8, typeProp)), $$invalidate(20, type)), $$invalidate(11, typeSelections)), $$invalidate(10, selectedType)), $$invalidate(6, id)), $$invalidate(21, types));
		await tick();
		const typedInputField = document.getElementById(typedInputId);

		if (typedInputField) {
			typedInputField.focus();
		}
	};

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler_1 = () => toggleShowOptions('left');
	const click_handler_2 = selection => handleLeftSideOptionChanged(selection);
	const click_handler_3 = () => toggleShowOptions('right');

	const click_handler_4 = option => {
		$$invalidate(9, internalValue.value = option.value, internalValue);
		(((((((((((($$invalidate(9, internalValue), $$invalidate(19, node)), $$invalidate(7, prop)), $$invalidate(22, value)), $$invalidate(42, defaults)), $$invalidate(23, error)), $$invalidate(8, typeProp)), $$invalidate(20, type)), $$invalidate(26, internalType)), $$invalidate(11, typeSelections)), $$invalidate(10, selectedType)), $$invalidate(6, id)), $$invalidate(21, types));
	};

	function input_input_handler() {
		internalValue.value = this.value;
		(((((((((((($$invalidate(9, internalValue), $$invalidate(19, node)), $$invalidate(7, prop)), $$invalidate(22, value)), $$invalidate(42, defaults)), $$invalidate(23, error)), $$invalidate(8, typeProp)), $$invalidate(20, type)), $$invalidate(26, internalType)), $$invalidate(11, typeSelections)), $$invalidate(10, selectedType)), $$invalidate(6, id)), $$invalidate(21, types));
	}

	const click_handler_5 = () => selectedType.expand();

	$$self.$$set = $$props => {
		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ('error' in $$props) $$invalidate(23, error = $$props.error);
		if ('i18n' in $$props) $$invalidate(24, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(6, id = $$props.id);
		if ('indented' in $$props) $$invalidate(4, indented = $$props.indented);
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(5, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(19, node = $$props.node);
		if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
		if ('prop' in $$props) $$invalidate(7, prop = $$props.prop);
		if ('tooltip' in $$props) $$invalidate(25, tooltip = $$props.tooltip);
		if ('type' in $$props) $$invalidate(20, type = $$props.type);
		if ('typeProp' in $$props) $$invalidate(8, typeProp = $$props.typeProp);
		if ('types' in $$props) $$invalidate(21, types = $$props.types);
		if ('value' in $$props) $$invalidate(22, value = $$props.value);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*init, tooltip, labelTooltipExists, id*/ 436207680) {
			{
				if (!init && tooltip || labelTooltipExists) {
					$$invalidate(28, labelTooltipExists = setTooltip(tooltip, labelTooltipExists, '#sir-TypedInput-Label-' + id));
				}
			}
		}

		if ($$self.$$.dirty[0] & /*types*/ 2097152) {
			$$invalidate(11, typeSelections = createTypeSelections(types));
		}

		if ($$self.$$.dirty[0] & /*node, prop, value, internalValue, error, typeProp, type, internalType, typeSelections, selectedType, id*/ 81268672) {
			{
				$$invalidate(9, internalValue = getNewInternal(node?.[prop], value, internalValue, defaults?.[prop]?.validate, error, node));
				$$invalidate(26, internalType = getNewInternal(node?.[typeProp], type, internalType, defaults?.[typeProp]?.validate, error, node));
				const valueHasChanged = internalValue.valueHasChanged || internalType.valueHasChanged;
				$$invalidate(10, selectedType = typeSelections[internalType.value] || {});

				// first error check was from defaults, if that was ok, check for specific value type errors
				if (!internalValue.isError && selectedType?.validate) {
					$$invalidate(9, internalValue.isError = !selectedType.validate(internalValue.value), internalValue);
				}

				if (internalValue.isError && updateNode) {
					$$invalidate(19, node.valid = false, node);
				}

				internalValue.updateNode
				? $$invalidate(19, node[prop] = internalValue.value, node)
				: $$invalidate(22, value = internalValue.value);

				internalType.updateNode
				? $$invalidate(19, node[typeProp] = internalType.value, node)
				: $$invalidate(20, type = internalType.value);

				if (!internalValue.init && !internalType.init && valueHasChanged) {
					dispatch(
						'change',
						{
							id,
							value: internalValue.value,
							type: internalType.value
						},
						{ cancelable: false }
					);
				}

				// Right side selectable option label
				if (selectedType?.options?.length) {
					const valueOptions = selectedType.options.find(o => o.value === internalValue.value);

					// unknown value for this type (left side changed or invalid default value) -> set to first value
					if (!valueOptions?.label) {
						$$invalidate(9, internalValue.value = selectedType.options[0]?.value || '', internalValue);
					} else {
						$$invalidate(13, valueOptionsLabel = getLabelAndIcon(valueOptions, true)); // const selectedValueOptions = selectedType.options.find(o => o.value === internalValue.value)?.label || 'Error: No value options found!'
					}
				}

				$$invalidate(9, internalValue.init = false, internalValue);
				$$invalidate(26, internalType.init = false, internalType);
			}
		}

		if ($$self.$$.dirty[0] & /*init, selectedType, selectionTooltipExists, id*/ 671089728) {
			{
				if (!init && selectedType.label || selectionTooltipExists) {
					$$invalidate(29, selectionTooltipExists = setTooltip(selectedType.label || 'Unknown', selectionTooltipExists, '#sir-TypedInput-Options-Button-' + id));
				}
			}
		}

		if ($$self.$$.dirty[0] & /*label, node, i18n*/ 17301505) {
			{
				if (label) {
					$$invalidate(0, label = i18nTranslate(RED, node, i18n, label));
				}
			}
		}

		if ($$self.$$.dirty[0] & /*placeholder, node, i18n*/ 17301506) {
			{
				if (placeholder) {
					$$invalidate(1, placeholder = i18nTranslate(RED, node, i18n, placeholder));
					const typedInputField = document.getElementById(typedInputId)?.parentNode.querySelector('.red-ui-typedInput-input');

					if (typedInputField) {
						typedInputField.setAttribute('placeholder', placeholder);
					}
				}
			}
		}
	};

	return [
		label,
		placeholder,
		disabled,
		icon,
		indented,
		maximize,
		id,
		prop,
		typeProp,
		internalValue,
		selectedType,
		typeSelections,
		optionsStyle,
		valueOptionsLabel,
		updateNode,
		typedInputId,
		toggleShowOptions,
		getLabelAndIcon,
		handleLeftSideOptionChanged,
		node,
		type,
		types,
		value,
		error,
		i18n,
		tooltip,
		internalType,
		init,
		labelTooltipExists,
		selectionTooltipExists,
		click_handler,
		focus_handler,
		blur_handler_1,
		blur_handler,
		mouseenter_handler,
		mouseleave_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		input_input_handler,
		click_handler_5
	];
}

class PlainTypedInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$8,
			create_fragment$8,
			safe_not_equal,
			{
				disabled: 2,
				error: 23,
				i18n: 24,
				icon: 3,
				id: 6,
				indented: 4,
				label: 0,
				maximize: 5,
				node: 19,
				placeholder: 1,
				prop: 7,
				tooltip: 25,
				type: 20,
				typeProp: 8,
				types: 21,
				value: 22
			},
			add_css$4,
			[-1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/TypedInput.svelte generated by Svelte v3.58.0 */

function add_css$3(target) {
	append_styles(target, "svelte-nc5mju", ".sir-TypedInput-Container.maximize{width:100%}.sir-TypedInput-Container{display:inline-flex;align-items:center}");
}

// (27:0) <Row id="sir-TypedInput-Container-{id}" {clazz} {inline} {fading} {style} >
function create_default_slot$6(ctx) {
	let plaintypedinput;
	let updating_node;
	let updating_prop;
	let updating_typeProp;
	let updating_value;
	let updating_type;
	let updating_types;
	let updating_label;
	let updating_disabled;
	let updating_tooltip;
	let current;

	function plaintypedinput_node_binding(value) {
		/*plaintypedinput_node_binding*/ ctx[20](value);
	}

	function plaintypedinput_prop_binding(value) {
		/*plaintypedinput_prop_binding*/ ctx[21](value);
	}

	function plaintypedinput_typeProp_binding(value) {
		/*plaintypedinput_typeProp_binding*/ ctx[22](value);
	}

	function plaintypedinput_value_binding(value) {
		/*plaintypedinput_value_binding*/ ctx[23](value);
	}

	function plaintypedinput_type_binding(value) {
		/*plaintypedinput_type_binding*/ ctx[24](value);
	}

	function plaintypedinput_types_binding(value) {
		/*plaintypedinput_types_binding*/ ctx[25](value);
	}

	function plaintypedinput_label_binding(value) {
		/*plaintypedinput_label_binding*/ ctx[26](value);
	}

	function plaintypedinput_disabled_binding(value) {
		/*plaintypedinput_disabled_binding*/ ctx[27](value);
	}

	function plaintypedinput_tooltip_binding(value) {
		/*plaintypedinput_tooltip_binding*/ ctx[28](value);
	}

	let plaintypedinput_props = {
		placeholder: /*placeholder*/ ctx[18],
		icon: /*icon*/ ctx[17],
		error: /*error*/ ctx[14],
		maximize: /*maximize*/ ctx[6],
		id: /*id*/ ctx[2],
		i18n: /*i18n*/ ctx[16],
		indented: /*indented*/ ctx[3]
	};

	if (/*node*/ ctx[7] !== void 0) {
		plaintypedinput_props.node = /*node*/ ctx[7];
	}

	if (/*prop*/ ctx[8] !== void 0) {
		plaintypedinput_props.prop = /*prop*/ ctx[8];
	}

	if (/*typeProp*/ ctx[11] !== void 0) {
		plaintypedinput_props.typeProp = /*typeProp*/ ctx[11];
	}

	if (/*value*/ ctx[13] !== void 0) {
		plaintypedinput_props.value = /*value*/ ctx[13];
	}

	if (/*type*/ ctx[10] !== void 0) {
		plaintypedinput_props.type = /*type*/ ctx[10];
	}

	if (/*types*/ ctx[12] !== void 0) {
		plaintypedinput_props.types = /*types*/ ctx[12];
	}

	if (/*label*/ ctx[5] !== void 0) {
		plaintypedinput_props.label = /*label*/ ctx[5];
	}

	if (/*disabled*/ ctx[1] !== void 0) {
		plaintypedinput_props.disabled = /*disabled*/ ctx[1];
	}

	if (/*tooltip*/ ctx[9] !== void 0) {
		plaintypedinput_props.tooltip = /*tooltip*/ ctx[9];
	}

	plaintypedinput = new PlainTypedInput({ props: plaintypedinput_props });
	binding_callbacks.push(() => bind(plaintypedinput, 'node', plaintypedinput_node_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'prop', plaintypedinput_prop_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'typeProp', plaintypedinput_typeProp_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'value', plaintypedinput_value_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'type', plaintypedinput_type_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'types', plaintypedinput_types_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'label', plaintypedinput_label_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'disabled', plaintypedinput_disabled_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'tooltip', plaintypedinput_tooltip_binding));
	plaintypedinput.$on("click", /*click_handler*/ ctx[29]);
	plaintypedinput.$on("change", /*change_handler*/ ctx[30]);
	plaintypedinput.$on("mouseenter", /*mouseenter_handler*/ ctx[31]);
	plaintypedinput.$on("mouseleave", /*mouseleave_handler*/ ctx[32]);
	plaintypedinput.$on("click", /*click_handler_1*/ ctx[33]);
	plaintypedinput.$on("focus", /*focus_handler*/ ctx[34]);
	plaintypedinput.$on("blur", /*blur_handler*/ ctx[35]);

	return {
		c() {
			create_component(plaintypedinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(plaintypedinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const plaintypedinput_changes = {};
			if (dirty[0] & /*placeholder*/ 262144) plaintypedinput_changes.placeholder = /*placeholder*/ ctx[18];
			if (dirty[0] & /*icon*/ 131072) plaintypedinput_changes.icon = /*icon*/ ctx[17];
			if (dirty[0] & /*error*/ 16384) plaintypedinput_changes.error = /*error*/ ctx[14];
			if (dirty[0] & /*maximize*/ 64) plaintypedinput_changes.maximize = /*maximize*/ ctx[6];
			if (dirty[0] & /*id*/ 4) plaintypedinput_changes.id = /*id*/ ctx[2];
			if (dirty[0] & /*i18n*/ 65536) plaintypedinput_changes.i18n = /*i18n*/ ctx[16];
			if (dirty[0] & /*indented*/ 8) plaintypedinput_changes.indented = /*indented*/ ctx[3];

			if (!updating_node && dirty[0] & /*node*/ 128) {
				updating_node = true;
				plaintypedinput_changes.node = /*node*/ ctx[7];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty[0] & /*prop*/ 256) {
				updating_prop = true;
				plaintypedinput_changes.prop = /*prop*/ ctx[8];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_typeProp && dirty[0] & /*typeProp*/ 2048) {
				updating_typeProp = true;
				plaintypedinput_changes.typeProp = /*typeProp*/ ctx[11];
				add_flush_callback(() => updating_typeProp = false);
			}

			if (!updating_value && dirty[0] & /*value*/ 8192) {
				updating_value = true;
				plaintypedinput_changes.value = /*value*/ ctx[13];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_type && dirty[0] & /*type*/ 1024) {
				updating_type = true;
				plaintypedinput_changes.type = /*type*/ ctx[10];
				add_flush_callback(() => updating_type = false);
			}

			if (!updating_types && dirty[0] & /*types*/ 4096) {
				updating_types = true;
				plaintypedinput_changes.types = /*types*/ ctx[12];
				add_flush_callback(() => updating_types = false);
			}

			if (!updating_label && dirty[0] & /*label*/ 32) {
				updating_label = true;
				plaintypedinput_changes.label = /*label*/ ctx[5];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty[0] & /*disabled*/ 2) {
				updating_disabled = true;
				plaintypedinput_changes.disabled = /*disabled*/ ctx[1];
				add_flush_callback(() => updating_disabled = false);
			}

			if (!updating_tooltip && dirty[0] & /*tooltip*/ 512) {
				updating_tooltip = true;
				plaintypedinput_changes.tooltip = /*tooltip*/ ctx[9];
				add_flush_callback(() => updating_tooltip = false);
			}

			plaintypedinput.$set(plaintypedinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(plaintypedinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(plaintypedinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(plaintypedinput, detaching);
		}
	};
}

function create_fragment$7(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-TypedInput-Container-" + /*id*/ ctx[2],
				clazz: /*clazz*/ ctx[0],
				inline: /*inline*/ ctx[4],
				fading: /*fading*/ ctx[15],
				style: /*style*/ ctx[19],
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty[0] & /*id*/ 4) row_changes.id = "sir-TypedInput-Container-" + /*id*/ ctx[2];
			if (dirty[0] & /*clazz*/ 1) row_changes.clazz = /*clazz*/ ctx[0];
			if (dirty[0] & /*inline*/ 16) row_changes.inline = /*inline*/ ctx[4];
			if (dirty[0] & /*fading*/ 32768) row_changes.fading = /*fading*/ ctx[15];
			if (dirty[0] & /*style*/ 524288) row_changes.style = /*style*/ ctx[19];

			if (dirty[0] & /*placeholder, icon, error, maximize, id, i18n, indented, node, prop, typeProp, value, type, types, label, disabled, tooltip*/ 491502 | dirty[1] & /*$$scope*/ 32) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let { clazz = '', disabled = false, error = false, fading = true, i18n, icon, id, indented = false, inline = false, label, maximize = true, node, placeholder, prop, style = '', tooltip, type, typeProp, types, value } = $$props;
	id = id || getId(prop);
	inline = getBooleanFrom(inline);
	disabled = getBooleanFrom(disabled);
	indented = getBooleanFrom(indented);
	maximize = getBooleanFrom(maximize);
	clazz += ` sir-TypedInput-Container ${maximize ? ' maximize' : ''}`;

	function plaintypedinput_node_binding(value) {
		node = value;
		$$invalidate(7, node);
	}

	function plaintypedinput_prop_binding(value) {
		prop = value;
		$$invalidate(8, prop);
	}

	function plaintypedinput_typeProp_binding(value) {
		typeProp = value;
		$$invalidate(11, typeProp);
	}

	function plaintypedinput_value_binding(value$1) {
		value = value$1;
		$$invalidate(13, value);
	}

	function plaintypedinput_type_binding(value) {
		type = value;
		$$invalidate(10, type);
	}

	function plaintypedinput_types_binding(value) {
		types = value;
		$$invalidate(12, types);
	}

	function plaintypedinput_label_binding(value) {
		label = value;
		$$invalidate(5, label);
	}

	function plaintypedinput_disabled_binding(value) {
		disabled = value;
		$$invalidate(1, disabled);
	}

	function plaintypedinput_tooltip_binding(value) {
		tooltip = value;
		$$invalidate(9, tooltip);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(0, clazz = $$props.clazz);
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('error' in $$props) $$invalidate(14, error = $$props.error);
		if ('fading' in $$props) $$invalidate(15, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(16, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(17, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(2, id = $$props.id);
		if ('indented' in $$props) $$invalidate(3, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(4, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(5, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(6, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(7, node = $$props.node);
		if ('placeholder' in $$props) $$invalidate(18, placeholder = $$props.placeholder);
		if ('prop' in $$props) $$invalidate(8, prop = $$props.prop);
		if ('style' in $$props) $$invalidate(19, style = $$props.style);
		if ('tooltip' in $$props) $$invalidate(9, tooltip = $$props.tooltip);
		if ('type' in $$props) $$invalidate(10, type = $$props.type);
		if ('typeProp' in $$props) $$invalidate(11, typeProp = $$props.typeProp);
		if ('types' in $$props) $$invalidate(12, types = $$props.types);
		if ('value' in $$props) $$invalidate(13, value = $$props.value);
	};

	return [
		clazz,
		disabled,
		id,
		indented,
		inline,
		label,
		maximize,
		node,
		prop,
		tooltip,
		type,
		typeProp,
		types,
		value,
		error,
		fading,
		i18n,
		icon,
		placeholder,
		style,
		plaintypedinput_node_binding,
		plaintypedinput_prop_binding,
		plaintypedinput_typeProp_binding,
		plaintypedinput_value_binding,
		plaintypedinput_type_binding,
		plaintypedinput_types_binding,
		plaintypedinput_label_binding,
		plaintypedinput_disabled_binding,
		plaintypedinput_tooltip_binding,
		click_handler,
		change_handler,
		mouseenter_handler,
		mouseleave_handler,
		click_handler_1,
		focus_handler,
		blur_handler
	];
}

class TypedInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$7,
			create_fragment$7,
			safe_not_equal,
			{
				clazz: 0,
				disabled: 1,
				error: 14,
				fading: 15,
				i18n: 16,
				icon: 17,
				id: 2,
				indented: 3,
				inline: 4,
				label: 5,
				maximize: 6,
				node: 7,
				placeholder: 18,
				prop: 8,
				style: 19,
				tooltip: 9,
				type: 10,
				typeProp: 11,
				types: 12,
				value: 13
			},
			add_css$3,
			[-1, -1]
		);
	}
}

var translations = {
  'en-US': {
    
    'about.oauth2': 'This node enables authentication using the OAuth2 protocol by obtaining an access token, which allows for authenticated API requests.',
    'standard.label': 'standard',
    
    'general.title': 'General',
    'general.name': 'Name',
    'general.password': 'Password',
    'general.container': 'Container',
    'general.errorHandling': 'Error Handling',
    'general.language': 'Language',

    'credentials.grantType': 'Grant Types',
    'credentials.title': 'Credentials',
    'credentials.clientId': 'Client Id',
    'credentials.clientSecret': 'Client Secret',
    'credentials.userName': 'User Name',
    'credentials.password': 'Password',
    'credentials.scope': 'Scope',
    'credentials.code': 'Code',
    'credentials.accessTokenUrl': 'Access Token URL',
    'credentials.authorizationEndpoint': 'Authorization Endpoint',
    "credentials.tooltip.clientCredentials": "To use the client credentials grant type,\nenter the access token URL, client ID, client secret, and scope.",
    'credentials.proxy': 'Proxy',
    'credentials.settings': 'Proxy Settings',
    'credentials.Headers': 'Headers',
    'credentials.Headers.Parameters': 'Parameters',


    'label.settings': 'Settings',
    'label.rejectUnauthorized': 'Reject Unauthorized',
    'label.clientCredentialsInBody': 'Embedded Credentials',
    'label.disableInput': 'Disable Input',
    'label.headers': 'Headers',
    'placeholder.name': 'Here could stand your individual node name. E.g. OAuth2',
    'placeholder.container': 'oauth2Response',
    'placeholder.accessTokenUrl': 'Access Token URL',
    'placeholder.clientId': 'Client Id',
    'placeholder.clientSecret': 'Client Secret',
    'placeholder.scope': 'Scope',
    'placeholder.userName': 'User Name',
    'placeholder.password': 'Password',
    'placeholder.authorizationEndpoint': 'Authorization Endpoint',
    'placeholder.code': 'Code',
    'tooltip.settings': 'Here could stand your individual node name. E.g. OAuth2',
    'tooltip.proxy': 'This is a group. It has 2 input fields grouped.\n\nThose fields like it very much to be grouped as they feel really close to each other.'    
  },
  'pt-BR': {
    'standard.label': 'padrão',
    'about.oauth2': 'Este nó habilita a autenticação usando o protocolo OAuth2 obtendo um token de acesso, que permite solicitações de API autenticadas.',
    
    'general.title': 'Geral',
    'general.name': 'Nome',
    'general.container': 'Container',
    'general.errorHandling': 'Tratamento de Erro',
    'general.language': 'Idioma',

    'credentials.grantType': 'Tipos de Concessão',
    'credentials.title': 'Credenciais',
    'credentials.clientId': 'ID do Cliente',
    'credentials.clientSecret': 'Segredo do Cliente',
    'credentials.userName': 'Nome de Usuário',
    'credentials.password': 'Senha',
    'credentials.scope': 'Escopo',
    'credentials.code': 'Código',
    'credentials.accessTokenUrl': 'URL do token de acesso',
    'credentials.authorizationEndpoint': 'Ponto de Autorização',
    "credentials.tooltip.clientCredentials": "Para usar o tipo de concessão de credenciais do cliente,\ninforme a URL do token de acesso, o ID do cliente, o segredo do cliente e o escopo.",    
    'credentials.proxy': 'Proxy',
    'credentials.settings': 'Configurações do Proxy',

    'credentials.Headers': 'Cabeçalhos',
    'credentials.Headers.Parameters': 'Parâmetros',

    'label.settings': 'Configurações',
    'label.rejectUnauthorized': 'Rejeitar Não Autorizado',
    'label.clientCredentialsInBody': 'Credenciais Incorporadas',
    'label.disableInput': 'Desativar Entrada',
    'label.accessTokenUrl': 'URL do Token de Acesso',
    'label.headers': 'Cabeçalhos',
    'placeholder.name': 'Aqui pode ser o nome do seu nó individual. Por exemplo, OAuth2',
    'placeholder.container': 'oauth2Response',
    'placeholder.accessTokenUrl': 'URL do Token de Acesso',
    'placeholder.clientId': 'ID do Cliente',
    'placeholder.clientSecret': 'Segredo do Cliente',
    'placeholder.scope': 'Escopo',
    'placeholder.userName': 'Nome de Usuário',
    'placeholder.password': 'Senha',
    'placeholder.authorizationEndpoint': 'Ponto de Autorização',
    'placeholder.code': 'Código',
    'tooltip.settings': 'Here could stand your individual node name. E.g. OAuth2',
    'tooltip.proxy': 'Este é um grupo. Ele possui 2 campos de entrada agrupados.\n\nEsses campos gostam muito de ser agrupados, pois se sentem realmente próximos um do outro.'
  },
};

const locale = writable("en-US");
const locales = Object.keys(translations);

function translate(locale, key, vars) {
  // Let's throw some errors if we're trying to use keys/locales that don't exist.
  // We could improve this by using Typescript and/or fallback values.
  if (!key) throw new Error("no key provided to $t()");
  if (!locale) throw new Error(`no translation for key "${key}"`);

  // Grab the translation from the translations object.
  let text = translations[locale][key];

  if (!text) throw new Error(`no translation found for ${locale}.${key}`);

  // Replace any passed in variables in the translation string.
  Object.keys(vars).map((k) => {
    const regex = new RegExp(`{{${k}}}`, "g");
    text = text.replace(regex, vars[k]);
  });

  return text;
}

const _ = derived(locale, ($locale) => (key, vars = {}) =>
  translate($locale, key, vars)
);

/* src/components/Advanced.svelte generated by Svelte v3.58.0 */

function add_css$2(target) {
	append_styles(target, "svelte-1eoffyz", ".select.svelte-1eoffyz{border:1px solid #ddd;border-radius:4px;padding:6px 10px 6px 4px}.block.svelte-1eoffyz{display:block;justify-content:space-between;margin-right:6px}");
}

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (24:4) {#each locales as l}
function create_each_block$2(ctx) {
	let option;
	let t_value = /*l*/ ctx[11] + "";
	let t;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = /*l*/ ctx[11];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (19:1) <Row>
function create_default_slot_10$1(ctx) {
	let label;
	let span;
	let t0_value = /*$_*/ ctx[1]("general.language") + "";
	let t0;
	let t1;
	let select;
	let select_disabled_value;
	let mounted;
	let dispose;
	let each_value = locales;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	return {
		c() {
			label = element("label");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(span, "class", "block svelte-1eoffyz");
			attr(select, "class", "block select svelte-1eoffyz");
			attr(select, "icon", "warning");
			select.disabled = select_disabled_value = /*node*/ ctx[0].disableInput;
			if (/*$locale*/ ctx[2] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[3].call(select));
			attr(label, "class", "block svelte-1eoffyz");
		},
		m(target, anchor) {
			insert(target, label, anchor);
			append(label, span);
			append(span, t0);
			append(label, t1);
			append(label, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(select, null);
				}
			}

			select_option(select, /*$locale*/ ctx[2], true);

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[3]),
					listen(select, "change", /*change_handler*/ ctx[4])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]("general.language") + "")) set_data(t0, t0_value);

			if (dirty & /*locales*/ 0) {
				each_value = locales;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*node*/ 1 && select_disabled_value !== (select_disabled_value = /*node*/ ctx[0].disableInput)) {
				select.disabled = select_disabled_value;
			}

			if (dirty & /*$locale, locales*/ 4) {
				select_option(select, /*$locale*/ ctx[2]);
			}
		},
		d(detaching) {
			if (detaching) detach(label);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (18:0) <Group slot="header" clazz="paddingBottom" style="justify-content: space-between; margin-right: 6px;">
function create_default_slot_9$1(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_10$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};

			if (dirty & /*$$scope, node, $locale, $_*/ 16391) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

// (34:2) {#if node.clientCredentialsInBody}
function create_if_block_5(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "info",
				small: true,
				$$slots: { default: [create_default_slot_8$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (35:3) <Callout type="info" small>
function create_default_slot_8$2(ctx) {
	let t;

	return {
		c() {
			t = text("Ensure that the client credentials are included in the token request body for authentication\n\t\t\t\tpurposes.");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (41:2) {#if node.rejectUnauthorized}
function create_if_block_4(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "info",
				small: true,
				$$slots: { default: [create_default_slot_7$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (42:3) <Callout type="info" small>
function create_default_slot_7$2(ctx) {
	let t0;
	let b;
	let t2;

	return {
		c() {
			t0 = text("The ");
			b = element("b");
			b.textContent = "rejectUnauthorized";
			t2 = text(" parameter controls SSL/TLS certificate validation for the server,\n\t\t\t\twith true enforcing validation and false disabling it.");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, b, anchor);
			insert(target, t2, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(b);
			if (detaching) detach(t2);
		}
	};
}

// (48:2) {#if node.keepAuth}
function create_if_block_3(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "info",
				small: true,
				$$slots: { default: [create_default_slot_6$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (49:3) <Callout type="info" small>
function create_default_slot_6$2(ctx) {
	let t;

	return {
		c() {
			t = text("msg.openApiToken and msg.headers will not be deleted and can be seen by other nodes in the\n\t\t\t\tflow.");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (32:1) <Collapsible label="Request" indented={false}>
function create_default_slot_5$2(ctx) {
	let input0;
	let updating_node;
	let t0;
	let t1;
	let input1;
	let updating_node_1;
	let t2;
	let t3;
	let input2;
	let updating_node_2;
	let t4;
	let if_block2_anchor;
	let current;

	function input0_node_binding(value) {
		/*input0_node_binding*/ ctx[5](value);
	}

	let input0_props = {
		prop: "clientCredentialsInBody",
		labelBeforeCheckbox: true
	};

	if (/*node*/ ctx[0] !== void 0) {
		input0_props.node = /*node*/ ctx[0];
	}

	input0 = new Input({ props: input0_props });
	binding_callbacks.push(() => bind(input0, 'node', input0_node_binding));
	let if_block0 = /*node*/ ctx[0].clientCredentialsInBody && create_if_block_5(ctx);

	function input1_node_binding(value) {
		/*input1_node_binding*/ ctx[6](value);
	}

	let input1_props = {
		prop: "rejectUnauthorized",
		labelBeforeCheckbox: true
	};

	if (/*node*/ ctx[0] !== void 0) {
		input1_props.node = /*node*/ ctx[0];
	}

	input1 = new Input({ props: input1_props });
	binding_callbacks.push(() => bind(input1, 'node', input1_node_binding));
	let if_block1 = /*node*/ ctx[0].rejectUnauthorized && create_if_block_4(ctx);

	function input2_node_binding(value) {
		/*input2_node_binding*/ ctx[7](value);
	}

	let input2_props = {
		prop: "keepAuth",
		labelBeforeCheckbox: true
	};

	if (/*node*/ ctx[0] !== void 0) {
		input2_props.node = /*node*/ ctx[0];
	}

	input2 = new Input({ props: input2_props });
	binding_callbacks.push(() => bind(input2, 'node', input2_node_binding));
	let if_block2 = /*node*/ ctx[0].keepAuth && create_if_block_3(ctx);

	return {
		c() {
			create_component(input0.$$.fragment);
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			create_component(input1.$$.fragment);
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			create_component(input2.$$.fragment);
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		m(target, anchor) {
			mount_component(input0, target, anchor);
			insert(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t1, anchor);
			mount_component(input1, target, anchor);
			insert(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t3, anchor);
			mount_component(input2, target, anchor);
			insert(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input0_changes = {};

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				input0_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input0.$set(input0_changes);

			if (/*node*/ ctx[0].clientCredentialsInBody) {
				if (if_block0) {
					if (dirty & /*node*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const input1_changes = {};

			if (!updating_node_1 && dirty & /*node*/ 1) {
				updating_node_1 = true;
				input1_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			input1.$set(input1_changes);

			if (/*node*/ ctx[0].rejectUnauthorized) {
				if (if_block1) {
					if (dirty & /*node*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_4(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const input2_changes = {};

			if (!updating_node_2 && dirty & /*node*/ 1) {
				updating_node_2 = true;
				input2_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_2 = false);
			}

			input2.$set(input2_changes);

			if (/*node*/ ctx[0].keepAuth) {
				if (if_block2) {
					if (dirty & /*node*/ 1) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_3(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(input0.$$.fragment, local);
			transition_in(if_block0);
			transition_in(input1.$$.fragment, local);
			transition_in(if_block1);
			transition_in(input2.$$.fragment, local);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(input0.$$.fragment, local);
			transition_out(if_block0);
			transition_out(input1.$$.fragment, local);
			transition_out(if_block1);
			transition_out(input2.$$.fragment, local);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			destroy_component(input0, detaching);
			if (detaching) detach(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t1);
			destroy_component(input1, detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t3);
			destroy_component(input2, detaching);
			if (detaching) detach(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(if_block2_anchor);
		}
	};
}

// (31:0) <Group clazz="paddingAdvanced">
function create_default_slot_4$2(ctx) {
	let collapsible;
	let current;

	collapsible = new Collapsible({
			props: {
				label: "Request",
				indented: false,
				$$slots: { default: [create_default_slot_5$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(collapsible.$$.fragment);
		},
		m(target, anchor) {
			mount_component(collapsible, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const collapsible_changes = {};

			if (dirty & /*$$scope, node*/ 16385) {
				collapsible_changes.$$scope = { dirty, ctx };
			}

			collapsible.$set(collapsible_changes);
		},
		i(local) {
			if (current) return;
			transition_in(collapsible.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(collapsible.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(collapsible, detaching);
		}
	};
}

// (59:1) {#if node.devMode}
function create_if_block_2$1(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "warning",
				$$slots: {
					header: [create_header_slot$1],
					default: [create_default_slot_3$2]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (60:2) <Callout type="warning">
function create_default_slot_3$2(ctx) {
	let p0;
	let t1;
	let p1;

	return {
		c() {
			p0 = element("p");
			p0.textContent = "Dev mode is experimental!";
			t1 = space();
			p1 = element("p");
			p1.textContent = "Allows to make otherwise rejected calls like when using self signed or expired certificates.";
		},
		m(target, anchor) {
			insert(target, p0, anchor);
			insert(target, t1, anchor);
			insert(target, p1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(p0);
			if (detaching) detach(t1);
			if (detaching) detach(p1);
		}
	};
}

// (61:3) 
function create_header_slot$1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Warning!";
			attr(span, "slot", "header");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (69:1) {#if node.showBanner}
function create_if_block_1$1(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "info",
				small: true,
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (70:2) <Callout type="info" small>
function create_default_slot_2$3(ctx) {
	let t0;
	let b;
	let t2;

	return {
		c() {
			t0 = text("Display the ");
			b = element("b");
			b.textContent = "Getnet Digital Platform API";
			t2 = text(" banner on the general tab.");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, b, anchor);
			insert(target, t2, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(b);
			if (detaching) detach(t2);
		}
	};
}

// (75:1) {#if node.disableInput}
function create_if_block$4(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "info",
				small: true,
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (76:2) <Callout type="info" small>
function create_default_slot_1$4(ctx) {
	let t;

	return {
		c() {
			t = text("Disable Input.");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (57:0) <Collapsible label="Options" indented={false}>
function create_default_slot$5(ctx) {
	let input0;
	let updating_node;
	let t0;
	let t1;
	let input1;
	let updating_node_1;
	let t2;
	let t3;
	let input2;
	let updating_node_2;
	let t4;
	let if_block2_anchor;
	let current;

	function input0_node_binding_1(value) {
		/*input0_node_binding_1*/ ctx[8](value);
	}

	let input0_props = {
		prop: "devMode",
		labelBeforeCheckbox: true
	};

	if (/*node*/ ctx[0] !== void 0) {
		input0_props.node = /*node*/ ctx[0];
	}

	input0 = new Input({ props: input0_props });
	binding_callbacks.push(() => bind(input0, 'node', input0_node_binding_1));
	let if_block0 = /*node*/ ctx[0].devMode && create_if_block_2$1(ctx);

	function input1_node_binding_1(value) {
		/*input1_node_binding_1*/ ctx[9](value);
	}

	let input1_props = {
		prop: "showBanner",
		labelBeforeCheckbox: true
	};

	if (/*node*/ ctx[0] !== void 0) {
		input1_props.node = /*node*/ ctx[0];
	}

	input1 = new Input({ props: input1_props });
	binding_callbacks.push(() => bind(input1, 'node', input1_node_binding_1));
	let if_block1 = /*node*/ ctx[0].showBanner && create_if_block_1$1(ctx);

	function input2_node_binding_1(value) {
		/*input2_node_binding_1*/ ctx[10](value);
	}

	let input2_props = {
		prop: "disableInput",
		labelBeforeCheckbox: true
	};

	if (/*node*/ ctx[0] !== void 0) {
		input2_props.node = /*node*/ ctx[0];
	}

	input2 = new Input({ props: input2_props });
	binding_callbacks.push(() => bind(input2, 'node', input2_node_binding_1));
	let if_block2 = /*node*/ ctx[0].disableInput && create_if_block$4(ctx);

	return {
		c() {
			create_component(input0.$$.fragment);
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			create_component(input1.$$.fragment);
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			create_component(input2.$$.fragment);
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		m(target, anchor) {
			mount_component(input0, target, anchor);
			insert(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t1, anchor);
			mount_component(input1, target, anchor);
			insert(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t3, anchor);
			mount_component(input2, target, anchor);
			insert(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input0_changes = {};

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				input0_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input0.$set(input0_changes);

			if (/*node*/ ctx[0].devMode) {
				if (if_block0) {
					if (dirty & /*node*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const input1_changes = {};

			if (!updating_node_1 && dirty & /*node*/ 1) {
				updating_node_1 = true;
				input1_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			input1.$set(input1_changes);

			if (/*node*/ ctx[0].showBanner) {
				if (if_block1) {
					if (dirty & /*node*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const input2_changes = {};

			if (!updating_node_2 && dirty & /*node*/ 1) {
				updating_node_2 = true;
				input2_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_2 = false);
			}

			input2.$set(input2_changes);

			if (/*node*/ ctx[0].disableInput) {
				if (if_block2) {
					if (dirty & /*node*/ 1) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$4(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(input0.$$.fragment, local);
			transition_in(if_block0);
			transition_in(input1.$$.fragment, local);
			transition_in(if_block1);
			transition_in(input2.$$.fragment, local);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(input0.$$.fragment, local);
			transition_out(if_block0);
			transition_out(input1.$$.fragment, local);
			transition_out(if_block1);
			transition_out(input2.$$.fragment, local);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			destroy_component(input0, detaching);
			if (detaching) detach(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t1);
			destroy_component(input1, detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t3);
			destroy_component(input2, detaching);
			if (detaching) detach(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(if_block2_anchor);
		}
	};
}

function create_fragment$6(ctx) {
	let group0;
	let t0;
	let group1;
	let t1;
	let collapsible;
	let current;

	group0 = new Group({
			props: {
				slot: "header",
				clazz: "paddingBottom",
				style: "justify-content: space-between; margin-right: 6px;",
				$$slots: { default: [create_default_slot_9$1] },
				$$scope: { ctx }
			}
		});

	group1 = new Group({
			props: {
				clazz: "paddingAdvanced",
				$$slots: { default: [create_default_slot_4$2] },
				$$scope: { ctx }
			}
		});

	collapsible = new Collapsible({
			props: {
				label: "Options",
				indented: false,
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(group0.$$.fragment);
			t0 = space();
			create_component(group1.$$.fragment);
			t1 = space();
			create_component(collapsible.$$.fragment);
		},
		m(target, anchor) {
			mount_component(group0, target, anchor);
			insert(target, t0, anchor);
			mount_component(group1, target, anchor);
			insert(target, t1, anchor);
			mount_component(collapsible, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const group0_changes = {};

			if (dirty & /*$$scope, node, $locale, $_*/ 16391) {
				group0_changes.$$scope = { dirty, ctx };
			}

			group0.$set(group0_changes);
			const group1_changes = {};

			if (dirty & /*$$scope, node*/ 16385) {
				group1_changes.$$scope = { dirty, ctx };
			}

			group1.$set(group1_changes);
			const collapsible_changes = {};

			if (dirty & /*$$scope, node*/ 16385) {
				collapsible_changes.$$scope = { dirty, ctx };
			}

			collapsible.$set(collapsible_changes);
		},
		i(local) {
			if (current) return;
			transition_in(group0.$$.fragment, local);
			transition_in(group1.$$.fragment, local);
			transition_in(collapsible.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(group0.$$.fragment, local);
			transition_out(group1.$$.fragment, local);
			transition_out(collapsible.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(group0, detaching);
			if (detaching) detach(t0);
			destroy_component(group1, detaching);
			if (detaching) detach(t1);
			destroy_component(collapsible, detaching);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let $_;
	let $locale;
	component_subscribe($$self, _, $$value => $$invalidate(1, $_ = $$value));
	component_subscribe($$self, locale, $$value => $$invalidate(2, $locale = $$value));
	let { node } = $$props;

	onMount(() => {
		locale.set(node.language);
	});

	function select_change_handler() {
		$locale = select_value(this);
		locale.set($locale);
	}

	const change_handler = event => $$invalidate(0, node.language = event.target.value, node);

	function input0_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input1_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input2_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input0_node_binding_1(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input1_node_binding_1(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input2_node_binding_1(value) {
		node = value;
		$$invalidate(0, node);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
	};

	return [
		node,
		$_,
		$locale,
		select_change_handler,
		change_handler,
		input0_node_binding,
		input1_node_binding,
		input2_node_binding,
		input0_node_binding_1,
		input1_node_binding_1,
		input2_node_binding_1
	];
}

class Advanced extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { node: 0 }, add_css$2);
	}
}

/* src/components/General.svelte generated by Svelte v3.58.0 */

function add_css$1(target) {
	append_styles(target, "svelte-jgw5as", ".flex.svelte-jgw5as{display:flex;flex-direction:row;align-items:center;gap:1rem;padding:1rem;border:1px solid #ccc;background-color:#ffe;border-radius:8px;max-width:500px;margin:auto}");
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

// (43:0) {#if node.showBanner}
function create_if_block$3(ctx) {
	let button;
	let t0;
	let br0;
	let t1;
	let div1;
	let div0;
	let p0;
	let t2;
	let p1;
	let t3_value = /*$_*/ ctx[2]('about.oauth2') + "";
	let t3;
	let t4;
	let p2;
	let t6;
	let br1;
	let current;

	button = new Button({
			props: { inline: true, small: true, icon: "close" }
		});

	button.$on("click", /*click_handler*/ ctx[4]);

	return {
		c() {
			create_component(button.$$.fragment);
			t0 = space();
			br0 = element("br");
			t1 = space();
			div1 = element("div");
			div0 = element("div");
			p0 = element("p");
			p0.innerHTML = `<img src="icons/oauth2/logo.svg" alt="oauth2"/>`;
			t2 = space();
			p1 = element("p");
			t3 = text(t3_value);
			t4 = space();
			p2 = element("p");
			p2.innerHTML = `<a href="https://www.ietf.org/rfc/rfc6749.txt" style="color: #2687E9; float: right;" target="_blank" title="The OAuth 2.0 Authorization Framework">rfc6749</a>`;
			t6 = space();
			br1 = element("br");
			set_style(p0, "float", "left");
			set_style(p1, "margin", "0");
			set_style(p2, "float", "right");
			set_style(div0, "display", "flex");
			set_style(div0, "flex-direction", "column");
			attr(div1, "class", "flex svelte-jgw5as");
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			insert(target, t0, anchor);
			insert(target, br0, anchor);
			insert(target, t1, anchor);
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, p0);
			append(div0, t2);
			append(div0, p1);
			append(p1, t3);
			append(div0, t4);
			append(div0, p2);
			insert(target, t6, anchor);
			insert(target, br1, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*$_*/ 4) && t3_value !== (t3_value = /*$_*/ ctx[2]('about.oauth2') + "")) set_data(t3, t3_value);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(br0);
			if (detaching) detach(t1);
			if (detaching) detach(div1);
			if (detaching) detach(t6);
			if (detaching) detach(br1);
		}
	};
}

// (86:3) {#each errorHandlingOptions as eOption}
function create_each_block$1(ctx) {
	let option;
	let t_value = /*eOption*/ ctx[10] + "";
	let t;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = /*eOption*/ ctx[10];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (79:2) <Select    bind:node    prop="errorHandling"    label={$_('general.errorHandling')}    icon="warning"    disabled={node.disableInput}   >
function create_default_slot_2$2(ctx) {
	let each_1_anchor;
	let each_value = /*errorHandlingOptions*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*errorHandlingOptions*/ 8) {
				each_value = /*errorHandlingOptions*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (68:1) <Group clazz="paddingBottom">
function create_default_slot_1$3(ctx) {
	let input;
	let updating_node;
	let t0;
	let typedinput;
	let updating_types;
	let updating_tooltip;
	let t1;
	let select;
	let updating_node_1;
	let current;

	function input_node_binding(value) {
		/*input_node_binding*/ ctx[5](value);
	}

	let input_props = {
		prop: "name",
		label: /*$_*/ ctx[2]('general.name')
	};

	if (/*node*/ ctx[0] !== void 0) {
		input_props.node = /*node*/ ctx[0];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'node', input_node_binding));

	function typedinput_types_binding(value) {
		/*typedinput_types_binding*/ ctx[6](value);
	}

	function typedinput_tooltip_binding(value) {
		/*typedinput_tooltip_binding*/ ctx[7](value);
	}

	let typedinput_props = {
		node: /*node*/ ctx[0],
		prop: "container",
		typeProp: "containerOpts",
		label: /*$_*/ ctx[2]('general.container'),
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*contentTypes*/ ctx[1] !== void 0) {
		typedinput_props.types = /*contentTypes*/ ctx[1];
	}

	if (/*node*/ ctx[0].container !== void 0) {
		typedinput_props.tooltip = /*node*/ ctx[0].container;
	}

	typedinput = new TypedInput({ props: typedinput_props });
	binding_callbacks.push(() => bind(typedinput, 'types', typedinput_types_binding));
	binding_callbacks.push(() => bind(typedinput, 'tooltip', typedinput_tooltip_binding));

	function select_node_binding(value) {
		/*select_node_binding*/ ctx[8](value);
	}

	let select_props = {
		prop: "errorHandling",
		label: /*$_*/ ctx[2]('general.errorHandling'),
		icon: "warning",
		disabled: /*node*/ ctx[0].disableInput,
		$$slots: { default: [create_default_slot_2$2] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select_props.node = /*node*/ ctx[0];
	}

	select = new Select({ props: select_props });
	binding_callbacks.push(() => bind(select, 'node', select_node_binding));

	return {
		c() {
			create_component(input.$$.fragment);
			t0 = space();
			create_component(typedinput.$$.fragment);
			t1 = space();
			create_component(select.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t0, anchor);
			mount_component(typedinput, target, anchor);
			insert(target, t1, anchor);
			mount_component(select, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};
			if (dirty & /*$_*/ 4) input_changes.label = /*$_*/ ctx[2]('general.name');

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				input_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input.$set(input_changes);
			const typedinput_changes = {};
			if (dirty & /*node*/ 1) typedinput_changes.node = /*node*/ ctx[0];
			if (dirty & /*$_*/ 4) typedinput_changes.label = /*$_*/ ctx[2]('general.container');
			if (dirty & /*node*/ 1) typedinput_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_types && dirty & /*contentTypes*/ 2) {
				updating_types = true;
				typedinput_changes.types = /*contentTypes*/ ctx[1];
				add_flush_callback(() => updating_types = false);
			}

			if (!updating_tooltip && dirty & /*node*/ 1) {
				updating_tooltip = true;
				typedinput_changes.tooltip = /*node*/ ctx[0].container;
				add_flush_callback(() => updating_tooltip = false);
			}

			typedinput.$set(typedinput_changes);
			const select_changes = {};
			if (dirty & /*$_*/ 4) select_changes.label = /*$_*/ ctx[2]('general.errorHandling');
			if (dirty & /*node*/ 1) select_changes.disabled = /*node*/ ctx[0].disableInput;

			if (dirty & /*$$scope*/ 8192) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node_1 && dirty & /*node*/ 1) {
				updating_node_1 = true;
				select_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			select.$set(select_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(typedinput.$$.fragment, local);
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(typedinput.$$.fragment, local);
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t0);
			destroy_component(typedinput, detaching);
			if (detaching) detach(t1);
			destroy_component(select, detaching);
		}
	};
}

// (67:0) <Collapsible label={$_('general.title')} indented={false} icon="globe">
function create_default_slot$4(ctx) {
	let group;
	let current;

	group = new Group({
			props: {
				clazz: "paddingBottom",
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(group.$$.fragment);
		},
		m(target, anchor) {
			mount_component(group, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const group_changes = {};

			if (dirty & /*$$scope, $_, node, contentTypes*/ 8199) {
				group_changes.$$scope = { dirty, ctx };
			}

			group.$set(group_changes);
		},
		i(local) {
			if (current) return;
			transition_in(group.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(group.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(group, detaching);
		}
	};
}

function create_fragment$5(ctx) {
	let t;
	let collapsible;
	let current;
	let if_block = /*node*/ ctx[0].showBanner && create_if_block$3(ctx);

	collapsible = new Collapsible({
			props: {
				label: /*$_*/ ctx[2]('general.title'),
				indented: false,
				icon: "globe",
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			create_component(collapsible.$$.fragment);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			mount_component(collapsible, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*node*/ ctx[0].showBanner) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*node*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const collapsible_changes = {};
			if (dirty & /*$_*/ 4) collapsible_changes.label = /*$_*/ ctx[2]('general.title');

			if (dirty & /*$$scope, $_, node, contentTypes*/ 8199) {
				collapsible_changes.$$scope = { dirty, ctx };
			}

			collapsible.$set(collapsible_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(collapsible.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(collapsible.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			destroy_component(collapsible, detaching);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let contentTypes;
	let $_;
	component_subscribe($$self, _, $$value => $$invalidate(2, $_ = $$value));
	let { node } = $$props;
	const errorHandlingOptions = [`${$_('standard.label')}`, 'other output', 'throw exception', 'all in one'];

	let testTypes = [
		{
			value: 'oauth2Response',
			label: 'default',
			icon: 'red/images/typedInput/bool.svg',
			options: [
				{
					value: 'oauth2Response',
					label: 'oauth2Response'
				},
				{ value: 'response', label: 'response' },
				{ value: 'payload', label: 'payload' }
			]
		}
	];

	const click_handler = () => $$invalidate(0, node.showBanner = false, node);

	function input_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function typedinput_types_binding(value) {
		contentTypes = value;
		($$invalidate(1, contentTypes), $$invalidate(9, testTypes));
	}

	function typedinput_tooltip_binding(value) {
		if ($$self.$$.not_equal(node.container, value)) {
			node.container = value;
			$$invalidate(0, node);
		}
	}

	function select_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
	};

	$$invalidate(1, contentTypes = [...['msg'], ...testTypes]);

	return [
		node,
		contentTypes,
		$_,
		errorHandlingOptions,
		click_handler,
		input_node_binding,
		typedinput_types_binding,
		typedinput_tooltip_binding,
		select_node_binding
	];
}

class General extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { node: 0 }, add_css$1);
	}
}

/* src/components/Proxy.svelte generated by Svelte v3.58.0 */

function create_default_slot_1$2(ctx) {
	let input;
	let current;

	input = new Input({
			props: {
				type: "config",
				node: /*node*/ ctx[0],
				prop: "proxy",
				disabled: /*node*/ ctx[0].disableInput
			}
		});

	return {
		c() {
			create_component(input.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};
			if (dirty & /*node*/ 1) input_changes.node = /*node*/ ctx[0];
			if (dirty & /*node*/ 1) input_changes.disabled = /*node*/ ctx[0].disableInput;
			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
		}
	};
}

// (8:0) <Group clazz="paddingAdvanced">
function create_default_slot$3(ctx) {
	let group;
	let current;

	group = new Group({
			props: {
				clazz: "paddingBottom",
				node: /*node*/ ctx[0],
				label: /*$_*/ ctx[1]("credentials.proxy"),
				icon: "minus",
				tooltip: /*$_*/ ctx[1]('tooltip.proxy'),
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(group.$$.fragment);
		},
		m(target, anchor) {
			mount_component(group, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const group_changes = {};
			if (dirty & /*node*/ 1) group_changes.node = /*node*/ ctx[0];
			if (dirty & /*$_*/ 2) group_changes.label = /*$_*/ ctx[1]("credentials.proxy");
			if (dirty & /*$_*/ 2) group_changes.tooltip = /*$_*/ ctx[1]('tooltip.proxy');

			if (dirty & /*$$scope, node*/ 5) {
				group_changes.$$scope = { dirty, ctx };
			}

			group.$set(group_changes);
		},
		i(local) {
			if (current) return;
			transition_in(group.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(group.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(group, detaching);
		}
	};
}

function create_fragment$4(ctx) {
	let group;
	let current;

	group = new Group({
			props: {
				clazz: "paddingAdvanced",
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(group.$$.fragment);
		},
		m(target, anchor) {
			mount_component(group, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const group_changes = {};

			if (dirty & /*$$scope, node, $_*/ 7) {
				group_changes.$$scope = { dirty, ctx };
			}

			group.$set(group_changes);
		},
		i(local) {
			if (current) return;
			transition_in(group.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(group.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(group, detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let $_;
	component_subscribe($$self, _, $$value => $$invalidate(1, $_ = $$value));
	let { node } = $$props;

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
	};

	return [node, $_];
}

class Proxy extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { node: 0 });
	}
}

/* src/components/Credentials.svelte generated by Svelte v3.58.0 */

function create_if_block_2(ctx) {
	let group;
	let current;

	group = new Group({
			props: {
				clazz: "paddingBottom",
				node: /*node*/ ctx[0],
				label: "label.settings",
				icon: "minus",
				tooltip: /*$_*/ ctx[5]('tooltip.settings'),
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(group.$$.fragment);
		},
		m(target, anchor) {
			mount_component(group, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const group_changes = {};
			if (dirty[0] & /*node*/ 1) group_changes.node = /*node*/ ctx[0];
			if (dirty[0] & /*$_*/ 32) group_changes.tooltip = /*$_*/ ctx[5]('tooltip.settings');

			if (dirty[0] & /*node, show_client_secret, show_code, $_*/ 45 | dirty[1] & /*$$scope*/ 2) {
				group_changes.$$scope = { dirty, ctx };
			}

			group.$set(group_changes);
		},
		i(local) {
			if (current) return;
			transition_in(group.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(group.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(group, detaching);
		}
	};
}

// (92:41) 
function create_if_block_1(ctx) {
	let group;
	let current;

	group = new Group({
			props: {
				clazz: "paddingBottom",
				node: /*node*/ ctx[0],
				label: "label.settings",
				icon: "minus",
				tooltip: /*$_*/ ctx[5]('tooltip.settings'),
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(group.$$.fragment);
		},
		m(target, anchor) {
			mount_component(group, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const group_changes = {};
			if (dirty[0] & /*node*/ 1) group_changes.node = /*node*/ ctx[0];
			if (dirty[0] & /*$_*/ 32) group_changes.tooltip = /*$_*/ ctx[5]('tooltip.settings');

			if (dirty[0] & /*$_, node, show_client_secret, show_password*/ 39 | dirty[1] & /*$$scope*/ 2) {
				group_changes.$$scope = { dirty, ctx };
			}

			group.$set(group_changes);
		},
		i(local) {
			if (current) return;
			transition_in(group.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(group.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(group, detaching);
		}
	};
}

// (82:1) {#if node.grantType === 'clientCredentials'}
function create_if_block$2(ctx) {
	let group;
	let current;

	group = new Group({
			props: {
				clazz: "paddingBottom",
				node: /*node*/ ctx[0],
				label: "label.settings",
				icon: "minus",
				tooltip: /*$_*/ ctx[5]('credentials.tooltip.clientCredentials'),
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(group.$$.fragment);
		},
		m(target, anchor) {
			mount_component(group, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const group_changes = {};
			if (dirty[0] & /*node*/ 1) group_changes.node = /*node*/ ctx[0];
			if (dirty[0] & /*$_*/ 32) group_changes.tooltip = /*$_*/ ctx[5]('credentials.tooltip.clientCredentials');

			if (dirty[0] & /*$_, node, show_client_secret*/ 37 | dirty[1] & /*$$scope*/ 2) {
				group_changes.$$scope = { dirty, ctx };
			}

			group.$set(group_changes);
		},
		i(local) {
			if (current) return;
			transition_in(group.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(group.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(group, detaching);
		}
	};
}

// (114:3) <Button inline icon={show_client_secret ? "eye" : "eye-slash"}  type="button" on:click="{ () => show_client_secret = !show_client_secret }">
function create_default_slot_13(ctx) {
	let t_value = (/*show_client_secret*/ ctx[2] ? 'Hide' : 'Show') + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*show_client_secret*/ 4 && t_value !== (t_value = (/*show_client_secret*/ ctx[2] ? 'Hide' : 'Show') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (112:3) <Row>
function create_default_slot_12(ctx) {
	let input;
	let updating_node;
	let t;
	let button;
	let current;

	function input_node_binding_3(value) {
		/*input_node_binding_3*/ ctx[27](value);
	}

	let input_props = {
		prop: "clientSecret",
		maximize: true,
		icon: "key",
		inline: true,
		label: /*$_*/ ctx[5]('credentials.clientSecret'),
		type: /*show_client_secret*/ ctx[2] ? "text" : "password",
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input_props.node = /*node*/ ctx[0];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'node', input_node_binding_3));

	button = new Button({
			props: {
				inline: true,
				icon: /*show_client_secret*/ ctx[2] ? "eye" : "eye-slash",
				type: "button",
				$$slots: { default: [create_default_slot_13] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler_3*/ ctx[28]);

	return {
		c() {
			create_component(input.$$.fragment);
			t = space();
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};
			if (dirty[0] & /*$_*/ 32) input_changes.label = /*$_*/ ctx[5]('credentials.clientSecret');
			if (dirty[0] & /*show_client_secret*/ 4) input_changes.type = /*show_client_secret*/ ctx[2] ? "text" : "password";
			if (dirty[0] & /*node*/ 1) input_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				input_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input.$set(input_changes);
			const button_changes = {};
			if (dirty[0] & /*show_client_secret*/ 4) button_changes.icon = /*show_client_secret*/ ctx[2] ? "eye" : "eye-slash";

			if (dirty[0] & /*show_client_secret*/ 4 | dirty[1] & /*$$scope*/ 2) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t);
			destroy_component(button, detaching);
		}
	};
}

// (119:3) <Button inline icon={show_client_secret ? "eye" : "eye-slash"}  type="button" on:click="{ () => show_code = !show_code }">
function create_default_slot_11(ctx) {
	let t_value = (/*show_code*/ ctx[3] ? 'Hide' : 'Show') + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*show_code*/ 8 && t_value !== (t_value = (/*show_code*/ ctx[3] ? 'Hide' : 'Show') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (117:3) <Row>
function create_default_slot_10(ctx) {
	let input;
	let updating_node;
	let t0;
	let button0;
	let t1;
	let button1;
	let current;

	function input_node_binding_4(value) {
		/*input_node_binding_4*/ ctx[30](value);
	}

	let input_props = {
		prop: "code",
		maximize: true,
		icon: "sign-in",
		inline: true,
		label: /*$_*/ ctx[5]('credentials.code'),
		type: /*show_code*/ ctx[3] ? "text" : "password",
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input_props.node = /*node*/ ctx[0];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'node', input_node_binding_4));

	button0 = new Button({
			props: {
				inline: true,
				icon: /*show_client_secret*/ ctx[2] ? "eye" : "eye-slash",
				type: "button",
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			}
		});

	button0.$on("click", /*click_handler_4*/ ctx[31]);

	button1 = new Button({
			props: {
				inline: true,
				icon: "key",
				disabled: /*node*/ ctx[0].disableInput
			}
		});

	button1.$on("click", /*onClick*/ ctx[6]);

	return {
		c() {
			create_component(input.$$.fragment);
			t0 = space();
			create_component(button0.$$.fragment);
			t1 = space();
			create_component(button1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t0, anchor);
			mount_component(button0, target, anchor);
			insert(target, t1, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};
			if (dirty[0] & /*$_*/ 32) input_changes.label = /*$_*/ ctx[5]('credentials.code');
			if (dirty[0] & /*show_code*/ 8) input_changes.type = /*show_code*/ ctx[3] ? "text" : "password";
			if (dirty[0] & /*node*/ 1) input_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				input_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input.$set(input_changes);
			const button0_changes = {};
			if (dirty[0] & /*show_client_secret*/ 4) button0_changes.icon = /*show_client_secret*/ ctx[2] ? "eye" : "eye-slash";

			if (dirty[0] & /*show_code*/ 8 | dirty[1] & /*$$scope*/ 2) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty[0] & /*node*/ 1) button1_changes.disabled = /*node*/ ctx[0].disableInput;
			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t0);
			destroy_component(button0, detaching);
			if (detaching) detach(t1);
			destroy_component(button1, detaching);
		}
	};
}

// (108:2) <Group clazz="paddingBottom" {node} label="label.settings" icon="minus" tooltip="{$_('tooltip.settings')}">
function create_default_slot_9(ctx) {
	let input0;
	let updating_node;
	let t0;
	let input1;
	let updating_node_1;
	let t1;
	let input2;
	let updating_node_2;
	let t2;
	let row0;
	let t3;
	let input3;
	let updating_node_3;
	let t4;
	let row1;
	let current;

	function input0_node_binding_2(value) {
		/*input0_node_binding_2*/ ctx[24](value);
	}

	let input0_props = {
		prop: "accessTokenUrl",
		maximize: true,
		icon: "link",
		label: /*$_*/ ctx[5]('credentials.accessTokenUrl'),
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input0_props.node = /*node*/ ctx[0];
	}

	input0 = new Input({ props: input0_props });
	binding_callbacks.push(() => bind(input0, 'node', input0_node_binding_2));

	function input1_node_binding_2(value) {
		/*input1_node_binding_2*/ ctx[25](value);
	}

	let input1_props = {
		prop: "authorizationEndpoint",
		maximize: true,
		icon: "link",
		label: /*$_*/ ctx[5]('credentials.authorizationEndpoint'),
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input1_props.node = /*node*/ ctx[0];
	}

	input1 = new Input({ props: input1_props });
	binding_callbacks.push(() => bind(input1, 'node', input1_node_binding_2));

	function input2_node_binding_2(value) {
		/*input2_node_binding_2*/ ctx[26](value);
	}

	let input2_props = {
		prop: "clientId",
		maximize: true,
		icon: "id-card",
		label: /*$_*/ ctx[5]('credentials.clientId'),
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input2_props.node = /*node*/ ctx[0];
	}

	input2 = new Input({ props: input2_props });
	binding_callbacks.push(() => bind(input2, 'node', input2_node_binding_2));

	row0 = new Row({
			props: {
				$$slots: { default: [create_default_slot_12] },
				$$scope: { ctx }
			}
		});

	function input3_node_binding_1(value) {
		/*input3_node_binding_1*/ ctx[29](value);
	}

	let input3_props = {
		prop: "scope",
		maximize: true,
		icon: "code",
		label: /*$_*/ ctx[5]('credentials.scope'),
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input3_props.node = /*node*/ ctx[0];
	}

	input3 = new Input({ props: input3_props });
	binding_callbacks.push(() => bind(input3, 'node', input3_node_binding_1));

	row1 = new Row({
			props: {
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(input0.$$.fragment);
			t0 = space();
			create_component(input1.$$.fragment);
			t1 = space();
			create_component(input2.$$.fragment);
			t2 = space();
			create_component(row0.$$.fragment);
			t3 = space();
			create_component(input3.$$.fragment);
			t4 = space();
			create_component(row1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input0, target, anchor);
			insert(target, t0, anchor);
			mount_component(input1, target, anchor);
			insert(target, t1, anchor);
			mount_component(input2, target, anchor);
			insert(target, t2, anchor);
			mount_component(row0, target, anchor);
			insert(target, t3, anchor);
			mount_component(input3, target, anchor);
			insert(target, t4, anchor);
			mount_component(row1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input0_changes = {};
			if (dirty[0] & /*$_*/ 32) input0_changes.label = /*$_*/ ctx[5]('credentials.accessTokenUrl');
			if (dirty[0] & /*node*/ 1) input0_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				input0_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input0.$set(input0_changes);
			const input1_changes = {};
			if (dirty[0] & /*$_*/ 32) input1_changes.label = /*$_*/ ctx[5]('credentials.authorizationEndpoint');
			if (dirty[0] & /*node*/ 1) input1_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node_1 && dirty[0] & /*node*/ 1) {
				updating_node_1 = true;
				input1_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			input1.$set(input1_changes);
			const input2_changes = {};
			if (dirty[0] & /*$_*/ 32) input2_changes.label = /*$_*/ ctx[5]('credentials.clientId');
			if (dirty[0] & /*node*/ 1) input2_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node_2 && dirty[0] & /*node*/ 1) {
				updating_node_2 = true;
				input2_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_2 = false);
			}

			input2.$set(input2_changes);
			const row0_changes = {};

			if (dirty[0] & /*show_client_secret, $_, node*/ 37 | dirty[1] & /*$$scope*/ 2) {
				row0_changes.$$scope = { dirty, ctx };
			}

			row0.$set(row0_changes);
			const input3_changes = {};
			if (dirty[0] & /*$_*/ 32) input3_changes.label = /*$_*/ ctx[5]('credentials.scope');
			if (dirty[0] & /*node*/ 1) input3_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node_3 && dirty[0] & /*node*/ 1) {
				updating_node_3 = true;
				input3_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_3 = false);
			}

			input3.$set(input3_changes);
			const row1_changes = {};

			if (dirty[0] & /*node, show_client_secret, show_code, $_*/ 45 | dirty[1] & /*$$scope*/ 2) {
				row1_changes.$$scope = { dirty, ctx };
			}

			row1.$set(row1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input0.$$.fragment, local);
			transition_in(input1.$$.fragment, local);
			transition_in(input2.$$.fragment, local);
			transition_in(row0.$$.fragment, local);
			transition_in(input3.$$.fragment, local);
			transition_in(row1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input0.$$.fragment, local);
			transition_out(input1.$$.fragment, local);
			transition_out(input2.$$.fragment, local);
			transition_out(row0.$$.fragment, local);
			transition_out(input3.$$.fragment, local);
			transition_out(row1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input0, detaching);
			if (detaching) detach(t0);
			destroy_component(input1, detaching);
			if (detaching) detach(t1);
			destroy_component(input2, detaching);
			if (detaching) detach(t2);
			destroy_component(row0, detaching);
			if (detaching) detach(t3);
			destroy_component(input3, detaching);
			if (detaching) detach(t4);
			destroy_component(row1, detaching);
		}
	};
}

// (98:3) <Button inline icon={show_password ? "eye" : "eye-slash"}  type="button" on:click="{ () => show_password = !show_password }">
function create_default_slot_8$1(ctx) {
	let t_value = (/*show_password*/ ctx[1] ? 'Hide' : 'Show') + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*show_password*/ 2 && t_value !== (t_value = (/*show_password*/ ctx[1] ? 'Hide' : 'Show') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (96:3) <Row>
function create_default_slot_7$1(ctx) {
	let input;
	let updating_node;
	let t;
	let button;
	let current;

	function input_node_binding_1(value) {
		/*input_node_binding_1*/ ctx[18](value);
	}

	let input_props = {
		prop: "password",
		maximize: true,
		inline: true,
		icon: "key",
		label: /*$_*/ ctx[5]('credentials.password'),
		type: /*show_password*/ ctx[1] ? "text" : "password",
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input_props.node = /*node*/ ctx[0];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'node', input_node_binding_1));

	button = new Button({
			props: {
				inline: true,
				icon: /*show_password*/ ctx[1] ? "eye" : "eye-slash",
				type: "button",
				$$slots: { default: [create_default_slot_8$1] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler_1*/ ctx[19]);

	return {
		c() {
			create_component(input.$$.fragment);
			t = space();
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};
			if (dirty[0] & /*$_*/ 32) input_changes.label = /*$_*/ ctx[5]('credentials.password');
			if (dirty[0] & /*show_password*/ 2) input_changes.type = /*show_password*/ ctx[1] ? "text" : "password";
			if (dirty[0] & /*node*/ 1) input_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				input_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input.$set(input_changes);
			const button_changes = {};
			if (dirty[0] & /*show_password*/ 2) button_changes.icon = /*show_password*/ ctx[1] ? "eye" : "eye-slash";

			if (dirty[0] & /*show_password*/ 2 | dirty[1] & /*$$scope*/ 2) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t);
			destroy_component(button, detaching);
		}
	};
}

// (103:3) <Button inline icon={show_client_secret ? "eye" : "eye-slash"}  type="button" on:click="{ () => show_client_secret = !show_client_secret }">
function create_default_slot_6$1(ctx) {
	let t_value = (/*show_client_secret*/ ctx[2] ? 'Hide' : 'Show') + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*show_client_secret*/ 4 && t_value !== (t_value = (/*show_client_secret*/ ctx[2] ? 'Hide' : 'Show') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (101:3) <Row>
function create_default_slot_5$1(ctx) {
	let input;
	let updating_node;
	let t;
	let button;
	let current;

	function input_node_binding_2(value) {
		/*input_node_binding_2*/ ctx[21](value);
	}

	let input_props = {
		prop: "clientSecret",
		maximize: true,
		icon: "key",
		inline: true,
		label: /*$_*/ ctx[5]('credentials.clientSecret'),
		type: /*show_client_secret*/ ctx[2] ? "text" : "password",
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input_props.node = /*node*/ ctx[0];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'node', input_node_binding_2));

	button = new Button({
			props: {
				inline: true,
				icon: /*show_client_secret*/ ctx[2] ? "eye" : "eye-slash",
				type: "button",
				$$slots: { default: [create_default_slot_6$1] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler_2*/ ctx[22]);

	return {
		c() {
			create_component(input.$$.fragment);
			t = space();
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};
			if (dirty[0] & /*$_*/ 32) input_changes.label = /*$_*/ ctx[5]('credentials.clientSecret');
			if (dirty[0] & /*show_client_secret*/ 4) input_changes.type = /*show_client_secret*/ ctx[2] ? "text" : "password";
			if (dirty[0] & /*node*/ 1) input_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				input_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input.$set(input_changes);
			const button_changes = {};
			if (dirty[0] & /*show_client_secret*/ 4) button_changes.icon = /*show_client_secret*/ ctx[2] ? "eye" : "eye-slash";

			if (dirty[0] & /*show_client_secret*/ 4 | dirty[1] & /*$$scope*/ 2) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t);
			destroy_component(button, detaching);
		}
	};
}

// (93:2) <Group clazz="paddingBottom" {node} label="label.settings" icon="minus" tooltip="{$_('tooltip.settings')}">
function create_default_slot_4$1(ctx) {
	let input0;
	let updating_node;
	let t0;
	let input1;
	let updating_node_1;
	let t1;
	let row0;
	let t2;
	let input2;
	let updating_node_2;
	let t3;
	let row1;
	let t4;
	let input3;
	let updating_node_3;
	let current;

	function input0_node_binding_1(value) {
		/*input0_node_binding_1*/ ctx[16](value);
	}

	let input0_props = {
		prop: "accessTokenUrl",
		maximize: true,
		icon: "link",
		label: /*$_*/ ctx[5]('credentials.accessTokenUrl'),
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input0_props.node = /*node*/ ctx[0];
	}

	input0 = new Input({ props: input0_props });
	binding_callbacks.push(() => bind(input0, 'node', input0_node_binding_1));

	function input1_node_binding_1(value) {
		/*input1_node_binding_1*/ ctx[17](value);
	}

	let input1_props = {
		prop: "userName",
		maximize: true,
		icon: "user",
		label: /*$_*/ ctx[5]('credentials.userName'),
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input1_props.node = /*node*/ ctx[0];
	}

	input1 = new Input({ props: input1_props });
	binding_callbacks.push(() => bind(input1, 'node', input1_node_binding_1));

	row0 = new Row({
			props: {
				$$slots: { default: [create_default_slot_7$1] },
				$$scope: { ctx }
			}
		});

	function input2_node_binding_1(value) {
		/*input2_node_binding_1*/ ctx[20](value);
	}

	let input2_props = {
		prop: "clientId",
		maximize: true,
		icon: "id-card",
		label: /*$_*/ ctx[5]('credentials.clientId'),
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input2_props.node = /*node*/ ctx[0];
	}

	input2 = new Input({ props: input2_props });
	binding_callbacks.push(() => bind(input2, 'node', input2_node_binding_1));

	row1 = new Row({
			props: {
				$$slots: { default: [create_default_slot_5$1] },
				$$scope: { ctx }
			}
		});

	function input3_node_binding(value) {
		/*input3_node_binding*/ ctx[23](value);
	}

	let input3_props = {
		prop: "scope",
		maximize: true,
		icon: "code",
		label: /*$_*/ ctx[5]('credentials.scope'),
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input3_props.node = /*node*/ ctx[0];
	}

	input3 = new Input({ props: input3_props });
	binding_callbacks.push(() => bind(input3, 'node', input3_node_binding));

	return {
		c() {
			create_component(input0.$$.fragment);
			t0 = space();
			create_component(input1.$$.fragment);
			t1 = space();
			create_component(row0.$$.fragment);
			t2 = space();
			create_component(input2.$$.fragment);
			t3 = space();
			create_component(row1.$$.fragment);
			t4 = space();
			create_component(input3.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input0, target, anchor);
			insert(target, t0, anchor);
			mount_component(input1, target, anchor);
			insert(target, t1, anchor);
			mount_component(row0, target, anchor);
			insert(target, t2, anchor);
			mount_component(input2, target, anchor);
			insert(target, t3, anchor);
			mount_component(row1, target, anchor);
			insert(target, t4, anchor);
			mount_component(input3, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input0_changes = {};
			if (dirty[0] & /*$_*/ 32) input0_changes.label = /*$_*/ ctx[5]('credentials.accessTokenUrl');
			if (dirty[0] & /*node*/ 1) input0_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				input0_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input0.$set(input0_changes);
			const input1_changes = {};
			if (dirty[0] & /*$_*/ 32) input1_changes.label = /*$_*/ ctx[5]('credentials.userName');
			if (dirty[0] & /*node*/ 1) input1_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node_1 && dirty[0] & /*node*/ 1) {
				updating_node_1 = true;
				input1_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			input1.$set(input1_changes);
			const row0_changes = {};

			if (dirty[0] & /*show_password, $_, node*/ 35 | dirty[1] & /*$$scope*/ 2) {
				row0_changes.$$scope = { dirty, ctx };
			}

			row0.$set(row0_changes);
			const input2_changes = {};
			if (dirty[0] & /*$_*/ 32) input2_changes.label = /*$_*/ ctx[5]('credentials.clientId');
			if (dirty[0] & /*node*/ 1) input2_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node_2 && dirty[0] & /*node*/ 1) {
				updating_node_2 = true;
				input2_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_2 = false);
			}

			input2.$set(input2_changes);
			const row1_changes = {};

			if (dirty[0] & /*show_client_secret, $_, node*/ 37 | dirty[1] & /*$$scope*/ 2) {
				row1_changes.$$scope = { dirty, ctx };
			}

			row1.$set(row1_changes);
			const input3_changes = {};
			if (dirty[0] & /*$_*/ 32) input3_changes.label = /*$_*/ ctx[5]('credentials.scope');
			if (dirty[0] & /*node*/ 1) input3_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node_3 && dirty[0] & /*node*/ 1) {
				updating_node_3 = true;
				input3_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_3 = false);
			}

			input3.$set(input3_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input0.$$.fragment, local);
			transition_in(input1.$$.fragment, local);
			transition_in(row0.$$.fragment, local);
			transition_in(input2.$$.fragment, local);
			transition_in(row1.$$.fragment, local);
			transition_in(input3.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input0.$$.fragment, local);
			transition_out(input1.$$.fragment, local);
			transition_out(row0.$$.fragment, local);
			transition_out(input2.$$.fragment, local);
			transition_out(row1.$$.fragment, local);
			transition_out(input3.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input0, detaching);
			if (detaching) detach(t0);
			destroy_component(input1, detaching);
			if (detaching) detach(t1);
			destroy_component(row0, detaching);
			if (detaching) detach(t2);
			destroy_component(input2, detaching);
			if (detaching) detach(t3);
			destroy_component(row1, detaching);
			if (detaching) detach(t4);
			destroy_component(input3, detaching);
		}
	};
}

// (88:3) <Button inline icon={show_client_secret ? "eye" : "eye-slash"}  type="button" on:click="{ () => show_client_secret = !show_client_secret }">
function create_default_slot_3$1(ctx) {
	let t_value = (/*show_client_secret*/ ctx[2] ? 'Hide' : 'Show') + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*show_client_secret*/ 4 && t_value !== (t_value = (/*show_client_secret*/ ctx[2] ? 'Hide' : 'Show') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (86:3) <Row>
function create_default_slot_2$1(ctx) {
	let input;
	let updating_node;
	let t;
	let button;
	let current;

	function input_node_binding(value) {
		/*input_node_binding*/ ctx[13](value);
	}

	let input_props = {
		prop: "clientSecret",
		maximize: true,
		icon: "key",
		inline: true,
		label: /*$_*/ ctx[5]('credentials.clientSecret'),
		type: /*show_client_secret*/ ctx[2] ? "text" : "password",
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input_props.node = /*node*/ ctx[0];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'node', input_node_binding));

	button = new Button({
			props: {
				inline: true,
				icon: /*show_client_secret*/ ctx[2] ? "eye" : "eye-slash",
				type: "button",
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler*/ ctx[14]);

	return {
		c() {
			create_component(input.$$.fragment);
			t = space();
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};
			if (dirty[0] & /*$_*/ 32) input_changes.label = /*$_*/ ctx[5]('credentials.clientSecret');
			if (dirty[0] & /*show_client_secret*/ 4) input_changes.type = /*show_client_secret*/ ctx[2] ? "text" : "password";
			if (dirty[0] & /*node*/ 1) input_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				input_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input.$set(input_changes);
			const button_changes = {};
			if (dirty[0] & /*show_client_secret*/ 4) button_changes.icon = /*show_client_secret*/ ctx[2] ? "eye" : "eye-slash";

			if (dirty[0] & /*show_client_secret*/ 4 | dirty[1] & /*$$scope*/ 2) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t);
			destroy_component(button, detaching);
		}
	};
}

// (83:2) <Group clazz="paddingBottom" {node} label="label.settings" icon="minus" tooltip="{$_('credentials.tooltip.clientCredentials')}">
function create_default_slot_1$1(ctx) {
	let input0;
	let updating_node;
	let t0;
	let input1;
	let updating_node_1;
	let t1;
	let row;
	let t2;
	let input2;
	let updating_node_2;
	let current;

	function input0_node_binding(value) {
		/*input0_node_binding*/ ctx[11](value);
	}

	let input0_props = {
		prop: "accessTokenUrl",
		maximize: true,
		icon: "link",
		label: /*$_*/ ctx[5]('credentials.accessTokenUrl'),
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input0_props.node = /*node*/ ctx[0];
	}

	input0 = new Input({ props: input0_props });
	binding_callbacks.push(() => bind(input0, 'node', input0_node_binding));

	function input1_node_binding(value) {
		/*input1_node_binding*/ ctx[12](value);
	}

	let input1_props = {
		prop: "clientId",
		maximize: true,
		icon: "id-card",
		label: /*$_*/ ctx[5]('credentials.clientId'),
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input1_props.node = /*node*/ ctx[0];
	}

	input1 = new Input({ props: input1_props });
	binding_callbacks.push(() => bind(input1, 'node', input1_node_binding));

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			}
		});

	function input2_node_binding(value) {
		/*input2_node_binding*/ ctx[15](value);
	}

	let input2_props = {
		prop: "scope",
		maximize: true,
		icon: "code",
		label: /*$_*/ ctx[5]('credentials.scope'),
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		input2_props.node = /*node*/ ctx[0];
	}

	input2 = new Input({ props: input2_props });
	binding_callbacks.push(() => bind(input2, 'node', input2_node_binding));

	return {
		c() {
			create_component(input0.$$.fragment);
			t0 = space();
			create_component(input1.$$.fragment);
			t1 = space();
			create_component(row.$$.fragment);
			t2 = space();
			create_component(input2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input0, target, anchor);
			insert(target, t0, anchor);
			mount_component(input1, target, anchor);
			insert(target, t1, anchor);
			mount_component(row, target, anchor);
			insert(target, t2, anchor);
			mount_component(input2, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input0_changes = {};
			if (dirty[0] & /*$_*/ 32) input0_changes.label = /*$_*/ ctx[5]('credentials.accessTokenUrl');
			if (dirty[0] & /*node*/ 1) input0_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				input0_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input0.$set(input0_changes);
			const input1_changes = {};
			if (dirty[0] & /*$_*/ 32) input1_changes.label = /*$_*/ ctx[5]('credentials.clientId');
			if (dirty[0] & /*node*/ 1) input1_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node_1 && dirty[0] & /*node*/ 1) {
				updating_node_1 = true;
				input1_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			input1.$set(input1_changes);
			const row_changes = {};

			if (dirty[0] & /*show_client_secret, $_, node*/ 37 | dirty[1] & /*$$scope*/ 2) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
			const input2_changes = {};
			if (dirty[0] & /*$_*/ 32) input2_changes.label = /*$_*/ ctx[5]('credentials.scope');
			if (dirty[0] & /*node*/ 1) input2_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node_2 && dirty[0] & /*node*/ 1) {
				updating_node_2 = true;
				input2_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_2 = false);
			}

			input2.$set(input2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input0.$$.fragment, local);
			transition_in(input1.$$.fragment, local);
			transition_in(row.$$.fragment, local);
			transition_in(input2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input0.$$.fragment, local);
			transition_out(input1.$$.fragment, local);
			transition_out(row.$$.fragment, local);
			transition_out(input2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input0, detaching);
			if (detaching) detach(t0);
			destroy_component(input1, detaching);
			if (detaching) detach(t1);
			destroy_component(row, detaching);
			if (detaching) detach(t2);
			destroy_component(input2, detaching);
		}
	};
}

// (80:0) <Group clazz="paddingBottom">
function create_default_slot$2(ctx) {
	let typedinput;
	let updating_node;
	let updating_types;
	let updating_tooltip;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	function typedinput_node_binding(value) {
		/*typedinput_node_binding*/ ctx[8](value);
	}

	function typedinput_types_binding(value) {
		/*typedinput_types_binding*/ ctx[9](value);
	}

	function typedinput_tooltip_binding(value) {
		/*typedinput_tooltip_binding*/ ctx[10](value);
	}

	let typedinput_props = {
		inline: true,
		prop: "grantType",
		label: /*$_*/ ctx[5]('credentials.grantType'),
		typeProp: "grantOpts",
		disabled: /*node*/ ctx[0].disableInput
	};

	if (/*node*/ ctx[0] !== void 0) {
		typedinput_props.node = /*node*/ ctx[0];
	}

	if (/*grantOpts*/ ctx[4] !== void 0) {
		typedinput_props.types = /*grantOpts*/ ctx[4];
	}

	if (/*node*/ ctx[0].grantType !== void 0) {
		typedinput_props.tooltip = /*node*/ ctx[0].grantType;
	}

	typedinput = new TypedInput({ props: typedinput_props });
	binding_callbacks.push(() => bind(typedinput, 'node', typedinput_node_binding));
	binding_callbacks.push(() => bind(typedinput, 'types', typedinput_types_binding));
	binding_callbacks.push(() => bind(typedinput, 'tooltip', typedinput_tooltip_binding));
	const if_block_creators = [create_if_block$2, create_if_block_1, create_if_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*node*/ ctx[0].grantType === 'clientCredentials') return 0;
		if (/*node*/ ctx[0].grantType === 'password') return 1;
		if (/*node*/ ctx[0].grantType === 'authorizationCode') return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			create_component(typedinput.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(typedinput, target, anchor);
			insert(target, t, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const typedinput_changes = {};
			if (dirty[0] & /*$_*/ 32) typedinput_changes.label = /*$_*/ ctx[5]('credentials.grantType');
			if (dirty[0] & /*node*/ 1) typedinput_changes.disabled = /*node*/ ctx[0].disableInput;

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				typedinput_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_types && dirty[0] & /*grantOpts*/ 16) {
				updating_types = true;
				typedinput_changes.types = /*grantOpts*/ ctx[4];
				add_flush_callback(() => updating_types = false);
			}

			if (!updating_tooltip && dirty[0] & /*node*/ 1) {
				updating_tooltip = true;
				typedinput_changes.tooltip = /*node*/ ctx[0].grantType;
				add_flush_callback(() => updating_tooltip = false);
			}

			typedinput.$set(typedinput_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(typedinput.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(typedinput.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(typedinput, detaching);
			if (detaching) detach(t);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$3(ctx) {
	let group;
	let current;

	group = new Group({
			props: {
				clazz: "paddingBottom",
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(group.$$.fragment);
		},
		m(target, anchor) {
			mount_component(group, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const group_changes = {};

			if (dirty[0] & /*node, $_, show_client_secret, show_password, show_code, grantOpts*/ 63 | dirty[1] & /*$$scope*/ 2) {
				group_changes.$$scope = { dirty, ctx };
			}

			group.$set(group_changes);
		},
		i(local) {
			if (current) return;
			transition_in(group.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(group.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(group, detaching);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let grantOpts;
	let $_;
	component_subscribe($$self, _, $$value => $$invalidate(5, $_ = $$value));
	let { node, data } = $$props;
	let show_password = false;
	let show_client_secret = false;
	let show_code = false;

	function onClick() {
		let url;

		if (node.authorizationEndpoint) {
			url = `oauth2/auth?id=${encodeURIComponent(node.id)}&clientId=${encodeURIComponent(node.clientId)}&clientSecret=${encodeURIComponent(node.clientSecret)}&scope=${encodeURIComponent(node.scope)}&callback=${encodeURIComponent(node.callback)}&authorizationEndpoint=${encodeURIComponent(node.authorizationEndpoint)}&redirectUri=${encodeURIComponent(node.redirectUri)}&proxy=${encodeURIComponent(node.proxy)}`;
		} else {
			url = `oauth2/auth?id=${encodeURIComponent(node.id)}&clientId=${encodeURIComponent(node.clientId)}&clientSecret=${encodeURIComponent(node.clientSecret)}&scope=${encodeURIComponent(node.scope)}&callback=${encodeURIComponent(node.callback)}&proxy=${encodeURIComponent(node.proxy)}`;
		}

		Object.assign(document.createElement('a'), {
			target: '_blank',
			rel: 'noopener noreferrer',
			href: url
		}).click();

		const getCode = async function () {
			const res = await fetch(`oauth2/credentials/${node.id}`);
			$$invalidate(7, data = await res.json());

			if (res.ok) {
				$$invalidate(7, data);
				$$invalidate(0, node.code = data.code, node);
			} else {
				throw new Error(data);
			}
		};

		window.configNodeIntervalId = window.setTimeout(getCode, 5000);
	}

	function typedinput_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function typedinput_types_binding(value) {
		grantOpts = value;
		$$invalidate(4, grantOpts);
	}

	function typedinput_tooltip_binding(value) {
		if ($$self.$$.not_equal(node.grantType, value)) {
			node.grantType = value;
			$$invalidate(0, node);
		}
	}

	function input0_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input1_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	const click_handler = () => $$invalidate(2, show_client_secret = !show_client_secret);

	function input2_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input0_node_binding_1(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input1_node_binding_1(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input_node_binding_1(value) {
		node = value;
		$$invalidate(0, node);
	}

	const click_handler_1 = () => $$invalidate(1, show_password = !show_password);

	function input2_node_binding_1(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input_node_binding_2(value) {
		node = value;
		$$invalidate(0, node);
	}

	const click_handler_2 = () => $$invalidate(2, show_client_secret = !show_client_secret);

	function input3_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input0_node_binding_2(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input1_node_binding_2(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input2_node_binding_2(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input_node_binding_3(value) {
		node = value;
		$$invalidate(0, node);
	}

	const click_handler_3 = () => $$invalidate(2, show_client_secret = !show_client_secret);

	function input3_node_binding_1(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input_node_binding_4(value) {
		node = value;
		$$invalidate(0, node);
	}

	const click_handler_4 = () => $$invalidate(3, show_code = !show_code);

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
		if ('data' in $$props) $$invalidate(7, data = $$props.data);
	};

	$$invalidate(4, grantOpts = [
		{
			value: 'oauth2Request',
			label: 'grant type',
			icon: 'red/images/typedInput/bool.svg',
			options: [
				{
					value: 'oauth2Request',
					label: 'Set by msg.oauth2Request'
				},
				{
					value: 'clientCredentials',
					label: 'Client Credentials'
				},
				{ value: 'password', label: 'Password' },
				{
					value: 'authorizationCode',
					label: 'Authorization Code'
				}
			]
		}
	]);

	return [
		node,
		show_password,
		show_client_secret,
		show_code,
		grantOpts,
		$_,
		onClick,
		data,
		typedinput_node_binding,
		typedinput_types_binding,
		typedinput_tooltip_binding,
		input0_node_binding,
		input1_node_binding,
		input_node_binding,
		click_handler,
		input2_node_binding,
		input0_node_binding_1,
		input1_node_binding_1,
		input_node_binding_1,
		click_handler_1,
		input2_node_binding_1,
		input_node_binding_2,
		click_handler_2,
		input3_node_binding,
		input0_node_binding_2,
		input1_node_binding_2,
		input2_node_binding_2,
		input_node_binding_3,
		click_handler_3,
		input3_node_binding_1,
		input_node_binding_4,
		click_handler_4
	];
}

class Credentials extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { node: 0, data: 7 }, null, [-1, -1]);
	}
}

/* src/components/Yell.svelte generated by Svelte v3.58.0 */

function create_default_slot$1(ctx) {
	let t;

	return {
		c() {
			t = text(/*message*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*message*/ 1) set_data(t, /*message*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (20:2) 
function create_header_slot(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error";
			attr(span, "slot", "header");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function create_fragment$2(ctx) {
	let div;
	let callout;
	let div_outro;
	let current;

	callout = new Callout({
			props: {
				type: "error",
				$$slots: {
					header: [create_header_slot],
					default: [create_default_slot$1]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(callout, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const callout_changes = {};

			if (dirty & /*$$scope, message*/ 5) {
				callout_changes.$$scope = { dirty, ctx };
			}

			callout.$set(callout_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			if (div_outro) div_outro.end(1);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			div_outro = create_out_transition(div, fade, {});
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(callout);
			if (detaching && div_outro) div_outro.end();
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { message } = $$props;

	onMount(() => {
		setTimeout(
			function () {
				dispatch('delete', {});
			},
			3000
		);
	});

	$$self.$$set = $$props => {
		if ('message' in $$props) $$invalidate(0, message = $$props.message);
	};

	return [message];
}

class Yell extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { message: 0 });
	}
}

/**
 * Creates a backward compatible object by assigning default values to properties if they are undefined.
 *
 * @param {object} obj - The object to make backward compatible.
 * @returns {void}
 */
const CreateBackwardCompatible = (obj) => {
  if (typeof obj.name === 'undefined') obj.name = '';
  if (typeof obj.container === 'undefined') obj.container = '';
  if (typeof obj.containerOpts === 'undefined') obj.containerOpts = '';
  if (typeof obj.errorHandling === 'undefined') obj.errorHandling = '';

  if (typeof obj.grantType === 'undefined') obj.grantType = '';
  if (typeof obj.grantOpts === 'undefined') obj.grantOpts = '';
  if (typeof obj.accessTokenUrl === 'undefined') obj.accessTokenUrl = '';
  if (typeof obj.clientSecret === 'undefined') obj.clientSecret = '';
  if (typeof obj.clientId === 'undefined') obj.clientId = '';
  if (typeof obj.scope === 'undefined') obj.scope = '';
  if (typeof obj.userName === 'undefined') obj.userName = '';
  if (typeof obj.password === 'undefined') obj.password = '';
  if (typeof obj.authorizationEndpoint === 'undefined') obj.authorizationEndpoint = '';
  if (typeof obj.code === 'undefined') obj.code = '';

  if (typeof obj.internalErrors === 'undefined') obj.internalErrors = {};
  if (typeof obj.devMode === 'undefined') obj.devMode = false;
  if (typeof obj.keepAuth === 'undefined') obj.keepAuth = false;
  if (typeof obj.rejectUnauthorized === 'undefined') obj.rejectUnauthorized = false;
  if (typeof obj.clientCredentialsInBody === 'undefined') obj.clientCredentialsInBody = false;
  if (typeof obj.headers === 'undefined') obj.headers = {};
  if (typeof obj.proxy === 'undefined') obj.proxy = '';
  if (typeof obj.language === 'undefined') obj.language = '';

  if (typeof obj.showBanner === 'undefined') obj.showBanner = false;
  if (typeof obj.disableInput === 'undefined') obj.disableInput = false;
};

var utils = {
  CreateBackwardCompatible
};

/* node_modules/carbon-icons-svelte/lib/Assembly.svelte generated by Svelte v3.58.0 */

function create_if_block$1(ctx) {
	let title_1;
	let t;

	return {
		c() {
			title_1 = svg_element("title");
			t = text(/*title*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, title_1, anchor);
			append(title_1, t);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 2) set_data(t, /*title*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(title_1);
		}
	};
}

function create_fragment$1(ctx) {
	let svg;
	let path0;
	let path1;
	let if_block = /*title*/ ctx[1] && create_if_block$1(ctx);

	let svg_levels = [
		{ xmlns: "http://www.w3.org/2000/svg" },
		{ viewBox: "0 0 32 32" },
		{ fill: "currentColor" },
		{ preserveAspectRatio: "xMidYMid meet" },
		{ width: /*size*/ ctx[0] },
		{ height: /*size*/ ctx[0] },
		/*attributes*/ ctx[2],
		/*$$restProps*/ ctx[3]
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M16,25.4l-8-4.7v-9.4l8-4.7l8,4.7v9.4L16,25.4z M10,19.6l6,3.5l6-3.5v-7.1l-6-3.5l-6,3.5V19.6z");
			attr(path1, "d", "M27,8.2L17,2.3C16.7,2.1,16.4,2,16,2s-0.7,0.1-1,0.3L5,8.2c-0.6,0.4-1,1-1,1.7v12.2c0,0.7,0.4,1.4,1,1.7l10,5.9\tc0.3,0.2,0.7,0.3,1,0.3s0.7-0.1,1-0.3l10-5.9c0.6-0.4,1-1,1-1.7V9.9C28,9.2,27.6,8.5,27,8.2z M26,22.1L16,28L6,22.1V9.9L16,4l10,5.9\tV22.1z");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			if (/*title*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(svg, path0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				{ xmlns: "http://www.w3.org/2000/svg" },
				{ viewBox: "0 0 32 32" },
				{ fill: "currentColor" },
				{ preserveAspectRatio: "xMidYMid meet" },
				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
				dirty & /*attributes*/ 4 && /*attributes*/ ctx[2],
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
			if (if_block) if_block.d();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let labelled;
	let attributes;
	const omit_props_names = ["size","title"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { size = 16 } = $$props;
	let { title = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
		if ('title' in $$new_props) $$invalidate(1, title = $$new_props.title);
	};

	$$self.$$.update = () => {
		$$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);

		$$invalidate(2, attributes = {
			"aria-hidden": labelled ? undefined : true,
			role: labelled ? "img" : undefined,
			focusable: Number($$props["tabindex"]) === 0 ? true : undefined
		});
	};

	$$props = exclude_internal_props($$props);
	return [size, title, attributes, $$restProps, labelled];
}

class Assembly extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { size: 0, title: 1 });
	}
}

/* src/oauth2.svelte generated by Svelte v3.58.0 */

function add_css(target) {
	append_styles(target, "svelte-19i8ud4", "#oauth2-svelte-container :is(.required, .required label){font-weight:bold !important}#oauth2-svelte-container .sir-Row label{min-width:150px}#oauth2-svelte-container .sir-Row label i{min-width:14px}.sir-Group.paddingBottom > .sir-Group-container{padding-bottom:12px}.success .fa-check-square{color:var(--red-ui-text-color-success)}.sir-Group.paddingAdvanced > .sir-Group-container{background-color:#ffe;padding-bottom:12px}");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[20] = list[i];
	return child_ctx;
}

// (191:0) {#each messages as message}
function create_each_block(ctx) {
	let yell;
	let current;
	yell = new Yell({ props: { message: /*message*/ ctx[20] } });
	yell.$on("delete", /*deleteMessage*/ ctx[6]);

	return {
		c() {
			create_component(yell.$$.fragment);
		},
		m(target, anchor) {
			mount_component(yell, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const yell_changes = {};
			if (dirty & /*messages*/ 8) yell_changes.message = /*message*/ ctx[20];
			yell.$set(yell_changes);
		},
		i(local) {
			if (current) return;
			transition_in(yell.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(yell.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(yell, detaching);
		}
	};
}

// (201:2) <Collapsible {node} indented={false} icon="key" label="{$_("credentials.title")}">
function create_default_slot_8(ctx) {
	let credentials;
	let updating_node;
	let updating_data;
	let current;

	function credentials_node_binding(value) {
		/*credentials_node_binding*/ ctx[10](value);
	}

	function credentials_data_binding(value) {
		/*credentials_data_binding*/ ctx[11](value);
	}

	let credentials_props = {};

	if (/*node*/ ctx[0] !== void 0) {
		credentials_props.node = /*node*/ ctx[0];
	}

	if (/*data*/ ctx[1] !== void 0) {
		credentials_props.data = /*data*/ ctx[1];
	}

	credentials = new Credentials({ props: credentials_props });
	binding_callbacks.push(() => bind(credentials, 'node', credentials_node_binding));
	binding_callbacks.push(() => bind(credentials, 'data', credentials_data_binding));

	return {
		c() {
			create_component(credentials.$$.fragment);
		},
		m(target, anchor) {
			mount_component(credentials, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const credentials_changes = {};

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				credentials_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_data && dirty & /*data*/ 2) {
				updating_data = true;
				credentials_changes.data = /*data*/ ctx[1];
				add_flush_callback(() => updating_data = false);
			}

			credentials.$set(credentials_changes);
		},
		i(local) {
			if (current) return;
			transition_in(credentials.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(credentials.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(credentials, detaching);
		}
	};
}

// (205:2) <Collapsible {node} indented={false} icon="key" label="{$_("credentials.settings")}">
function create_default_slot_7(ctx) {
	let proxy;
	let updating_node;
	let updating_data;
	let current;

	function proxy_node_binding(value) {
		/*proxy_node_binding*/ ctx[12](value);
	}

	function proxy_data_binding(value) {
		/*proxy_data_binding*/ ctx[13](value);
	}

	let proxy_props = {};

	if (/*node*/ ctx[0] !== void 0) {
		proxy_props.node = /*node*/ ctx[0];
	}

	if (/*data*/ ctx[1] !== void 0) {
		proxy_props.data = /*data*/ ctx[1];
	}

	proxy = new Proxy({ props: proxy_props });
	binding_callbacks.push(() => bind(proxy, 'node', proxy_node_binding));
	binding_callbacks.push(() => bind(proxy, 'data', proxy_data_binding));

	return {
		c() {
			create_component(proxy.$$.fragment);
		},
		m(target, anchor) {
			mount_component(proxy, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const proxy_changes = {};

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				proxy_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_data && dirty & /*data*/ 2) {
				updating_data = true;
				proxy_changes.data = /*data*/ ctx[1];
				add_flush_callback(() => updating_data = false);
			}

			proxy.$set(proxy_changes);
		},
		i(local) {
			if (current) return;
			transition_in(proxy.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(proxy.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(proxy, detaching);
		}
	};
}

// (209:2) {#if node.headers}
function create_if_block(ctx) {
	let collapsible;
	let current;

	collapsible = new Collapsible({
			props: {
				indented: false,
				label: /*$_*/ ctx[4]("credentials.Headers"),
				icon: "list",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(collapsible.$$.fragment);
		},
		m(target, anchor) {
			mount_component(collapsible, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const collapsible_changes = {};
			if (dirty & /*$_*/ 16) collapsible_changes.label = /*$_*/ ctx[4]("credentials.Headers");

			if (dirty & /*$$scope, $_, node*/ 8388625) {
				collapsible_changes.$$scope = { dirty, ctx };
			}

			collapsible.$set(collapsible_changes);
		},
		i(local) {
			if (current) return;
			transition_in(collapsible.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(collapsible.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(collapsible, detaching);
		}
	};
}

// (213:3) <Row>
function create_default_slot_6(ctx) {
	let input;
	let updating_value;
	let t;
	let typedinput;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[14](value, /*index*/ ctx[19]);
	}

	let input_props = { inline: true, placeholder: "key" };

	if (/*node*/ ctx[0].headers[/*index*/ ctx[19]].key !== void 0) {
		input_props.value = /*node*/ ctx[0].headers[/*index*/ ctx[19]].key;
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding));

	function change_handler(...args) {
		return /*change_handler*/ ctx[15](/*index*/ ctx[19], ...args);
	}

	typedinput = new TypedInput({
			props: {
				inline: true,
				value: /*node*/ ctx[0].headers[/*index*/ ctx[19]].value,
				type: /*node*/ ctx[0].headers[/*index*/ ctx[19]].type,
				types: ["str", "num", "bool", "json"],
				placeholder: "value"
			}
		});

	typedinput.$on("change", change_handler);

	return {
		c() {
			create_component(input.$$.fragment);
			t = space();
			create_component(typedinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t, anchor);
			mount_component(typedinput, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const input_changes = {};

			if (!updating_value && dirty & /*node, index*/ 524289) {
				updating_value = true;
				input_changes.value = /*node*/ ctx[0].headers[/*index*/ ctx[19]].key;
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
			const typedinput_changes = {};
			if (dirty & /*node, index*/ 524289) typedinput_changes.value = /*node*/ ctx[0].headers[/*index*/ ctx[19]].value;
			if (dirty & /*node, index*/ 524289) typedinput_changes.type = /*node*/ ctx[0].headers[/*index*/ ctx[19]].type;
			typedinput.$set(typedinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(typedinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(typedinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t);
			destroy_component(typedinput, detaching);
		}
	};
}

// (212:4) <EditableList id="headersList" sortable removable addButton label="{$_("credentials.Headers.Parameters")}" icon="database"  bind:elements={node.headers} let:index on:add={addHeaders} >
function create_default_slot_5(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};

			if (dirty & /*$$scope, node, index*/ 8912897) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

// (211:4) <Group clazz="paddingBottom">
function create_default_slot_4(ctx) {
	let editablelist;
	let updating_elements;
	let current;

	function editablelist_elements_binding(value) {
		/*editablelist_elements_binding*/ ctx[16](value);
	}

	let editablelist_props = {
		id: "headersList",
		sortable: true,
		removable: true,
		addButton: true,
		label: /*$_*/ ctx[4]("credentials.Headers.Parameters"),
		icon: "database",
		$$slots: {
			default: [
				create_default_slot_5,
				({ index }) => ({ 19: index }),
				({ index }) => index ? 524288 : 0
			]
		},
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0].headers !== void 0) {
		editablelist_props.elements = /*node*/ ctx[0].headers;
	}

	editablelist = new EditableList({ props: editablelist_props });
	binding_callbacks.push(() => bind(editablelist, 'elements', editablelist_elements_binding));
	editablelist.$on("add", /*addHeaders*/ ctx[5]);

	return {
		c() {
			create_component(editablelist.$$.fragment);
		},
		m(target, anchor) {
			mount_component(editablelist, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const editablelist_changes = {};
			if (dirty & /*$_*/ 16) editablelist_changes.label = /*$_*/ ctx[4]("credentials.Headers.Parameters");

			if (dirty & /*$$scope, node, index*/ 8912897) {
				editablelist_changes.$$scope = { dirty, ctx };
			}

			if (!updating_elements && dirty & /*node*/ 1) {
				updating_elements = true;
				editablelist_changes.elements = /*node*/ ctx[0].headers;
				add_flush_callback(() => updating_elements = false);
			}

			editablelist.$set(editablelist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(editablelist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(editablelist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(editablelist, detaching);
		}
	};
}

// (210:2) <Collapsible indented={false} label="{$_("credentials.Headers")}" icon="list">
function create_default_slot_3(ctx) {
	let group;
	let current;

	group = new Group({
			props: {
				clazz: "paddingBottom",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(group.$$.fragment);
		},
		m(target, anchor) {
			mount_component(group, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const group_changes = {};

			if (dirty & /*$$scope, $_, node*/ 8388625) {
				group_changes.$$scope = { dirty, ctx };
			}

			group.$set(group_changes);
		},
		i(local) {
			if (current) return;
			transition_in(group.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(group.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(group, detaching);
		}
	};
}

// (197:1) <TabContent tab="general">
function create_default_slot_2(ctx) {
	let general;
	let updating_node;
	let updating_data;
	let t0;
	let collapsible0;
	let t1;
	let collapsible1;
	let t2;
	let if_block_anchor;
	let current;

	function general_node_binding(value) {
		/*general_node_binding*/ ctx[8](value);
	}

	function general_data_binding(value) {
		/*general_data_binding*/ ctx[9](value);
	}

	let general_props = {};

	if (/*node*/ ctx[0] !== void 0) {
		general_props.node = /*node*/ ctx[0];
	}

	if (/*data*/ ctx[1] !== void 0) {
		general_props.data = /*data*/ ctx[1];
	}

	general = new General({ props: general_props });
	binding_callbacks.push(() => bind(general, 'node', general_node_binding));
	binding_callbacks.push(() => bind(general, 'data', general_data_binding));

	collapsible0 = new Collapsible({
			props: {
				node: /*node*/ ctx[0],
				indented: false,
				icon: "key",
				label: /*$_*/ ctx[4]("credentials.title"),
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			}
		});

	collapsible1 = new Collapsible({
			props: {
				node: /*node*/ ctx[0],
				indented: false,
				icon: "key",
				label: /*$_*/ ctx[4]("credentials.settings"),
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			}
		});

	let if_block = /*node*/ ctx[0].headers && create_if_block(ctx);

	return {
		c() {
			create_component(general.$$.fragment);
			t0 = space();
			create_component(collapsible0.$$.fragment);
			t1 = space();
			create_component(collapsible1.$$.fragment);
			t2 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(general, target, anchor);
			insert(target, t0, anchor);
			mount_component(collapsible0, target, anchor);
			insert(target, t1, anchor);
			mount_component(collapsible1, target, anchor);
			insert(target, t2, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const general_changes = {};

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				general_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_data && dirty & /*data*/ 2) {
				updating_data = true;
				general_changes.data = /*data*/ ctx[1];
				add_flush_callback(() => updating_data = false);
			}

			general.$set(general_changes);
			const collapsible0_changes = {};
			if (dirty & /*node*/ 1) collapsible0_changes.node = /*node*/ ctx[0];
			if (dirty & /*$_*/ 16) collapsible0_changes.label = /*$_*/ ctx[4]("credentials.title");

			if (dirty & /*$$scope, node, data*/ 8388611) {
				collapsible0_changes.$$scope = { dirty, ctx };
			}

			collapsible0.$set(collapsible0_changes);
			const collapsible1_changes = {};
			if (dirty & /*node*/ 1) collapsible1_changes.node = /*node*/ ctx[0];
			if (dirty & /*$_*/ 16) collapsible1_changes.label = /*$_*/ ctx[4]("credentials.settings");

			if (dirty & /*$$scope, node, data*/ 8388611) {
				collapsible1_changes.$$scope = { dirty, ctx };
			}

			collapsible1.$set(collapsible1_changes);

			if (/*node*/ ctx[0].headers) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*node*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(general.$$.fragment, local);
			transition_in(collapsible0.$$.fragment, local);
			transition_in(collapsible1.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(general.$$.fragment, local);
			transition_out(collapsible0.$$.fragment, local);
			transition_out(collapsible1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(general, detaching);
			if (detaching) detach(t0);
			destroy_component(collapsible0, detaching);
			if (detaching) detach(t1);
			destroy_component(collapsible1, detaching);
			if (detaching) detach(t2);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (227:1) <TabContent tab="advanced">
function create_default_slot_1(ctx) {
	let advanced;
	let updating_node;
	let current;

	function advanced_node_binding(value) {
		/*advanced_node_binding*/ ctx[17](value);
	}

	let advanced_props = {};

	if (/*node*/ ctx[0] !== void 0) {
		advanced_props.node = /*node*/ ctx[0];
	}

	advanced = new Advanced({ props: advanced_props });
	binding_callbacks.push(() => bind(advanced, 'node', advanced_node_binding));

	return {
		c() {
			create_component(advanced.$$.fragment);
		},
		m(target, anchor) {
			mount_component(advanced, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const advanced_changes = {};

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				advanced_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			advanced.$set(advanced_changes);
		},
		i(local) {
			if (current) return;
			transition_in(advanced.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(advanced.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(advanced, detaching);
		}
	};
}

// (196:0) <TabbedPane bind:tabs>
function create_default_slot(ctx) {
	let tabcontent0;
	let t;
	let tabcontent1;
	let current;

	tabcontent0 = new TabContent({
			props: {
				tab: "general",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	tabcontent1 = new TabContent({
			props: {
				tab: "advanced",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(tabcontent0.$$.fragment);
			t = space();
			create_component(tabcontent1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tabcontent0, target, anchor);
			insert(target, t, anchor);
			mount_component(tabcontent1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tabcontent0_changes = {};

			if (dirty & /*$$scope, $_, node, data*/ 8388627) {
				tabcontent0_changes.$$scope = { dirty, ctx };
			}

			tabcontent0.$set(tabcontent0_changes);
			const tabcontent1_changes = {};

			if (dirty & /*$$scope, node*/ 8388609) {
				tabcontent1_changes.$$scope = { dirty, ctx };
			}

			tabcontent1.$set(tabcontent1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tabcontent0.$$.fragment, local);
			transition_in(tabcontent1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tabcontent0.$$.fragment, local);
			transition_out(tabcontent1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tabcontent0, detaching);
			if (detaching) detach(t);
			destroy_component(tabcontent1, detaching);
		}
	};
}

function create_fragment(ctx) {
	let t0;
	let div;
	let assembly;
	let t1;
	let tabbedpane;
	let updating_tabs;
	let current;
	let mounted;
	let dispose;
	let each_value = /*messages*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	assembly = new Assembly({ props: { size: 32 } });

	function tabbedpane_tabs_binding(value) {
		/*tabbedpane_tabs_binding*/ ctx[18](value);
	}

	let tabbedpane_props = {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*tabs*/ ctx[2] !== void 0) {
		tabbedpane_props.tabs = /*tabs*/ ctx[2];
	}

	tabbedpane = new TabbedPane({ props: tabbedpane_props });
	binding_callbacks.push(() => bind(tabbedpane, 'tabs', tabbedpane_tabs_binding));

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			div = element("div");
			create_component(assembly.$$.fragment);
			t1 = space();
			create_component(tabbedpane.$$.fragment);
			attr(div, "class", "bottom");
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, t0, anchor);
			insert(target, div, anchor);
			mount_component(assembly, div, null);
			insert(target, t1, anchor);
			mount_component(tabbedpane, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(div, "mouseenter", /*Click*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*messages, deleteMessage*/ 72) {
				each_value = /*messages*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(t0.parentNode, t0);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const tabbedpane_changes = {};

			if (dirty & /*$$scope, node, $_, data*/ 8388627) {
				tabbedpane_changes.$$scope = { dirty, ctx };
			}

			if (!updating_tabs && dirty & /*tabs*/ 4) {
				updating_tabs = true;
				tabbedpane_changes.tabs = /*tabs*/ ctx[2];
				add_flush_callback(() => updating_tabs = false);
			}

			tabbedpane.$set(tabbedpane_changes);
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(assembly.$$.fragment, local);
			transition_in(tabbedpane.$$.fragment, local);
			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(assembly.$$.fragment, local);
			transition_out(tabbedpane.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div);
			destroy_component(assembly);
			if (detaching) detach(t1);
			destroy_component(tabbedpane, detaching);
			mounted = false;
			dispose();
		}
	};
}

const render = sir_render;
const update = sir_update;
const revert = sir_revert;
const addCurrentNodeVersion = sir_addCurrentNodeVersion;

RED.nodes.registerType('oauth2', {
	paletteLabel: 'oauth2',
	category: 'payment methods',
	color: '#fff',
	defaults: {
		name: {
			value: '',
			label: 'label.name',
			placeholder: 'placeholder.name',
			icon: 'tag'
		},
		container: {
			value: '',
			label: 'label.container',
			icon: 'cube',
			placeholder: 'placeholder.container',
			validate: RED.validators.typedInput('containerOpts')
		},
		containerOpts: { value: 'oauth2Response' },
		errorHandling: {
			value: 'standard',
			label: 'label.errorHandling'
		},
		grantType: {
			value: '',
			label: 'label.grantType',
			icon: 'lock',
			validate: RED.validators.typedInput('grantOpts')
		},
		grantOpts: { value: 'oauth2Request' },
		accessTokenUrl: {
			value: '',
			label: 'label.accessTokenUrl',
			placeholder: 'placeholder.accessTokenUrl'
		},
		clientId: {
			value: '',
			placeholder: 'placeholder.clientId'
		},
		clientSecret: {
			value: '',
			placeholder: 'placeholder.clientSecret'
		},
		scope: {
			value: '',
			placeholder: 'placeholder.scope'
		},
		userName: {
			value: '',
			placeholder: 'placeholder.userName'
		},
		password: {
			value: '',
			placeholder: 'placeholder.password'
		},
		authorizationEndpoint: {
			value: '',
			placeholder: 'placeholder.authorizationEndpoint'
		},
		code: {
			value: '',
			placeholder: 'placeholder.code'
		},
		internalErrors: { value: {} },
		rejectUnauthorized: {
			value: false,
			label: 'label.rejectUnauthorized',
			icon: 'lock'
		},
		clientCredentialsInBody: {
			value: false,
			label: 'label.clientCredentialsInBody',
			icon: 'lock'
		},
		headers: {
			value: [{ key: '', value: '', type: 'str' }],
			label: 'label.headers'
		},
		disableInput: {
			value: false,
			label: 'label.disableInput',
			icon: 'lock'
		},
		clientCredentialsInBody: { value: true },
		language: { value: 'pt-BR' },
		keepAuth: {
			value: false,
			label: 'Keep authentification',
			icon: 'lock'
		},
		devMode: {
			value: false,
			label: 'Development Mode',
			icon: 'at'
		},
		showBanner: {
			value: true,
			label: 'Show Banner',
			icon: 'eye'
		},
		proxy: {
			type: 'http proxy',
			required: false,
			label: RED._('node-red:httpin.proxy-config')
		},
		outputs: { value: 1 }
	},
	inputs: 1,
	outputs: 1,
	icon: 'icons/oauth2/logo-x16.svg',
	i18nOptions: {
		// If there should be translation, each DOM needs the object 'node' (mostly it's already bound) or a 'i18n' property with the path to the folder e.g.: node.name + ':'.
		// if the node is not in the main folder, set here the folder name (which is in this case the same name as the node)
		folder: 'oauth2/'
	},
	label() {
		if (this.name) return this.name; else //  else if (this.operation) return this.operation
		return 'OAuth2 Svelte';
	},
	oneditprepare() {
		var pathname = document.location.pathname;

		if (pathname.slice(-1) != '/') {
			pathname += '/';
		}

		this.callback = '';
		var privateIPRegex = /(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)/;

		if (privateIPRegex.test(location.hostname)) {
			// if private IP has been detected
			var dummyDomain = 'node-red.example.com';
			this.callback = `${location.protocol}//${dummyDomain}${location.port ? ':' + location.port : ''}${pathname}oauth2/auth/callback`;
		} else {
			this.callback = `${location.protocol}//${location.hostname}${location.port ? ':' + location.port : ''}${pathname}oauth2/auth/callback`;
		}

		this.redirectUri = `${location.protocol}//${location.hostname}${location.port ? ':' + location.port : ''}${pathname}oauth2/redirect`;
		console.log(this.language);
		console.log(this.callback);
		render(this, { minWidth: '600px' });
	},
	oneditsave() {
		update(this);
		this.outputs = 'other output' === this.errorHandling ? 2 : 1;
	},
	oneditcancel() {
		revert(this);
	},
	onadd() {
		addCurrentNodeVersion(this);
	}
});

function instance($$self, $$props, $$invalidate) {
	let $_;
	component_subscribe($$self, _, $$value => $$invalidate(4, $_ = $$value));
	let { node, data } = $$props;
	utils.createBackwardCompatible(node);
	node.internalErrors.readUrl = false;
	let tabs = { general: 'General', advanced: 'Advanced' };

	const addHeaders = () => {
		node.headers.push({ key: '', value: '', type: 'str' });
		$$invalidate(0, node);
	};

	let messages = [];

	function deleteMessage(event) {
		// delete first element in arr
		$$invalidate(3, messages = messages.slice(1));

		console.log(messages);
	}

	let Click = () => {
		$$invalidate(3, messages = [data]);
	};

	function general_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function general_data_binding(value) {
		data = value;
		$$invalidate(1, data);
	}

	function credentials_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function credentials_data_binding(value) {
		data = value;
		$$invalidate(1, data);
	}

	function proxy_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function proxy_data_binding(value) {
		data = value;
		$$invalidate(1, data);
	}

	function input_value_binding(value, index) {
		if ($$self.$$.not_equal(node.headers[index].key, value)) {
			node.headers[index].key = value;
			$$invalidate(0, node);
		}
	}

	const change_handler = (index, e) => {
		$$invalidate(0, node.headers[index].type = e.detail.type, node);
		$$invalidate(0, node.headers[index].value = e.detail.value, node);
	};

	function editablelist_elements_binding(value) {
		if ($$self.$$.not_equal(node.headers, value)) {
			node.headers = value;
			$$invalidate(0, node);
		}
	}

	function advanced_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function tabbedpane_tabs_binding(value) {
		tabs = value;
		$$invalidate(2, tabs);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
		if ('data' in $$props) $$invalidate(1, data = $$props.data);
	};

	return [
		node,
		data,
		tabs,
		messages,
		$_,
		addHeaders,
		deleteMessage,
		Click,
		general_node_binding,
		general_data_binding,
		credentials_node_binding,
		credentials_data_binding,
		proxy_node_binding,
		proxy_data_binding,
		input_value_binding,
		change_handler,
		editablelist_elements_binding,
		advanced_node_binding,
		tabbedpane_tabs_binding
	];
}

class Oauth2 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { node: 0, data: 1 }, add_css);
	}
}



  }
</script>
<script type="text/x-red" data-template-name="oauth2">
  <div id='oauth2-svelte-container'></div>
</script>
<script type="text/markdown" data-help-name="oauth2">
    
The `oauth2` Node-RED node enables `OAuth2 authentication` and provides an `access token` for authenticated API requests.

### Inputs

: container (string) : This refers to the name of the container that is intended to receive the message object. By default, it is set to oauth2Response.
: grant type (object) : This specifies the grant type used to obtain the access token.
: access token url (string) : This is the URL used to obtain the access token.
: client id (string) : This is the unique identifier for the client application.
: client secret (string) : This is the secret key used to authenticate the client application.

- grant: `password`
  : username (string) : This is the username used for authentication.
  : password (string) : This is the password used for authentication.

- grant type: `authorization code`
  : authorization endpoint (string) : This is the URL of the authorization endpoint.
  : code (string) : This is the authorization code. _read only_

: scope (string) : This specifies the scope of the access request.

: use proxy (boolean) : This specifies whether to use a proxy or not.

- use proxy: `true`
  : Proxy Configuration (object) : This specifies the configuration for the proxy.

: only send non-2xx responses to catch node (boolean) : This specifies whether to only catch non-2xx responses.
: embedded credentials (boolean) : This specifies whether to include the client credentials in the token request body for authentication purposes.
: reject Unauthorized (boolean) : This specifies whether to reject unauthorized requests. The rejectUnauthorized parameter controls SSL/TLS certificate validation for the server, with true enforcing validation and false disabling it.

**`Note:`**

> - If running behind a proxy, the standard `http_proxy=...` environment variable should be set and `Node-RED restarted, or use Proxy Configuration`. If Proxy Configuration was set, the configuration take precedence over environment variable.

> - The OAuth redirect URL is set by default to `/oauth2/redirect`, which is the endpoint responsible for receiving the authorization `code`.

### Outputs

: access_token (string) : This is the access token obtained from the OAuth2 server.
: expires_in (number) : This is the duration of time, in seconds, until the access token expires.
: token_type (string) : This is the type of the token. For example, "Bearer".
: scope (string) : This specifies the scope of the access granted by the token obtained.
: refresh_token (string) : This is the refresh token that can be used to obtain a new access token before the current one expires.

### Details

The `msg.oauth2Request` object contains the OAuth2 request details that are set by the node. The following are the different types of credentials that can be used for authentication:

# `Client Credentials`

The client credentials can be sent as part of the message payload to the node. The `msg.oauth2Request.credentials` object should contain the following properties:

- `grant_type` (string): This specifies the grant type. For dynamic credentials, the value should be set to "client_credentials".
- `client_id` (string): This is the client ID of the OAuth2 client.
- `client_secret` (string): This is the client secret of the OAuth2 client.
- `scope` (string): This specifies the scope of the access requested.

Here's an example:

```js
msg.oauth2Request = {
	access_token_url: 'http://localhost:8080/v1/oauth/tokens',
	credentials: {
		grant_type: 'client_credentials',
		client_id: 'test_client_1',
		client_secret: 'test_secret',
		scope: 'read_write'
	}
}
return msg
```

# `Password`

The username and password can be sent as part of the message payload to the node. The `msg.oauth2Request.credentials` object should contain the following properties:

- `grant_type` (string): This specifies the grant type. For password credentials, the value should be set to "password".
- `client_id` (string): This is the client ID of the OAuth2 client.
- `client_secret` (string): This is the client secret of the OAuth2 client.
- `scope` (string): This specifies the scope of the access requested.
- `username` (string): This is the username of the user.
- `password` (string): This is the password of the user.

Here's an example:

```js
msg.oauth2Request = {
	access_token_url: 'http://localhost:8080/v1/oauth/tokens',
	credentials: {
		grant_type: 'password',
		client_id: 'test_client_1',
		client_secret: 'test_secret',
		scope: 'read_write',
		username: 'test@user',
		password: 'test_password'
	}
}
return msg
```

# `refresh_token`

A refresh token can be used to obtain a new access token without requiring the user to re-authenticate. The `msg.oauth2Request.credentials` object should contain the following properties:

- `grant_type` (string): This specifies the grant type. For refresh token credentials, the value should be set to "refresh_token".
- `client_id` (string): This is the client ID of the OAuth2 client.
- `client_secret` (string): This is the client secret of the OAuth2 client.
- `scope` (string): This specifies the scope of the access requested.
- `refresh_token` (string): This is the refresh token obtained from a previous authentication.

Here's an example:

```js
let refresh_token = global.get('refresh_token')

msg.oauth2Request = {
	access_token_url: 'http://localhost:8080/v1/oauth/tokens',
	credentials: {
		grant_type: 'refresh_token',
		client_id: 'test_client_1',
		client_secret: 'test_secret',
		scope: 'read_write',
		refresh_token: refresh_token
	}
}
return msg
```

### References

- `RFC 6749` - [The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749)
- `RFC 5849` - [The OAuth 1.0 Protocol](https://www.rfc-editor.org/rfc/rfc5849)

</script>
